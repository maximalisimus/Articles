<html>
<head>
	<meta charset="utf-8">
	<title>Безопасность сетевых соединений</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/firewall-favicon.ico">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css"> -->
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Безопасность сетевых соединений</p>
			</div>
		</div>
		<div class="content">
			<center>
				<h1>Теория и практика.</h1>
			</center>
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/Superman-Linux-jpg.jpg" width="150px"/>
				</div>
				<div style="clear:both"></div>
			</center>
			</br>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Пароли</a></li>
				<li><a href="#part2">Настройка роутеров и маршрутизаторв</a></li>
				<li><a href="#part3">Настройка безопасности ssh соединений</a></li>
				<li><a href="#part4">Фаервол</a></li>
				<li><a href="#part5.0">Fail2ban</a></li>
				<ol>
					<li><a href="#part5.1">Установка и запуск</a></li>
					<li><a href="#part5.2">Базовая настройка</a></li>
					<li><a href="#part5.3">Настройка правил</a></li>
					<li><a href="#part5.4">NGINX DDoS (req limit)</a></li>
					<li><a href="#part5.5">Работа со списком заблокированных адресов</a></li>
					<li><a href="#part5.6">Примеры правил</a></li>
					<li><a href="#part5.7">Удаление</a></li>
				</ol>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>Пароли.</h2>
			<p>
				Первое что каждый пользователь хочет услышать – ваше соединение максимально защищено. Но так ли это на самом деле? Так ли безопасны соединения с вашими серверами как мы думаем? Будь то сервер контроля версий GIT, файловый сервер или любой другой.
			</p><p>
				Наливайте приятную для вас жидкость, присаживайтесь поудобнее – будет интересно.
			</p><p>
				У любого продвинутого пользователя всегда имеется электронная почта. А если он ещё и по совместительству системный администратор, то скорее всего для упрощения рабочей нагрузки, он почти наверняка будет везде использовать одинаковые пароли. Конечно один пароль легче запомнить, но так делать категорически не стоит. Такое допущение упрощает работу злоумышленникам, а вам добавляет нервного напряжения, что наверняка скажется на вашем здоровье. Хорошенько задумайтесь перед тем, как использовать одинаковые пароли. Хорошо, если вы отделаетесь лёгким испугом, но надеятся на это никогда не стоит. Необходимо забодится о безопасности своих данных заблаговременно.
			</p><p>
				Мы можем бесконечно углубляться в тему паролей, но всё-таки коснёмся нескольких важных вопросов, которые повысят ваш уровень знаний, сохранят не толко ваши нервы, а злоумышленникам значительно усложнят работу.
			</p><p>
				С одной стороны все прекрасно знают какие комбинации для паролей не стоит использовать.  С другой стороны запоминать гигантскую строку из различного набора знаков, которую вам создал генератор паролей также не является выходом, ведь вы можете забыть один из символов, что только прибавит вам головной боли пока вы всё вспомните. Сохранять пароль даже на USB носитель не всегда оправдывает себя, т. к. вашим носителем могут воспользоваться нечестные на руку коллеги по работе. Флеш-карту также легко можно случайно где-нибудь забыть или обранить. Нет, я конечно не призываю вас не сохранять ваши пароли или не использовать генераторы, я просто предостерегаю вас от таких казусов, до того как они произошли. 
			</p><p>
				Так как же поступить в такой сложной ситуации, чтобы не запутаться и не забыть свой пароль, особенно если он не один? 
			</p><p>
				Всё гениальное просто. Вам достаточно придумать и запомнить свою определенную цепочку символов из которых будут состоять ваши пароли, т. е. придумать алгоритм, по которому они и будут создаваться с одной только помощью вашей умной головы. А дальше дело техники. Восстановить подобные пароли по памяти не составит труда. Приведу простой пример. Пусть тестовая цепочка паролей будет состоять из следующего набора символов: 1) дата выхода одного из любимых сериалов вместе с точками, 2) Слитное написание фамилии и имени героя выбранного сериала в пункте 1. Такой комбинации уже будет достаточно. Например: «19.11.2020SamVinchester».
			</p><p>
				24 символа. Неплохо, правда? Такая задача злоумышленникам будет явно не по силам. Разумеется данную комбинацию уже не стоит использовать. Она приведена только в качестве примера, а алгоритм вы должны будете придумать самостоятельно под свои нужды. Теперь созданные наборы паролей можно записать на отдельную Флеш-карту и хранить дома в сейфе за 7 замками. Шучу конечно. Просто использовать лишь в крайнем случае.
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h2>Настройка роутеров и маршрутизаторв.</h2>
			<p>Теперь немного уделим внимания настройкам ваших роутеров и маршрутизаторов.</p>
			<p>
				Многие из вас, дорогие друзья, даже не догадываются насколько они уязвимы. А ведь такое упущение может принести для вас много головной боли. Давайте же это исправим.
			</p><p>
				Кусайте печеньку, запивайте чайком, а я пока что приведу пример настроек роутера TP-Link WR741. В других роутера, например D-Link, ищите аналогичные меню и настройки. 
			</p><p>
				Первое что необходимо изменить в конфигурации – это имя администратора и пароль. Теперь доступ к вашему роутеру ограничен, но пока ещё уязвим. После этого найдите настройку базовой защиты, а именно – межсетевой экран, VPN и ALG. Все указанные пункты необходимо установить в положение «Включить». Сохраните настройки и перейдите в следующий пункт настройки безопасности: «Защита от Dos атак» и также установите в положение «Включить». Не забудьте в этом же меню установить галочки напротив всех остальных пунктов с наименованием - «включить фильтрацию от атак…». 
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-1.jpg" class="fz__minimized" alt="клик для увеличения" title="Настройка базовой защиты" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-2.jpg" class="fz__minimized" alt="клик для увеличения" title="Расширенные настройки защиты" />
			</div>	
			<p>
				Приведу ещё одну настройку, в которой можно легко ошибиться. В этом же меню безопасности имеется пункт «Локальное управление». По умолчанию настройка установлена в положение «Всем компьютерам в локальной сети…». Многие пользователи устанавливают её во второе положение - «Только указанным компьютерам…». Перед изменением этой настройки необходимо обратить внимание на кнопочку возле пункта «Mac-адрес вашего компьютера». Во многих роутерах на ней указано – «Добавить». В моём же роутере (TL-841L), на этой кнопке написано: «Копировать». Т.е. прошивка моего роутера не позволяет добавлять новые Mac-адреса. Будьте осторожны с этой настройкой. Иначе может возникнуть ситуация, что у вас самого не будет доступа к настройкам вашего маршрутизатора и его придётся сбрасывать к заводским настройкам. Вообщем, только потеряте время и деньги. Думаю, данную настройку стоит оставить по умолчанию.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-3.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-4.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление2" />
			</div>
			<p>Также не забудьте про протокол UPnP.</p>
			<p>UPnP - это протокол, который позволяет приложениям и другим устройствам в вашей сети автоматически открывать и закрывать порты для подключения друг к другу. Например, если вы решили подключить принтер ко всем устройствам в доме без UPnP, то вам потребуется сделать это вручную, уделяя внимание каждому отдельному девайсу. Но благодаря UPnP можно автоматизировать этот процесс.</p>
			<p>С поддержкой UPnP они могут автоматически подключаться к сети, получать IP-адрес, находить другие устройства в сети и подключаться к ним, и это очень удобно.</p>
			<p>Первоначально предполагалось, что UPnP будет работать только на уровне локальной сети, что означает, что устройства только в вашей сети могут подключаться друг к другу. Однако многие производители маршрутизаторов теперь включают UPnP по умолчанию, что делает их доступными для обнаружения из WAN, а это приводит к многочисленным проблемам безопасности.</p>
			<p>UPnP не использует аутентификацию или авторизацию (только некоторые устройства), предполагая, что устройства, пытающиеся подключиться к нему, являются надежными и поступают из вашей локальной сети. Это означает, что хакеры могут найти бэкдоры в вашей сети. Например, они отправят UPnP-запрос на ваш маршрутизатор и он откроет им порт без лишних вопросов.</p>
			<p>Если вы планируете отключить протокол UPnP, то вам придётся настроить проброс портов вручную для каждого устройства или программы отдельно. При этом также будет необходимо зарезервировать для каждого устройства отдельный IP адрес.</p>
			<p>Например, для каждого Torrent клиента (или сервера) порт подключения + ip адресс ПК, на котором используется тот или иной Torrent клиент. Иначе, рано или поздно, обнаружете что ваши torrent закачки попросту не работают.</p>
			<p>По умолчанию порт uTorrent клиента ОС Windows 35691. Поэтому рекомендую сгенерировать случайный порт с помощью кнопочки "Случайный".</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-5.png" class="fz__minimized" alt="клик для увеличения" title="Список клиентов DHCP" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-6.png" class="fz__minimized" alt="клик для увеличения" title="Резервирование адресов" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-7.png" class="fz__minimized" alt="клик для увеличения" title="UPnP" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-8.png" class="fz__minimized" alt="клик для увеличения" title="Виртуальный сервер" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/utorrent.png" class="fz__minimized" alt="клик для увеличения" title="uTorrent" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/transmission.png" class="fz__minimized" alt="клик для увеличения" title="Transmission" />
			</div>
			<p>
				Port Forwarding – или проброс портов, который также иногда называемый перенаправлением портов или туннелированием – это процесс пересылки трафика, адресованного конкретному сетевому порту с одного сетевого узла на другой. Этот метод позволяет внешнему пользователю достичь порта на частном IPv4-адресе (внутри локальной сети) извне, через маршрутизатор с поддержкой NAT.
			</p><p>	
				Проброс портов позволяет пользователям в интернете получать доступ к внутренним серверам с помощью адреса порта WAN маршрутизатора и соответствующего номера внешнего порта. Внутренние серверы обычно конфигурируются с частными адресами IPv4 и когда запрос отправляется на адрес порта WAN через Интернет, маршрутизатор перенаправляет запрос на соответствующий сервер в локальной сети. По соображениям безопасности широкополосные маршрутизаторы по умолчанию не разрешают перенаправление любого внешнего сетевого запроса на внутренний хост.
			</p><p>	
				Port Triggering - это параметр конфигурации маршрутизатора с поддержкой NAT, который управляет связью между внутренними и внешними хост-машинами в IP-сети. Он похож на переадресацию портов в том смысле, что позволяет перенаправлять входящий трафик на определенную внутреннюю хост-машину, хотя переадресованный порт не открыт постоянно, а целевая внутренняя хост-машина выбирается динамически.
			</p><p>	
				Разница между Port Forwarding и Port Triggering в том, что первый это доступ из внешней сети к серверу во внутренней сети, а Port Triggering - это доступ из внутренней сети во внешнюю.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-9.png" class="fz__minimized" alt="клик для увеличения" title="Port Forwarding" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-10.png" class="fz__minimized" alt="клик для увеличения" title="Port Triggering" />
			</div>
			<p>	
				DMZ — это специализированный локальный сегмент сети, который содержит в себе общедоступные сервисы с полным открытым доступом для внутренней и внешней сети. Т.е. это конфигурация сети, в которой открытые для общего доступа сервера находятся в отдельном изолированном сегменте сети. Данная концепция обеспечивает отсутствие контактов между открытыми для общего доступа серверами и другими сегментами сети в случае взлома сервера.
			</p><p>	
				Одновременно с этим, домашняя (частная) сеть остается закрытой за сетевым устройством и никаких изменений в ее работе нет.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-11.png" class="fz__minimized" alt="клик для увеличения" title="DMZ" />
			</div>
			<p>
				Если вы ещё не сделали указанных настроек, то поспешите, пока злоумышленники не причинили вред вашему сетевому устройству и не завладели вашими персональными данными. Данных настроек вполне достаточно, чтобы ограничить доступ любому злоумышленнику. Однако всегда помните, что указанные настройки роутера вовсе не универсальны а только усложняют недоброжелателям работу. 
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h2>Настройка безопасности ssh соединений</h2>
			<p>Наконец мы подошли к главному вопросу дня – «Настройка безопасности ssh соединений».</p>	
			<p>Для начала необходимо установить пакет для ssh:</p>
			<p class="codes">
				$: sudo pacman -S openssh</br>
				$: sudo yum –y install openssh-server openssh-clients</br>
				$: sudo apt-get update &amp;&amp; sudo apt-get install openssh-server openssh-clients
			</p>
			<p>Затем обязательно выполните генерацию ключей по умолчанию для каждого из ключевых типов, для которых ключи хоста не существуют:</p>
			<p class="codes">
				$: /usr/sbin/ssh-keygen -A
			</p>
			<p>А также сделайте резервную копию настроек sshd сервиса, перед его редактированием</p>
			<p class="codes">
				$: sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.factory-defaults
			</p>
			<p>Запустите sshd сервис и добавте его в атозагрузку:</p>
			<p class="codes">
				$: sudo systemctl start sshd</br>
				$: sudo systemctl enable sshd
			</p>
			<p>Перед тем, как отключить проверку пароля, обязательно скопируйте и вставте сгенерированный ключ с вашего удалённого пк на сервер ssh в конец файла пользователя к которому будете подключаться: <b>~/.ssh/authorized_keys</b></br>
				Например.
			</p>
			<p class="codes">
				$: ssh-copy-id -i ~/.ssh/id_rsa.pub user@host
			</p>
			<p>Или вручную, с помощью флеш-карты:</p>
			<p class="codes">
				$: cat id_rsa.pub >> ~/.ssh/authorized_keys
			</p>
			<p>Теперь внесем некоторые изменения от имени суперпользователя в файл: <b>/etc/ssh/sshd_config</b></p>
			<p>
				Протокол SSH первой версии имеет проблемы с безопасностью, которые закрыты во второй версии. Внесите эту строчку вручную, её нет в этом файле. </br>
			</p>
			<p class="codes">Protocol 2</p>
			<p>Отключение проверки пароля:</p>
			<p class="codes">PasswordAuthentication no</p>
			<p>Включаем аутентификацию по открытому ключу:</p>
			<p class="codes">PubkeyAuthentication yes</p>
			<p>Параметр <b>AuthorizedKeysFile</b> определяет файл, в котором содержатся публичные ключи, используемые для аутентификации пользователей по открытому ключу. В записи могут присутствовать переменные, например <b>%h</b> означает домашний каталог пользователя, а <b>%u</b> – имя пользователя. В дальнейшем мы планируем использование аутентификации по открытому ключу - раскомментируем эту строку.
			</p>
			<p class="codes">AuthorizedKeysFile .ssh/authorized_keys</p>
			<p>По умолчанию, все системные пользователи имеют возможность подключаться к системе по SSH. Например, разрешим SSH для пользователей root и networks:</br>
			</p>
			<p class="codes">AllowUsers root networks</p>
			<p>Можно разрешить доступ всем, кроме указанных:</p>
			<p class="codes">DenyUsers root networks</p>
			<p>Выбранных пользователей можно добавить в группу и разрешить доступ только этой группе:</p>
			<p class="codes">AllowGroups ssh_group</p>
			<p>Укажем время, в течение которого, неактивная сессия будет завершена, а также количество проверок доступности клиента, которые могут оставаться без ответа:</p>
			<p class="codes">ClientAliveInterval 300</br>
							ClientAliveCountMax 3</p>
			<p>Отключаем уязвимость в виде файла .RHOSTS со списком хостов и пользователей:</p>
			<p class="codes">IgnoreRhosts yes</p>
			<p>Отключаем аутентификацию на базе хоста, которая позволяет пользователю с определённого хоста подключаться к серверу:</p>
			<p class="codes">HostbasedAuthentication no</p>
			<p>Отключаем прямое подключение через root:</p>
			<p class="codes">PermitRootLogin no</p>
			<p>За настройку баннера отвечает параметр Banner</p>
			<p>Запрещаем пустые пароли</p>
			<p class="codes">PermitEmptyPasswords no</p>
			<p>Изменяем порт по умолчанию. Обязательно запомните его. Он понадобится при настройке фаервола.</p>
			<p class="codes">Port 962</p>
			<p>Анализ логов, для расширенного контроля над системой:</p>
			<p class="codes">LogLevel INFO</p>
			<p>Отключаем пересылку X11 через ssh, т.к. данный протокол не ориентирован на безопасность.</p>
			<p class="codes">X11Forwarding no</p>
			<p>Форвардинг портов. С помощью SSH туннелей вы можете строить целые цепочки для форвардинга портов. Включить или отключить SSH туннелирование можно следующими директивами.</p>
			<p class="codes">AllowStreamLocalForwarding yes</br>
				AllowTcpForwarding remote</br>
				GatewayPorts yes
			</p>
			<p>Сохраните файл и перезапустите sshd сервис:</p>
			<p class="codes">
				$: sudo systemctl restart sshd
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>Фаервол</h2>
			<p>Наливайте ещё немного чая, осталось совсем немного.</p>
			<p>Ну а я пока расскажу про команды и настройки фаервола.</p>
			<p>Не во всех ОС в репозиториях имеется графическая оболочка к консольной версии утилиты, но с консольной версией работается намного быстрее и удобнее. Установка выполняется следующей командой:</p>
			<p class="codes">
				$: sudo pacman -S ufw gufw</br>
				$: sudo yum -y install ufw</br>
				$: sudo apt install ufw gufw
			</p>
			<p>Команды UFW:</p>
			<p class="codes">
				app list - список доступных имён приложений;</br>
				enable - включить фаерволл и добавить его в автозагрузку;</br>
				disable - отключить фаерволл и удалить его из автозагрузки;</br>
				reload - перезагрузить файервол;</br>
				status - посмотреть состояние фаервола;</br>
				show - посмотреть один из отчётов о работе;</br>
				allow - добавить разрешающее правило;</br>
				deny - добавить запрещающее правило;</br>
				reject - добавить отбрасывающее правило;</br>
				limit - добавить лимитирующее правило;</br>
				delete - удалить правило;</br>
				insert - вставить правило.
			</p>
			<p>Например, чтобы открыть порт ufw для SSH, можно добавить одно из этих правил:</p>
			<p class="codes">
				$: sudo ufw allow OpenSSH</br>
				$: sudo ufw allow 22</br>
				$: sudo ufw allow 22/tcp
			</p>
			<p>Теперь необходимо активировать фаервол. Мне в archlinux для автоматического запуска при перезагрузки системы понадобилось выполнить ещё одну команду.</p>
			<p class="codes">
				$: sudo ufw enable</br>
				$: sudo systemctl enable ufw
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.0"></a></p>
			<h2>Fail2ban</h2>
			<p><a name="part5.1"></a></p>
			<h3>Установка и запуск</h3>
			<p>Описывая Fail2ban в двух словах, можно сказать, что он позволяет на основе анализа логов блокировать тех, кто злоупотребляет доступностью сервера по сети. Например, защитить почтовые ящики от взлома путем перебора паролей или многократного запроса какого-либо ресурса.</p>
			<p>Установка производится следующей командой:</p>
			<p class="codes">
				$: sudo yum install fail2ban</br>
				$: sudo apt-get install fail2ban</br>
				$: sudo pacman -S fail2ban
			</p>
			<p>Для запуска службы вводим следующие команды:</p>
			<p class="codes">
				$: systemctl enable fail2ban</br>
				$: systemctl start fail2ban
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.2"></a></p>
			<h3>Базовая настройка</h3>
			<p>Процесс настройки fail2ban не зависит от дистрибутива Linux. Основной конфигурационный файл находится по пути /etc/fail2ban/jail.conf. Однако, его не рекомендуется менять и для настройки используют подключаемые файлы из каталога /etc/fail2ban/jail.d.</p>
			<p>Для начала создаем первый файл, в котором будут храниться настройки по умолчанию: /etc/fail2ban/jail.d/default.conf</p>
			<p class="codes">
				[DEFAULT]</br>
				maxretry = 4</br>
				findtime = 480</br>
				bantime = 720</br>
				action = firewallcmd-ipset</br>
				ignoreip = 127.0.0.1/8</br>
			</p>
			<p>* где:</p>
			<ul>
				<li>maxretry &nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;количество действий, которые разрешено совершить до бана</li>
				<li>findtime &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время в секундах, в течение которого учитывается maxretry;</li>
				<li>bantime &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время, на которое будет блокироваться IP-адрес;</li>
				<li>action &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;действия, которое будет выполняться, если Fail2ban обнаружит активность, соответствующую критериям поиска;</li>
				<li>ignoreip &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;игнорировать защиту, если запросы приходят с перечисленных адресов.</li>
			</ul>
			<p>* В данном примере, если в течение 8 минут (480) будет найдено 5 строк (maxretry = 4), содержащих критерий фильтра, Fail2ban заблокирует IP-адрес, с которого идет подключение на 12 минут (720);</p>
			<p>* В секции [DEFAULT] хранятся общие настройки для всех правил. Каждую из настроек можно переопределить при конфигурировании самого правила.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.3"></a></p>
			<h3>Настройка правил</h3>
			<p>Для нового правила необходимо создать конфигурационный файл в каталоге /etc/fail2ban/jail.d, например: /etc/fail2ban/jail.d/service.conf</p>
			<p class="codes">
				[ssh]</br>
				enabled = true</br>
				port = ssh</br>
				filter = sshd</br>
				action = iptables[name=sshd, port=ssh, protocol=tcp]</br>
				logpath = /var/log/auth.log</br>
				maxretry = 10</br>
				findtime = 600
			</p>
			<p>* где:</p>
			<ul>
				<li>ssh — название для правила;</li>
				<li>enabled позволяет быстро включать (true) или отключать (false) правило;</li>
				<li>port — порт целевого сервиса. Принимается буквенное или цифирное обозначение;</li>
				<li>filter — фильтр (критерий поиска), который будет использоваться для поиска подозрительных действий. По сути, это имя файла из каталога /etc/fail2ban/filter.d без .conf на конце;</li>
				<li>action — действие, совершаемое в случае срабатывания правила. В квадратных скобках указаны название для правила, сетевой порт и протокол для блокирования;</li>
				<li>logpath — расположение лог-файла, в котором фильтр будет искать подозрительную активность на основе описанных критериев.</li>
			</ul>
			<p>* обратите внимание, что мы переопределили параметры по умолчанию maxretry, findtime и action.</p>
			<p>Чтобы изменения вступили в силу, перезапускаем сервис:</p>
			<p class="codes">
				$: systemctl restart fail2ban
			</p>
			<p>Для гарантии, что fail2ban не заблокирут компьютер администратора или другой важный узел, предусмотрена настройка исключений с помощью опции ignoreip. Опция может быть применена как на глобальном уровне (default), так и для конкретного правила.</p>
			<p>Для того, чтобы задать общую настроку, откроем наш файл default:</p>
			<p class="codes">
				[DEFAULT]</br>
				...</br>
				ignoreip = 192.168.0.0/24 95.95.95.95
			</p>
			<p>* в данном примере под фильтры не будут попадать адреса с 192.168.0.1 по 192.168.0.255 и адрес 95.95.95.95.</p>
			<p>Файлы с настройкой действий находятся в каталоге /etc/fail2ban/action.d. Чтобы блокировать адрес, Fail2ban создает правило в брандмауэре netfilter. Для этого, чаще всего, используются утилиты iptables или firewall-cmd. Последняя применяется в последних версиях CentOS / Red Hat / Fedora. iptables более универсальная и может использоваться, почти, во всех системах Linux.</p>
			<p>Остановимся на описании самых используемых действий:</p>
			<ul>
				<li>iptables — создание простого правила в netfilter с помощью одноименной утилиты;</li>
				<li>iptables-multiport — использование модуля multiports, позволяющий добавлять диапазоны портов для блокировки;</li>
				<li>iptables-ipset — использование ipset для придания более лаконичного вида правилам;</li>
				<li>iptables-allports — блокирует для адреса все порты;</li>
				<li>firewallcmd-new — создание простого правила в netfilter с помощью firewall-cmd;</li>
				<li>firewallcmd-ipset — добавляет правила с помощью утилиты firewall-cmd, используя ipset;</li>
				<li>firewallcmd-rich-rules — создает rich-rules при помощи firewall-cmd.</li>
			</ul>
			<p>Фильтры, в основном, представляют набор регулярных выражений для поиска ключевых слов в log-файлах. Они находятся в каталоге /etc/fail2ban/filter.d.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.4"></a></p>
			<h3>NGINX DDoS (req limit)</h3>
			<p>Данное правило поможет защитить веб-сервер nginx от DDoS-атак. В некоторых сборках, для данного правило может не оказаться готового фильтра, поэтому в данном примере, мы его создадим вручную.</p>
			<p>Для начала, необходимо настроить NGINX:</p>
			<p class="codes">
				$: vi /etc/nginx/nginx.conf
			</p>
			<p>В раздел http добавим:</p>
			<p class="codes">
				http {</br>
				...</br>
				limit_req_zone $binary_remote_addr zone=one:10m rate=5r/s;</br>
				...</br>
			</p>
			<p>* данная настройка создает зону с интенсивностью запросов в 1 запрос в секунду.</p>
			<p>После настраиваем лимит для конкретного виртуального домена в разделе server - location:</p>
			<p class="codes">
				server {</br>
				...</br>
				location / {</br>
				...</br>
				limit_req zone=one burst=5 nodelay;</br>
				...
			</p>
			<p>* данная настройка вместе с предыдущей зоной, созданной в секции http, позволит лимитировать запросы — 1 запрос в секунду при всплеске 5 запросов.</p>
			<p>Проверяем конфигурационный файл nginx и перезапускаем сервис:</p>
			<p class="codes">
				$: nginx -t</br>
				$: systemctl reload nginx
			</p>
			<p>В лог-файле /var/log/nginx/error.log мы должны увидеть запись на подобие:</p>
			<p class="codes">
				2020/11/16 19:11:08 [error] 1330844#1330844: *16640836 limiting requests, excess: 10.520 by zone "one", client: xxx.xxx.xxx.xxx, server: dmosk.ru, request: "GET / HTTP/1.1", host: "dmosk.ru", referrer: "https://dmosk.ru/page1"
			</p>
			<p>Теперь можно приступать к настройке fail2ban. Создаем фильтр:</p>
			<p class="codes">
				$: vi /etc/fail2ban/filter.d/nginx-limit-req.conf</br></br>
				[Definition]</br>
				ngx_limit_req_zones = [^"]+</br>
				failregex = ^\s*\[error\] \d+#\d+: \*\d+ limiting requests, excess: [\d\.]+ by zone "(?:%(ngx_limit_req_zones)s)", client: <HOST></br>
				ignoreregex =
			</p>
			<p>Создаем правило в fail2ban:</p>
			<p class="codes">
				$: vi /etc/fail2ban/jail.d/nginx-ddos.conf</br></br>
				[nginx-ddos]</br>
				enabled = true</br>
				port = http,https</br>
				filter = nginx-limit-req</br>
				action = iptables-multiport[name=nginxddos, port="http,https", protocol=tcp]</br>
				logpath = /var/log/nginx/error.log
			</p>
			<p>После настройки не забываем перезапустить fail2ban:</p>
			<p class="codes">
				$: systemctl restart fail2ban
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.5"></a></p>
			<h3>Работа со списком заблокированных адресов</h3>
			<p>Получить статистику заблокированных адресов можно следующей командой:</p>
			<p class="codes">
				$: fail2ban-client status <имя правила>
			</p>
			<p>Получить список правил можно командой:</p>
			<p class="codes">
				$: fail2ban-client status
			</p>
			<p>При наличие заблокированных IP-адресов мы увидим, примерно, следующее:</p>
			<p class="codes">
				`- action</br>
				|- Currently banned: 2</br>
				|  `- IP list:       31.207.47.55 10.212.245.29</br>
			</p>
			<p>С помощью iptables:</p>
			<p class="codes">
				$: iptables -L -n --line
			</p>
			<p>С помощью firewall-cmd:</p>
			<p class="codes">
				$: firewall-cmd --direct --get-all-rules
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.6"></a></p>
			<h3>Примеры правил</h3>
			<p>CentOS</p>
			<p class="codes">
				/etc/fail2ban/jail.d/ssh.conf</br></br>
				[ssh]</br>
				enabled = true</br>
				port = ssh</br>
				filter = sshd</br>
				action = firewallcmd-new[name=sshd]</br>
				logpath = /var/log/secure
			</p>
			<p>Ubuntu</p>
			<p class="codes">
				/etc/fail2ban/jail.d/ssh.conf</br></br>
				[ssh]</br>
				enabled = true</br>
				port = ssh</br>
				filter = sshd</br>
				action = iptables[name=sshd]</br>
				logpath = /var/log/auth.log
			</p>
			<p>Asterisk</p>
			<p class="codes">
				/etc/fail2ban/jail.d/asterisk.conf</br></br>
				[asterisk]</br>
				enabled = true</br>
				filter = asterisk</br>
				action = iptables-allports[name=asterisk, protocol=all]</br>
				logpath = /var/log/asterisk/messages
			</p>
			<p>NGINX</p>
			<p class="codes">
				/etc/fail2ban/jail.d/nginx.conf</br></br>
				[nginx]</br>
				enabled = true</br>
				port = http,https</br>
				filter = nginx-http-auth</br>
				action = iptables-multiport[name=nginx, port="http,https", protocol=tcp]</br>
				logpath = /var/log/nginx/error.log
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.7"></a></p>
			<h3>Удаление</h3>
			<p class="pbold">Средствами fail2ban:</p>
			<p>Для удаление адреса из списка вводим:</p>
			<p class="codes">
				$: fail2ban-client set <имя правила> unbanip <IP-адрес>
			</p>
			<p>например:</p>
			<p class="codes">
				$: fail2ban-client set ssh unbanip 31.207.47.55
			</p>
			<p class="pbold">С помощью iptables:</p>
			<p class="codes">
				$: iptables -D <цепочка правил> -s IP-адрес
			</p>
			<p>например:</p>
			<p class="codes">
				$: iptables -D fail2ban-ssh -s 10.212.245.29
			</p>
			<p class="pbold">С помощью firewall-cmd:</p>
			<p class="codes">
				$: firewall-cmd --direct --permanent --remove-rule <правило>
			</p>
			<p>например:</p>
			<p class="codes">
				$: firewall-cmd --direct --permanent --remove-rule ipv4 filter f2b-sshd 0 -s 188.134.7.221
			</p>
			<p>После необходимо перечитать правила:</p>
			<p class="codes">
				$: firewall-cmd --reload
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="about">
			<p>Copyright &copy; 14.01.2021 by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
