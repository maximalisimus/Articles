<html>
<head>
	<meta charset="utf-8">
	<title>Безопасность сетевых соединений</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/firewall-favicon.ico">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css"> -->
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Безопасность сетевых соединений</p>
			</div>
		</div>
		<div class="content">
			<center>
				<h1>Теория и практика.</h1>
			</center>
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/Superman-Linux-jpg.jpg" width="150px"/>
				</div>
				<div style="clear:both"></div>
			</center>
			</br>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Пароли</a></li>
				<li><a href="#part2">Настройка роутеров и маршрутизаторв</a></li>
				<li><a href="#part3">Настройка безопасности ssh соединений</a></li>
				<li><a href="#part4">Фаерволы</a></li>
					<ol>
						<li><a href="#part4.1">Фаервол UFW</a></li>
						<li><a href="#part4.2">Фаервол Firewalld</a></li>
					</ol>
				<li><a href="#part5.0">Fail2ban</a></li>
				<ol>
					<li><a href="#part5.1">Установка и запуск</a></li>
					<li><a href="#part5.2">Базовая настройка</a></li>
					<li><a href="#part5.3">Настройка правил</a></li>
					<li><a href="#part5.4">NGINX DDoS (req limit)</a></li>
					<li><a href="#part5.5">NGINX files</a></li>
					<li><a href="#part5.6">NGINX GZIP</a></li>
					<li><a href="#part5.7">NGINX X-XSS-Protection</a></li>
					<li><a href="#part5.8">NGINX X-Frame-Options</a></li>
					<li><a href="#part5.9">NGINX X-Permitted-Cross-Domain-Policies</a></li>
					<li><a href="#part5.10">NGINX Strict-Transport-Security</a></li>
					<li><a href="#part5.11">NGINX X-Content-Type-Options</a></li>
					<li><a href="#part5.12">NGINX SSL</a></li>
					<li><a href="#part5.13">Работа со списком заблокированных адресов</a></li>
					<li><a href="#part5.14">Примеры правил</a></li>
					<li><a href="#part5.15">Удаление</a></li>
				</ol>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>Пароли.</h2>
			<p>
				Первое что каждый пользователь хочет услышать – ваше соединение максимально защищено. Но так ли это на самом деле? Так ли безопасны соединения с вашими серверами как мы думаем? Будь то сервер контроля версий GIT, файловый сервер или любой другой.
			</p><p>
				Наливайте приятную для вас жидкость, присаживайтесь поудобнее – будет интересно.
			</p><p>
				У любого продвинутого пользователя всегда имеется электронная почта. А если он ещё и по совместительству системный администратор, то скорее всего для упрощения рабочей нагрузки, он почти наверняка будет везде использовать одинаковые пароли. Конечно один пароль легче запомнить, но так делать категорически не стоит. Такое допущение упрощает работу злоумышленникам, а вам добавляет нервного напряжения, что наверняка скажется на вашем здоровье. Хорошенько задумайтесь перед тем, как использовать одинаковые пароли. Хорошо, если вы отделаетесь лёгким испугом, но надеятся на это никогда не стоит. Необходимо забодится о безопасности своих данных заблаговременно.
			</p><p>
				Мы можем бесконечно углубляться в тему паролей, но всё-таки коснёмся нескольких важных вопросов, которые повысят ваш уровень знаний, сохранят не толко ваши нервы, а злоумышленникам значительно усложнят работу.
			</p><p>
				С одной стороны все прекрасно знают какие комбинации для паролей не стоит использовать.  С другой стороны запоминать гигантскую строку из различного набора знаков, которую вам создал генератор паролей также не является выходом, ведь вы можете забыть один из символов, что только прибавит вам головной боли пока вы всё вспомните. Сохранять пароль даже на USB носитель не всегда оправдывает себя, т. к. вашим носителем могут воспользоваться нечестные на руку коллеги по работе. Флеш-карту также легко можно случайно где-нибудь забыть или обранить. Нет, я конечно не призываю вас не сохранять ваши пароли или не использовать генераторы, я просто предостерегаю вас от таких казусов, до того как они произошли. 
			</p><p>
				Так как же поступить в такой сложной ситуации, чтобы не запутаться и не забыть свой пароль, особенно если он не один? 
			</p><p>
				Всё гениальное просто. Вам достаточно придумать и запомнить свою определенную цепочку символов из которых будут состоять ваши пароли, т. е. придумать алгоритм, по которому они и будут создаваться с одной только помощью вашей умной головы. А дальше дело техники. Восстановить подобные пароли по памяти не составит труда. Приведу простой пример. Пусть тестовая цепочка паролей будет состоять из следующего набора символов: 1) дата выхода одного из любимых сериалов вместе с точками, 2) Слитное написание фамилии и имени героя выбранного сериала в пункте 1. Такой комбинации уже будет достаточно. Например: «19.11.2020SamVinchester».
			</p><p>
				24 символа. Неплохо, правда? Такая задача злоумышленникам будет явно не по силам. Разумеется данную комбинацию уже не стоит использовать. Она приведена только в качестве примера, а алгоритм вы должны будете придумать самостоятельно под свои нужды. Теперь созданные наборы паролей можно записать на отдельную Флеш-карту и хранить дома в сейфе за 7 замками. Шучу конечно. Просто использовать лишь в крайнем случае.
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h2>Настройка роутеров и маршрутизаторв.</h2>
			<p>Теперь немного уделим внимания настройкам ваших роутеров и маршрутизаторов.</p>
			<p>
				Многие из вас, дорогие друзья, даже не догадываются насколько они уязвимы. А ведь такое упущение может принести для вас много головной боли. Давайте же это исправим.
			</p><p>
				Кусайте печеньку, запивайте чайком, а я пока что приведу пример настроек роутера TP-Link WR741. В других роутера, например D-Link, ищите аналогичные меню и настройки. 
			</p><p>
				Первое что необходимо изменить в конфигурации – это имя администратора и пароль. Теперь доступ к вашему роутеру ограничен, но пока ещё уязвим. После этого найдите настройку базовой защиты, а именно – межсетевой экран, VPN и ALG. Все указанные пункты необходимо установить в положение «Включить». Сохраните настройки и перейдите в следующий пункт настройки безопасности: «Защита от Dos атак» и также установите в положение «Включить». Не забудьте в этом же меню установить галочки напротив всех остальных пунктов с наименованием - «включить фильтрацию от атак…». 
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-1.jpg" class="fz__minimized" alt="клик для увеличения" title="Настройка базовой защиты" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-2.jpg" class="fz__minimized" alt="клик для увеличения" title="Расширенные настройки защиты" />
			</div>	
			<p>
				Приведу ещё одну настройку, в которой можно легко ошибиться. В этом же меню безопасности имеется пункт «Локальное управление». По умолчанию настройка установлена в положение «Всем компьютерам в локальной сети…». Многие пользователи устанавливают её во второе положение - «Только указанным компьютерам…». Перед изменением этой настройки необходимо обратить внимание на кнопочку возле пункта «Mac-адрес вашего компьютера». Во многих роутерах на ней указано – «Добавить». В моём же роутере (TL-841L), на этой кнопке написано: «Копировать». Т.е. прошивка моего роутера не позволяет добавлять новые Mac-адреса. Будьте осторожны с этой настройкой. Иначе может возникнуть ситуация, что у вас самого не будет доступа к настройкам вашего маршрутизатора и его придётся сбрасывать к заводским настройкам. Вообщем, только потеряте время и деньги. Думаю, данную настройку стоит оставить по умолчанию.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr741-config-3.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-4.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление2" />
			</div>
			<p>Также не забудьте про протокол UPnP.</p>
			<p>UPnP - это протокол, который позволяет приложениям и другим устройствам в вашей сети автоматически открывать и закрывать порты для подключения друг к другу. Например, если вы решили подключить принтер ко всем устройствам в доме без UPnP, то вам потребуется сделать это вручную, уделяя внимание каждому отдельному девайсу. Но благодаря UPnP можно автоматизировать этот процесс.</p>
			<p>С поддержкой UPnP они могут автоматически подключаться к сети, получать IP-адрес, находить другие устройства в сети и подключаться к ним, и это очень удобно.</p>
			<p>Первоначально предполагалось, что UPnP будет работать только на уровне локальной сети, что означает, что устройства только в вашей сети могут подключаться друг к другу. Однако многие производители маршрутизаторов теперь включают UPnP по умолчанию, что делает их доступными для обнаружения из WAN, а это приводит к многочисленным проблемам безопасности.</p>
			<p>UPnP не использует аутентификацию или авторизацию (только некоторые устройства), предполагая, что устройства, пытающиеся подключиться к нему, являются надежными и поступают из вашей локальной сети. Это означает, что хакеры могут найти бэкдоры в вашей сети. Например, они отправят UPnP-запрос на ваш маршрутизатор и он откроет им порт без лишних вопросов.</p>
			<p>Если вы планируете отключить протокол UPnP, то вам придётся настроить проброс портов вручную для каждого устройства или программы отдельно. При этом также будет необходимо зарезервировать для каждого устройства отдельный IP адрес.</p>
			<p>Например, для каждого Torrent клиента (или сервера) порт подключения + ip адресс ПК, на котором используется тот или иной Torrent клиент. Иначе, рано или поздно, обнаружете что ваши torrent закачки попросту не работают.</p>
			<p>По умолчанию порт uTorrent клиента ОС Windows 35691. Поэтому рекомендую сгенерировать случайный порт с помощью кнопочки "Случайный".</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-5.png" class="fz__minimized" alt="клик для увеличения" title="Список клиентов DHCP" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-6.png" class="fz__minimized" alt="клик для увеличения" title="Резервирование адресов" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-7.png" class="fz__minimized" alt="клик для увеличения" title="UPnP" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-8.png" class="fz__minimized" alt="клик для увеличения" title="Виртуальный сервер" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/utorrent.png" class="fz__minimized" alt="клик для увеличения" title="uTorrent" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/transmission.png" class="fz__minimized" alt="клик для увеличения" title="Transmission" />
			</div>
			<p>
				Port Forwarding – или проброс портов, который также иногда называемый перенаправлением портов или туннелированием – это процесс пересылки трафика, адресованного конкретному сетевому порту с одного сетевого узла на другой. Этот метод позволяет внешнему пользователю достичь порта на частном IPv4-адресе (внутри локальной сети) извне, через маршрутизатор с поддержкой NAT.
			</p><p>	
				Проброс портов позволяет пользователям в интернете получать доступ к внутренним серверам с помощью адреса порта WAN маршрутизатора и соответствующего номера внешнего порта. Внутренние серверы обычно конфигурируются с частными адресами IPv4 и когда запрос отправляется на адрес порта WAN через Интернет, маршрутизатор перенаправляет запрос на соответствующий сервер в локальной сети. По соображениям безопасности широкополосные маршрутизаторы по умолчанию не разрешают перенаправление любого внешнего сетевого запроса на внутренний хост.
			</p><p>	
				Port Triggering - это параметр конфигурации маршрутизатора с поддержкой NAT, который управляет связью между внутренними и внешними хост-машинами в IP-сети. Он похож на переадресацию портов в том смысле, что позволяет перенаправлять входящий трафик на определенную внутреннюю хост-машину, хотя переадресованный порт не открыт постоянно, а целевая внутренняя хост-машина выбирается динамически.
			</p><p>	
				Разница между Port Forwarding и Port Triggering в том, что первый это доступ из внешней сети к серверу во внутренней сети, а Port Triggering - это доступ из внутренней сети во внешнюю.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-9.png" class="fz__minimized" alt="клик для увеличения" title="Port Forwarding" />
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-10.png" class="fz__minimized" alt="клик для увеличения" title="Port Triggering" />
			</div>
			<p>	
				DMZ — это специализированный локальный сегмент сети, который содержит в себе общедоступные сервисы с полным открытым доступом для внутренней и внешней сети. Т.е. это конфигурация сети, в которой открытые для общего доступа сервера находятся в отдельном изолированном сегменте сети. Данная концепция обеспечивает отсутствие контактов между открытыми для общего доступа серверами и другими сегментами сети в случае взлома сервера.
			</p><p>	
				Одновременно с этим, домашняя (частная) сеть остается закрытой за сетевым устройством и никаких изменений в ее работе нет.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/tplink-wr841-config-11.png" class="fz__minimized" alt="клик для увеличения" title="DMZ" />
			</div>
			<p>
				Если вы ещё не сделали указанных настроек, то поспешите, пока злоумышленники не причинили вред вашему сетевому устройству и не завладели вашими персональными данными. Данных настроек вполне достаточно, чтобы ограничить доступ любому злоумышленнику. Однако всегда помните, что указанные настройки роутера вовсе не универсальны а только усложняют недоброжелателям работу. 
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h2>Настройка безопасности ssh соединений</h2>
			<p>Наконец мы подошли к главному вопросу дня – «Настройка безопасности ssh соединений».</p>	
			<p>Для начала необходимо установить пакет для ssh:</p>
			<p class="codes">
				$: sudo pacman -S openssh</br>
				$: sudo yum –y install openssh-server openssh-clients</br>
				$: sudo apt-get update &amp;&amp; sudo apt-get install openssh-server openssh-clients
			</p>
			<p>Затем обязательно выполните генерацию ключей по умолчанию для каждого из ключевых типов, для которых ключи хоста не существуют:</p>
			<p class="codes">
				$: /usr/sbin/ssh-keygen -A
			</p>
			<p>А также сделайте резервную копию настроек sshd сервиса, перед его редактированием</p>
			<p class="codes">
				$: sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.factory-defaults
			</p>
			<p>Запустите sshd сервис и добавте его в атозагрузку:</p>
			<p class="codes">
				$: sudo systemctl start sshd</br>
				$: sudo systemctl enable sshd
			</p>
			<p>Перед тем, как отключить проверку пароля, обязательно скопируйте и вставте сгенерированный ключ с вашего удалённого пк на сервер ssh в конец файла пользователя к которому будете подключаться: <b>~/.ssh/authorized_keys</b></br>
				Например.
			</p>
			<p class="codes">
				$: ssh-copy-id -i ~/.ssh/id_rsa.pub user@host
			</p>
			<p>Или вручную, с помощью флеш-карты:</p>
			<p class="codes">
				$: cat id_rsa.pub >> ~/.ssh/authorized_keys
			</p>
			<p>Теперь внесем некоторые изменения от имени суперпользователя в файл: <b>/etc/ssh/sshd_config</b></p>
			<p>
				Протокол SSH первой версии имеет проблемы с безопасностью, которые закрыты во второй версии. Внесите эту строчку вручную, её нет в этом файле. </br>
			</p>
			<p class="codes">Protocol 2</p>
			<p>Отключение проверки пароля:</p>
			<p class="codes">PasswordAuthentication no</p>
			<p>Включаем аутентификацию по открытому ключу:</p>
			<p class="codes">PubkeyAuthentication yes</p>
			<p>Параметр <b>AuthorizedKeysFile</b> определяет файл, в котором содержатся публичные ключи, используемые для аутентификации пользователей по открытому ключу. В записи могут присутствовать переменные, например <b>%h</b> означает домашний каталог пользователя, а <b>%u</b> – имя пользователя. В дальнейшем мы планируем использование аутентификации по открытому ключу - раскомментируем эту строку.
			</p>
			<p class="codes">AuthorizedKeysFile .ssh/authorized_keys</p>
			<p>По умолчанию, все системные пользователи имеют возможность подключаться к системе по SSH. Например, разрешим SSH для пользователей root и networks:</br>
			</p>
			<p class="codes">AllowUsers root networks</p>
			<p>Можно разрешить доступ всем, кроме указанных:</p>
			<p class="codes">DenyUsers root networks</p>
			<p>Выбранных пользователей можно добавить в группу и разрешить доступ только этой группе:</p>
			<p class="codes">AllowGroups ssh_group</p>
			<p>Укажем время, в течение которого, неактивная сессия будет завершена, а также количество проверок доступности клиента, которые могут оставаться без ответа:</p>
			<p class="codes">
				TCPKeepAlive yes</br>
				ClientAliveInterval 300</br>
				ClientAliveCountMax 3
			</p>
			<p>Отключаем уязвимость в виде файла .RHOSTS со списком хостов и пользователей:</p>
			<p class="codes">IgnoreRhosts yes</p>
			<p>Отключаем аутентификацию на базе хоста, которая позволяет пользователю с определённого хоста подключаться к серверу:</p>
			<p class="codes">HostbasedAuthentication no</p>
			<p>Отключаем прямое подключение через root:</p>
			<p class="codes">PermitRootLogin no</p>
			<p>За настройку баннера отвечает параметр Banner</p>
			<p>Запрещаем пустые пароли</p>
			<p class="codes">PermitEmptyPasswords no</p>
			<p>Изменяем порт по умолчанию. Обязательно запомните его. Он понадобится при настройке фаервола.</p>
			<p class="codes">Port 962</p>
			<p>Анализ логов, для расширенного контроля над системой:</p>
			<p class="codes">LogLevel INFO</p>
			<p>Отключаем пересылку X11 через ssh, т.к. данный протокол не ориентирован на безопасность.</p>
			<p class="codes">X11Forwarding no</p>
			<p>Сначала нужно задать эти параметры в sshd_config. Поскольку мы вносим изменения в интерфейсы и удалённой, и клиентской системы, нам нужны права root с обеих сторон.</p>
			<p class="codes">
				PermitRootLogin yes</br>
				PermitTunnel yes
			</p>
			<p>Форвардинг портов. С помощью SSH туннелей вы можете строить целые цепочки для форвардинга портов. Включить или отключить SSH туннелирование можно следующими директивами.</p>
			<p class="codes">AllowStreamLocalForwarding yes</br>
				# AllowTcpForwarding remote</br>
				AllowTcpForwarding yes</br>
				GatewayPorts yes</br>
				# AllowAgentForwarding yes
			</p>
			<p>Сохраните файл и перезапустите sshd сервис:</p>
			<p class="codes">
				$: sudo systemctl restart sshd
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>Фаервол</h2>
			<p>Наливайте ещё немного чая, осталось совсем немного.</p>
			<p>Ну а я пока расскажу про 2 фаервола, один из которых вам понадобится.</p>
			<p><a name="part4.1"></a></p>
			<h3>Фаервол UFW</h3>
			<p>Не самый хороший фаервол, но самый удобный в плане простоты настройки.</p>
			<p><b>Обратите внимание, что блокировка входящего трафика в docker-контейнеры может нормально не отработывать. <br>По крайней мере в локальной сети между 2-мя ПК.</b></p>
			<p>Не во всех ОС в репозиториях имеется графическая оболочка к консольной версии утилиты, но с консольной версией работается намного быстрее и удобнее. Установка выполняется следующей командой:</p>
			<p class="codes">
				$: sudo pacman -S ufw gufw</br>
				$: sudo yum -y install ufw</br>
				$: sudo apt install ufw gufw
			</p>
			<p>Команды UFW:</p>
			<p class="codes">
				app list - список доступных имён приложений;</br>
				enable - включить фаерволл и добавить его в автозагрузку;</br>
				disable - отключить фаерволл и удалить его из автозагрузки;</br>
				reload - перезагрузить файервол;</br>
				status - посмотреть состояние фаервола;</br>
				show - посмотреть один из отчётов о работе;</br>
				allow - добавить разрешающее правило;</br>
				deny - добавить запрещающее правило;</br>
				reject - добавить отбрасывающее правило;</br>
				limit - добавить лимитирующее правило;</br>
				delete - удалить правило;</br>
				insert - вставить правило.
			</p>
			<p>Например, чтобы открыть порт ufw для SSH, можно добавить одно из этих правил:</p>
			<p class="codes">
				$: sudo ufw allow OpenSSH</br>
				$: sudo ufw allow 22</br>
				$: sudo ufw allow 22/tcp
			</p>
			<p>Теперь необходимо активировать фаервол. Мне в archlinux для автоматического запуска при перезагрузки системы понадобилось выполнить ещё одну команду.</p>
			<p class="codes">
				$: sudo ufw enable</br>
				$: sudo systemctl enable ufw
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4.2"></a></p>
			<h3>Фаервол Firewalld</h3>
			<p>Самый сильный и хороший фаервол. Единственный недостаток, он же и большой плюс - <b>требует тщательной настройки и понимания как всё устроено!</b></p>
			<br>
			<p><b><span style="color:red;">Обратите внимание!</span></b> <br>В данном блоке мы не будем рассматривать все варианты команд и примеров как их использовать. Мы рассмотрим конкретный случай, когда у вас установлен <b>&laquo;wireguard + docker + docker-compose&raquo;</b>, чтобы вы могли быстро на конкретных примерах с подробными объяснениями понять как всё устроено и работает. И также быстро разобраться как и что делать у себя на своем сервере. <br>При этом не важно какой <b>nginx</b> у вас установлен - будь то просто <b>&laquo;Nginx + certbot + python3-certbot-nginx + crontab&raquo;</b> для <b>&laquo;Let’s Encrypt&raquo;</b> сертификтов или <b>&laquo;Nginx proxy manager&raquo;</b> в docker-контейнере или что-то другое. <br><b>Работать везде будет примерно одинаково.</b></p>
			<br>
			<p>Перед тем как приступить к установке и настройке firewalld, мы познакомимся с понятием зон, которые используются для определения уровня доверия к различным соединениям. <b>Вот как раз от них и будет зависеть то как будет работать ваш фаервол.</b></p>
			<p>Например, к сожалению, <i>UFW</i> не всегда блокирует входящий трафик по направлению к <i>docker-контейнерам</i>. При правильной настройке <i>Firewalld</i> можно не только ограничить доступ из-вне к определенным ресурсам внутри вашей системы, но и указать в каких случаях разрешать доступ. <i>UFW</i> такого не умеет. У него либо доступ есть, либо его нет.</p>
			<p>Единственный недостаток <b>Firewalld</b>, на мой скромный взгляд, это необходимость работать только с ним, вместо <b>iptables</b> и <b>ufw</b>. Однако, это даёт намного больше пространства для маневров и более глубокую настройку поведения, которая недоступна в <b>ufw</b>.</p>
			<p><b>Firewalld</b> фильтрует входящий трафик по зонам в зависимости от примененных к зоне правил. <br>Если <b>IP-адрес</b> отправителя запроса соответствует правилам какой-либо зоны, то пакет будет отправляться через эту зону. <br>Если же адрес не соответствует ни одной из настроенных на сервере зоне, пакет будет обрабатываться зоной используемой по умолчанию. <br>При установке <b>firewalld</b> зона по умолчанию называется <b>public</b>.</p>
			<p>В <i>firewalld</i> есть зоны, где уже предварительно настроены разрешения для различных служб. Можно использовать эти настройки или создавать собственные зоны.</p>
			<table>
				<tr>
					<td><b>drop</b></td>
					<td>минимальный уровень доверия. Все входящие соединения блокируются без ответа, допускаются только исходящие соединения;</td>
				</tr>
				<tr>
					<td><b>block</b></td>
					<td>зона схожа с предыдущей, но при отклонении входящих запросов отправляется сообщение icmp-host-prohibited для Ipv4 или icmp6-adm-prohibited для Ipv6;</td>
				</tr>
				<tr>
					<td><b>public</b></td>
					<td>представляет общественные, недоверенные сети. Можно разрешать избранные входящие соединения в индивидуальном порядке;</td>
				</tr>
				<tr>
					<td><b>external</b></td>
					<td>внешние сети при использовании брандмауэра в качестве шлюза. Она настроена для маскирования NAT, поэтому ваша внутренняя сеть остается частной, но доступной;</td>
				</tr>
				<tr>
					<td><b>internal</b></td>
					<td>антоним зоны external. Хост обладают достаточным уровнем доверия, доступен ряд дополнительных служб;</td>
				</tr>
				<tr>
					<td><b>dmz</b></td>
					<td>используется для компьютеров, расположенных в DMZ (изолированные компьютеры без доступа к остальной сети). Разрешены только определенные входящие соединения;</td>
				</tr>
				<tr>
					<td><b>work</b></td>
					<td>зона для рабочих машин (большинство компьютеров в сети доверенные);</td>
				</tr>
				<tr>
					<td><b>home</b></td>
					<td>зона домашней сети. Можно доверять большинству ПК, но поддерживаются только определенные входящие соединения;</td>
				</tr>
				<tr>
					<td><b>trusted</b></td>
					<td>доверять всем машинам в сети. Наиболее открытая из всех доступных опций, требует сознательного использования.</td>
				</tr>
			</table>
			<p>В <i>firewalld</i> используется два набора правил — постоянные и временные. Временные правила работают до перезагрузки сервера. По умолчанию при добавлении правил в firewalld, правила считаются временными <b>&laquo;runtime&raquo;</b>. Чтобы добавить правило на постоянной основе нужно использовать флаг <u>&laquo;--permanent&raquo;</u>. Такие правила будут применяться после перезагрузки сервера.</p>
			<p>Итак, прежде чем установить этот фаервол, необходимо выключить и убрать всё что будет с ним конфликтовать. А именно - <u>ufw</u> и <u>iptables</u>.</p>
			<h3><span style="color:red;"><b>Обратите внимание!</b></span></h3>
			<p><span style="color:red;">Маскировать или полностью удалять <span style="color:blue;">&laquo;iptables.service&raquo;</span>, как рекомендуют большинство источников интернета - не рекомендуется во избежание проблем не только с самим &laquo;Firewalld&raquo;, но и с &laquo;Fail2Ban&raquo;.</span> <span style="color:blue;">&laquo;iptables.service&raquo;, если он вообще есть, необходимо только выключить!</span></p>
			<p>Дело в том, что <b>&laquo;IPTABLES&raquo;</b> и <b>&laquo;Firewalld&raquo;</b> взаимодействуют с системой следующим образом.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/The-security-of-network-connections/IptablesConcepts.png" width="424px"/>
			</div>
			<p>Теперь можно приступать к выполнению команд.</p>
			<p class="codes">
				$ sudo ufw disable</br>
				$ sudo systemctl stop ufw</br>
				$ sudo systemctl disable ufw</br>
				</br>
				$ sudo systemctl stop iptables</br>
				$ sudo systemctl disable iptables</br>
				<span style="color:blue;"># Проверяем</span><br>
				$ sudo systemctl status iptables
			</p>
			<p>Устанавливаем <b>Firewalld</b>, запускаем и проверяем.</p>
			<p class="codes">
				$ sudo apt -y install firewalld</br>
				$ sudo systemctl enable firewalld</br>
				$ sudo systemctl start firewalld</br>
				<span style="color:blue;"># Проверяем</span><br>
				$ sudo systemctl status firewalld</br>
			</p>
			<p>Далее я часто буду употреблять следующие 2 команды:</p>
			<p class="codes">
				$ sudo firewall-cmd --list-all</br>
				<span style="color:blue;"># Покажет в активной зоне все настройки</span></br>
				<span style="color:blue;"># и</span></br>
				$ sudo firewall-cmd --get-active-zones</br>
				<span style="color:blue;"># покажет все активные зоны</span><br>
				$ sudo firewall-cmd --get-services<br>
				<span style="color:blue;"># Список всех сервисов доступных firewalld</span>
			</p>
			<p><b>Обязательно выполните эти 2 команды сверху, чтобы убедиться, что в данный момент у вас в активной зоне по умолчанию (а это скорее всего <u>public</u>) имеется сервис <b>ssh</b> или порт этого сервиса (если он у вас изменен). Иначе вы можете потерять доступ к своему серверу. Это важно!</b></p>
			<p>Если <i>ssh</i> сервиса там нет, его можно добавить 2-мя следующими командами:</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhcp<br>
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhcpv6<br>
				<span style="color:blue;"># Сначала DHCP-IPV4, т.к. по умолчанию там только DHCP-IPV6 (dhcpv6-client)</span></br>
				$ sudo firewall-cmd --permanent --zone=public --add-service=ssh</br>
				<span style="color:blue;"># Если порт отличается можно заменить эту команду на следующую</span></br>
				$ sudo firewall-cmd --permanent --zone=public --add-port=2222/tcp</br>
				<span style="color:blue;"># Обязательно указывайте протокол для порта - иначе получите ошибку добавления</span></br></br>
				$ sudo firewall-cmd --reload</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
			</p>
			<p>К сожалению сервиса <b>&laquo;dhclient&raquo;</b> для <b>ipv4</b> в <b>Firewalld</b> нет, т.е. <b>&laquo;.xml&raquo;</b>-файла с указанными портами и протоколами. Имеется введу конкретно сервис для клиента, чтобы сервер мог отдать клиенту заданные в настройках порты.</p>
			<p>Такой сервис можно создать самостоятельно.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Создаем сервис для firewalld в виде xml-файла</span></br>
<b>$ sudo nano /usr/lib/firewalld/services/dhclient.xml</b>

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service&gt;
  &lt;short&gt;dhclient&lt;/short&gt;
  &lt;description&gt;This allows a DHCLIENT to accept messages from DHCP server and relay agents.&lt;/description&gt;
  &lt;port protocol="udp" port="67"/&gt;
  &lt;port protocol="udp" port="68"/&gt;
&lt;/service&gt;


<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Обязательно перезагружаем правила</span>
<b>$ sudo firewall-cmd --reload</b>
<b>$ sudo firewall-cmd --info-service=dhclient</b>
dhclient
  ports: 67/udp 68/udp
  protocols:
  source-ports:
  modules:
  destination:
  includes:
  helpers:</pre>
			</div>
			<p>После чего добавляем в нужную зону.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhclient</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br>
				<span style="color:blue;"># Проверяем</span></br>
				$ sudo firewall-cmd --info-zone=public
			</p>
			<p>В случае, если вы не меняли настройки сетевых карт сервера по умолчанию на ручные (<i>&laquo;/etc/network/interfaces&raquo;</i>), то добавлять <i>DHCP-сервисы</i> обязательная процедура, чтобы сервер смог получить свой адрес. Если у вас ручные настройки сетевых карт, можно не добавлять ни один <i>DHCP-сервис</i>. Но, обычно в любой <b>VPS</b> или <b>VDS</b> не рекомендуется ставить ручные настройки сетевых карт, хотя это вполне возможно и нормально. Ручные настройки чаще всего прописывают на своих собственных серверах, на которых как раз и установлен <i>DHCP-сервер</i>, который как раз и раздаёт всем ПК в локальной сети IP адреса. Однако, в таком случае, все <i>DHCP-сервисы</i> необходимо добавлять в нужные зоны. Иначе ПК в сети не смогут получить свои адреса, а сервер раздать их.</p>
			<p>И ещё раз убедитесь, что <i>ssh</i> или порт появились в зоне <i>public</i>.</p>
			<p class="codes">
				$ sudo firewall-cmd --list-all<br>
				<span style="color:blue;"># или</span></br>
				$ sudo firewall-cmd --info-zone=public
			</p>
			<p>Далее у вас уже должен быть запущен <b>wireguard</b> и <b>docker</b> сервисы, чтобы их сети были включены и доступны.</p>
			<p>Сразу выполним команду, с помощью которой определим все необходимые нам наименования сетей - сеть по которому идёт интернет, сети ваших контейнеров (при появлении новых, обязательно вносить их в дальнейшие настройки), и сеть VPN wireguard.</p>
			<p class="codes">
				$ ip a
			</p>
			<p>У меня в виртуальной машине используются следующие сети. У вас могут быть другие. Пока просто запомним их. Они нам далее пригодятся.</p>
			<ul>
				<li><b>enp0s3</b> - интернет сетевая карта.</li>
				<li><b>wg0</b> - wireguard сеть.</li>
				<li><b>br-00aaad17d4b5</b> - docker сеть.</li>
				<li><b>br-c2ecab4afa7c</b> - docker сеть.</li>
				<li><b>docker0</b> - docker сеть.</li>
			</ul>
			<p><span style="color:red;">Теперь, перед тем, как продолжать необходимо понять несколько важных аспектов, т.к. без этих настроек у вас могут возникнуть <span style="color:blue;">БОЛЬШИЕ ПРОБЛЕМЫ</span>.</span></p>
			<p>Дело в том, что <i>firewalld</i> сервис стартует сразу после запуска сети. А <i>docker</i> сервис несколько позже. И также несколько позже стартует <i>wireguard</i>. Поэтому если вы просто добавить сети <i>docker</i>-а куда-либо, то после перезагрузки сервера мало того, что фаервол не запуститься, тык ещё и <i>docker</i>-сервис также не сможет запуститься.</p>
			<p>Чтобы отрабатывал <i>nginx</i> - ему нужны сети, которые есть в <i>docker</i>-контейнерах. Сервису <i>firewalld</i> нужны все сети - и те что в <i>docker-ах</i>, и от <i>wireguard-а</i>. Ну а чтобы он правильно маршрутизировал трафик ему нужен запущенный <i>nginx</i>. И последний <i>fail2ban-у</i> нужен в первую очередь <i>firewalld-сервис</i>, чтобы правильно отрабатывали все ловушки.</p>
			<p>Если вы попытаетесь добавить строку вида: <b>&laquo;After=docker.service&raquo;</b> в службу <b>firewalld.service</b>, то после перезагрузки сервера вы также получите те же ошибки и проблемы запуска.</p>
			<p>Лучше всего будет <b>firewalld.service</b> запускать по таймеру <b>systemd</b>, что решит все проблемы.</p>
			<p>Поэтому, чтобы всё правильно запускалось, в правильной последовательности и не вызывало ошибок - уберем из автозагрузки <b>docker</b> и <b>nginx</b> сервисы и создадим для них <b>systemd-таймеры</b>. Таким образом, сначала будет запускаться <b>wireguard</b>, затем <b>docker</b>, <b>nginx</b>, <b>firewalld</b> и только после этого <b>fail2ban</b>.</p>
			<p>Убираем nginx и docker из автозагрузки.</p>
			<p class="codes">
				$ sudo systemctl disable nginx</br>
				$ sudo systemctl disable docker</br>
			</p>
			<p>Создадим таймеры <b>docker</b> и <b>nginx</b>, добавим в автозагрузки и запустим их.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/systemd/system/docker.timer</b>

[Unit]
Description=Starting Docker on after services wireguard
Wants=wg-quick.target
After=wg-quick.target

[Timer]
Unit=docker.service
OnBootSec=5s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>

<b>$ sudo nano /etc/systemd/system/nginx.timer</b>

[Unit]
Description=Starting Nginx on after services docker
Wants=docker.timer
After=docker.timer

[Timer]
Unit=nginx.service
OnBootSec=10s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>

<b>$ sudo systemctl start docker.timer</b>
<b>$ sudo systemctl enable docker.timer</b>
<b>$ sudo systemctl start nginx.timer</b>
<b>$ sudo systemctl enable nginx.timer</b></pre>
			</div>
			<p>Вот теперь переходим к таймеру <b>firewalld</b>.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># <span style="color:red;">Выключим</span> стандартный способ включения фаервола</span>
<b>$ sudo systemctl disable firewalld</b>
<span style="color:blue;"># и создадим systemd таймер для нормального запуска firewalld сервиса без ошибок</span>
<b>$ sudo nano /etc/systemd/system/firewalld.timer</b>

[Unit]
Description=Starting Firewalld on after services nginx
Wants=nginx.timer
After=nginx.timer

[Timer]
Unit=firewalld.service
OnBootSec=15s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Добавление таймера в автозапуск</span>
<b>$ sudo systemctl enable firewalld.timer</b>
<b>$ sudo systemctl start firewalld.timer</b></pre>
			</div>
			<p>Таймер не обязательно должен называться точно также как и сервис, но расширение должно быть именно <b>&laquo;.timer&raquo;</b>.</p>
			<p>Параметры таймера:</p>
			<ul>
				<li><b>Unit</b> - какой сервис необходимо запускать по таймеру.</li>
				<li><b>AccuracySec</b> - точность таймера равна 1 секунде. По умолчанию точность таймера равно 1 минуте. Поэтому для заданий, которые выполняются чаще 1 минуты, нужно использовать этот параметр.</li>
				<li><b>OnUnitActiveSec</b> - определяет отсчёт времени от момента запуска юнита, который был активирован таймером. Другими словами отсчет ведётся с момента запуска test-timer.service, и когда он доходит до нуля, таймер срабатывает вновь. Вместо этого параметра можно использовать следующие:</li>
				<ul>
					<li><b>OnActiveSec</b> - отсчёт относительно момента активации самого таймера.</li>
					<li><b>OnBootSec</b> - отсчёт ведётся с момента запуска компьютера, например через 30 секунд, после запуска компьютера.</li>
					<li><b>OnUnitInactiveSec</b> - отсчёт начинается с момента деактивации юнита, который запускается таймером. Этот параметр противоположен <b>OnUnitActiveSec</b>.</li>
					<li><b>OnCalendar</b> - определяет таймер реального времени. Этот параметр может быть указан несколько раз, если нужно.</li>
				</ul>
			</ul>
			<p><b>Только после этого, можно подготавливать дальнейшую работу фаервола.</b></p>
			<p>Теперь необходимо добавить все <u>docker-сети</u> к внутренней зоне фаервола <u>internal</u>. Т.е. к этим сетям будет иметь доступ только сам хост сервера. Из-вне доступа ни у кого не будет, кроме <u>wireguard</u>-а при подключении к нему. Всё нормально, мы этот момент дальше поправим, чтобы иметь к контейнерам доступ по доменам через 80 и 443 порт на входе в систему.</p>
			<p>Это необходимо сделать не только ради ограничения доступа, но ещё по 1 причине.</p>
			<p>Дело в том, что после перезагрузки <b>firewalld</b> сканирует все доступные сети и если не находит во всех имеющихся зонах какой-либо существующий интерфейс - автоматически создаст новую зону с этими наименованиями интерфейсов сетей.</p>
			<p><b>Это проблема.</b> Т.к. если будет существовать зона с указанными сетями - у вас будет случайный доступ из-вне к одному из ваших контейнеров (может даже ко всем контейнерам), даже если вы не указывали порт доступа.</p>
			<p>Создавать скрипт и отдельный сервис ради удаления новой зоны бессмесленно, т.к. мы и устанавливали <b>&laquo;firewalld&raquo;</b> ради правильного и беспощадного ограничения доступа, какого нет в <b>&laquo;ufw&raquo;</b>.</p>
			<p>Кстати говоря, на заметку, именно так обычно и происходит в <b>ufw</b> фаерволе. Поэтому в нём ограничить доступ из-вне значительно сложнее.</p>
			<p>Чтобы такого не происходило - и не появлялось случайного доступа - необходимо при каждом новом контейнере, если у него есть своя новая сеть - обязательно добавлять её во внутреннюю зону фаервола. Так, при каждом перезапуске сервера - он не будет создавать новых зон, т.к. все сети будут уже заняты - каждая в свой зоне. И у вас не будет появляться случайного доступа из-вне.</p>
			<p>С помощью команды <b>&laquo;$ ip a&raquo;</b> выше мы получили нужные нам списки сетей. Теперь используем их.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=br-00aaad17d4b5</br>
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=br-c2ecab4afa7c</br>
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=docker0</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:blue;"># и проверяем что у нас получилось</span></br>
				$ sudo firewall-cmd --info-zone=internal
			</p>
			<p>Теперь можно создавать зоны фаервола с нужным нам доступом. Создадим зоны, например, <b>&laquo;mysite&raquo;</b> и <b>&laquo;mywg&raquo;</b>. Пока поработаем надо зоной <b>&laquo;mysite&raquo;</b>.</p>
			<p>Добавим в эту зону <i>&laquo;DHCP&raquo;</i> и <i>&laquo;SSH&raquo;</i>, несколько портов, включая <i>&laquo;wireguard&raquo;</i>, а также включим <b>&laquo;NAT&raquo;</b>, чтобы при подключении к <i>&laquo;wireguard&raquo;</i> у нас были свои <i>IP</i> адреса, заданные в <i>&laquo;.conf&raquo;</i>-файле. У меня порт <i>&laquo;SSH&raquo;</i> остался в виртуальной машине по умолчанию. Лучше так не делать и менять его на другой. Тогда вместо добавления сервиса надо будет добавлять конкретно порт, а не менять его в конфигурационных файлах, что будет более наглядно для вас самих и работать будет абсолютно также, но не правильнее.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --new-zone=mysite</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=dhcp</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=dhcpv6-client</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=ssh</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=http</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=https</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-port=51820/udp</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-masquerade</br></br>
				$ sudo firewall-cmd --reload</br>
				<span style="color:blue;"># Для DNS тоже есть сервисы - dns, dns-over-tls, mdns.</span>
			</p>
			<p>Мы ешё не закончили с этой зоной. Это только подготовительная часть - чтобы в процессе не потерять доступ.</p>
			<p>Теперь добавим к этой зоне интерфейс и убедимся, что всё правильно работает. Вот теперь у нас есть доступ к нашим контейнерам по 80 и 443 портам по именам доменов + доступ к vpn сервису.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Добавляем интерфейс, у вас будет свой</span>
<b>$ sudo firewall-cmd --permanent --zone=mysite --add-interface=enp0s3</b>
<span style="color:blue;"># Меняем зону по умолчанию</span>
<b>$ sudo firewall-cmd --set-default-zone=mysite</b>
<span style="color:blue;"># Обязательно перезагружаем правила</span>
<b>$ sudo firewall-cmd --reload</b>

<span style="color:blue;"># Всё проверяем</span>
<b>$ sudo firewall-cmd --get-default-zone</b>
mysite
<b>$ sudo firewall-cmd --info-zone=mysite</b>
mysite (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3
  sources: 
  services: dhcp dhcpv6-client http https ssh
  ports: 51820/udp
  protocols: 
  forward: no
  masquerade: yes
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
<b>$ sudo firewall-cmd --info-zone=public</b>
public
  target: default
  icmp-block-inversion: no
  interfaces: 
  sources: 
  services: dhcp dhcpv6-client ssh
  ports: 
  protocols: 
  forward: no
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
<b>$ sudo firewall-cmd --get-active-zones</b>
internal
  interfaces: br-00aaad17d4b5 br-c2ecab4afa7c docker0
mysite
  interfaces: enp0s3
<b>$ sudo firewall-cmd --list-all</b>
mysite (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3
  sources: 
  services: dhcp dhcpv6-client http http ssh
  ports: 51820/udp
  protocols: 
  forward: no
  masquerade: yes
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:</pre>
			</div>
			<p>Теперь займемся зоной <b>&laquo;mywg&raquo;</b>. Здесь немного посложнее.</p>
			<p>Здесь помимо всего остального доступа необходимо будет настроить таблицы маршрутизации, но т.к. у нас нет <b>&laquo;iptables&raquo;</b>,то это делается через <b>&laquo;firewalld&raquo;</b>.</p>
			<p class="codes">
				<span style="color:blue;"># Создаем новую зону</span></br>
				$ sudo firewall-cmd --permanent --new-zone=mywg</br></br>
				<span style="color:blue;"># Обязательно перезагружаем правила для применения зименений</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:blue;"># Добавляем в зону интерфейс</span></br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-interface=wg0</br></br>
				<span style="color:blue;"># Перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:red;"># Правило POSTROUTING добавлять не нужно, если уже включен маскарадинг в зоне.</span>
				<span style="color:blue;"></br># Правило POSTROUTING отвечает за изменение исходящих IP-адресов на маршрутизаторе или компьютере, который является шлюзом по умолчанию. </br># Если маскарадинг уже включен в зоне, то этого достаточно для настройки NAT-преобразования IP-адресов. </br># Однако, такая возможность существует.</span></br>
				$ sudo firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -o enp0s3 -j MASQUERADE</br></br>
				<span style="color:red;"># Для разрешения пропуска трафика из одной сети в другую, необходимо добавить правило в FORWARD в firewalld.</span></br>
				<span style="color:blue;"># Это правило указывает, какой трафик должен быть разрешен для маршрутизации между различными сетями. </br># Без правила FORWARD маршрутирование между сетями может быть заблокировано.</span></br>
				<span style="color:blue;"># Добавляем в iptables в таблицу FORWARD разрешение на пропуск трафика из одной сети в другую</span></br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter FORWARD 0 -i enp0s3 -o wg0 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter FORWARD 0 -i wg0 -o enp0s3 -m state --state RELATED,ESTABLISHED -j ACCEPT</br></br>
				<span style="color:blue;"># Перезагружаем весь фаервол для применение таблиц маршрутизации</span></br>
				$ sudo systemctl restart firewalld</br></br>
				<span style="color:blue;"># И смотрим на добавленные правила маршрутизации - если что-то не правильно - вы сразу увидите</span></br>
				$ sudo firewall-cmd --direct --get-all-rules</br>
			</p>
			<p>Добавим доступ по <i>&laquo;SSH&raquo;</i>, откроем доступ к <i>&laquo;Portainer-у&raquo;</i> через <i>&laquo;wireguard&raquo;</i>, если <i>&laquo;portainer&raquo;</i> имеется, и посмотрим на все внесенные изменения.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Добавляем ssh и 9000 порт portainer-а и перезагружаем правила</span>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=ssh</b>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=http</b>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=https</b>
<span style="color:blue;"># Для DNS тоже есть сервисы - dns, dns-over-tls, mdns.</span>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-port=9000/tcp</b>
<span style="color:blue;"># Для Portainer-а, визуального контроля контейнеров.</span>
<b>$ sudo firewall-cmd --reload</b>

<span style="color:blue;"># Всё проверяем</span>
<b>$ sudo firewall-cmd --info-zone=mywg</b>
<b>$ sudo firewall-cmd --info-zone=public</b>
<b>$ sudo firewall-cmd --get-active-zones</b>
internal
  interfaces: br-00aaad17d4b5 br-c2ecab4afa7c docker0
mysite
  interfaces: enp0s3
mywg
  interfaces: wg0</pre>
			</div>
			<p>Всё! На этом настройки данного фаервола завершены. Можно переходить к тестированию в браузере, консоли - везде где вам необходимо.</p></br>
			<h3>Переходим к настройкам wireguard-а.</h3>
			<p>Настроим конфигурацию сервера. Закоментируем строки с маршрутизацией и перезапустим сервис.</p>
			<p class="codes">
				<b>$ sudo nano /etc/wireguard/wg0.conf</b></br></br>
				[Interface]</br>
				... </br>
				<span style="color:blue;"># PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE</br></br>
				# PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE</span></br>
				... </br></br>
				<b>$ sudo systemctl restart wg-quick@wg0</b></br>
			</p>
			<p>К сожалению, совместить как-то по другому, увы, нельзя.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.0"></a></p>
			<h2>Fail2ban</h2>
			<p><a name="part5.1"></a></p>
			<h3>Установка и запуск</h3>
			<p>Описывая <b>Fail2ban</b> в двух словах, можно сказать, что он позволяет на основе анализа логов блокировать тех, кто злоупотребляет доступностью сервера по сети. Например, защитить почтовые ящики от взлома путем перебора паролей или многократного запроса какого-либо ресурса.</p>
			<p>Установка производится следующей командой:</p>
			<p class="codes">
				$ sudo yum install fail2ban</br>
				$ sudo apt-get install fail2ban</br>
				$ sudo pacman -S fail2ban
			</p>
			<p>Для запуска службы вводим команду:</p>
			<p class="codes">
				$ sudo systemctl start fail2ban
			</p>
			<p>А вот сразу добавлять <i>fail2ban</i> в автозапуск - не рекомендую.</p>
			<p class="codes">
				<s>$ sudo systemctl enable fail2ban</s>
			</p>
			<p><b>Объясню небольшую проблему запуска <i>fail2ban-а</i></b>. Дело в том, что он запускается раньше всех, даже раньше <i>firewalld</i> и значительно раньше <i>docker</i>-а. В результате правила просто не действуют. А вот если бы он стартовал позже нашего фаервола, который уже настроен на запуск позже <i>docker-сервиса</i> - это было бы идеально. Поэтому создаём таймер аналогичный запуску фаервола, за исключением того, что указываем запуск после него.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/systemd/system/fail2ban.timer</b>

[Unit]
Description=Starting Fail2Ban on after services Firewalld
Wants=firewalld.timer
After=firewalld.timer

[Timer]
Unit=fail2ban.service
OnBootSec=20s
AccuracySec=1s

[Install]
WantedBy=timers.target
				</pre>
			</div>
			<p>Вот теперь запускаем.</p>
			<p class="codes">
				$ sudo systemctl enable fail2ban.timer<br>
				$ sudo systemctl start fail2ban.timer
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.2"></a></p>
			<h3>Базовая настройка</h3>
			<p>Процесс настройки fail2ban не зависит от дистрибутива Linux. Основной конфигурационный файл находится по пути <b>&laquo;/etc/fail2ban/jail.conf&raquo;</b>. Однако, его не рекомендуется менять и для настройки используют подключаемые файлы из каталога <b>&laquo;/etc/fail2ban/jail.d&raquo;</b>.</p>
			<p>Для начала создаем первый файл, в котором будут храниться настройки по умолчанию.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/default.conf</b></br></br>
				[DEFAULT]</br>
				maxretry = 5</br>
				findtime = 5m</br>
				bantime = 10m</br>
				action = firewallcmd-ipset</br>
				ignoreip = 127.0.0.1/8 192.168.0.100</br>
			</p>
			<p>* где:</p>
			<ul>
				<li><b>maxretry</b> &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;количество действий, которые разрешено совершить до бана</li>
				<li><b>findtime</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время, в течение которого учитывается maxretry;</li>
				<li><b>bantime</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время, на которое будет блокироваться IP-адрес;</li>
				<li><b>action</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;действие, которое будет выполняться, если Fail2ban обнаружит активность, соответствующую критериям поиска;</li>
				<li><b>ignoreip</b> &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;игнорировать защиту, если запросы приходят с перечисленных адресов.</li>
			</ul>
			<p>* В секции [DEFAULT] хранятся общие настройки для всех правил. Каждую из настроек можно переопределить при конфигурировании самого правила.</p>
			<p>Время указывается в следующих выборках:</p>
			<ul>
				<li><b>&laquo;s&raquo;</b> - секунды;</li>
				<li><b>&laquo;m&raquo;</b> - минуты;</li>
				<li><b>&laquo;h&raquo;</b> - часы.</li>
			</ul>
			<p>В данном примере, если в течение 5 минут будет найдено 5 строк (maxretry = 5), содержащих критерий фильтра, Fail2ban заблокирует IP-адрес, с которого идет подключение на 10 минут.<br>Т.е. если вы ошибетесь 5 раз в течении 5 минут - вас заблокирует на 10 минут.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.3"></a></p>
			<h3>Настройка правил</h3>
			<p>В <b>Debian</b> по умолчанию вместо стандартной настройки есть такой файл: <b>&laquo;/etc/fail2ban/jail.d/defaults-debian.conf&raquo;</b>.</p>
			<p>Обычно в нём заданы настройки SSH-ловушки по умолчанию. Сейчас она не работает. Мы её перезапишем в новой конфигурации: <b>&laquo;/etc/fail2ban/jail.d/ssh.conf&raquo;</b>.</p>
			<p>Не забудьте перед этим создать нужный файл лога и дать ему соответствующие права доступа. Иначе при перезапуске <b>&laquo;fail2ban-сервиса&raquo;</b> получите ошибку.</p>
			<p class="codes">
				$ sudo touch /var/log/sshd.log</br>
				$ sudo chown root:adm /var/log/sshd.log</br>
				$ sudo chmod 640 /var/log/sshd.log
			</p>
			<p><span style="color:red;"><b>Обратите внимание!</b></span> Перед настройкой конфигураций необходимо понимать ещё один важный момент.</p>
			<p>Дело в том, что стандартный <b>&laquo;action=firewallcmd...&raquo;</b>, т.е. через firewald не всегда хорошо отрабатывает. В процессе всесторонней проверке на виртуальной машине выяснилась одна проблема.</p>
			<p>IP-адреса блокирует только один раз. В таблице маршрутизации фаервола адрес, который блокирован находится не по порядку, из-за чего - он по сути <u>не блокируется</u>.</p>
			<p>Исправляет этот момент только перезапуском и фаервола и fail2ban-а. Чтобы такого не происходило - <b>action</b> вполне можно взять другой, пусть даже с <b>iptables</b> - это вполне нормально. У нас нет <i>&laquo;iptables-сервиса&raquo;</i>, а не самого <i>&laquo;iptables&raquo;</i> как такового. Таким образом один бан другому мешать никак не будет. И разбан будет работать так как должен.</p>
			<p>Выходит, что работать на блокировку будут таблицы маршрутизации <i>&laquo;iptables&raquo;</i>, а не <i>&laquo;firewalld&raquo;</i>. Т.е. пакет свободно пройдет через <i>&laquo;firewalld&raquo;</i> и остановится на <i>&laquo;iptables&raquo;</i>. Фаервол и так уже нагружен, поэтому разгрузить его было бы хорошо. К тому же <i>&laquo;iptables&raquo;</i> по сути вообще не нагружен.</p>
			<p>Поэтому в дальнейших конфигурациях я буду комментировать один из <b>action-ов</b>. Таким образом он никак в управлении участвовать не будет. Но останется в качестве напоминания, о том, что такая конфигурация может и не функионировать, но имеет место быть.</p>
			<p>Вообще-то то, что закоментировано как раз и предлагают страницы интернета, не думая, о том, будет ли это нормально работать в комплексе с другими утилитами.</p>
			<p></p>
			<p>Теперь создаем файл конфигурации: <b>&laquo;ssh.conf&raquo;</b>.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/ssh.conf</b><br><br>
				[sshd]</br>
				enabled = true</br>
				port = ssh</br>
				<span style="color:blue;"># action = iptables-ipset[name=sshd, port=ssh, protocol=tcp]</span><br>
				action = firewallcmd-ipset[name=sshd, port=ssh, protocol=tcp]</br>
				logpath = /var/log/sshd.log</br>
			</p>
			<p>* где:</p>
			<ul>
				<li><b>sshd</b> — название для правила;</li>
				<li><b>enabled</b> - позволяет быстро включать (true) или отключать (false) правило;</li>
				<li><b>port</b> — порт целевого сервиса. Принимается буквенное или цифирное обозначение;</li>
				<li><b>action</b> — действие, совершаемое в случае срабатывания правила. В квадратных скобках указаны название для правила, сетевой порт и протокол для блокировки;</li>
				<li><b>logpath</b> - файл лога.</li>
			</ul>
			<p>Чтобы изменения вступили в силу, перезапускаем сервис и проверяем.</p>
			<div class="codeses">
				<pre><b>$ sudo systemctl restart fail2ban</b>
<b>$ sudo fail2ban-client restart</b>
<span style="color:blue;"># Этот вариант, в отличие от предыдущего, показывает ошибки при перезапуске, но не перезапускает свой сервис</span>
<b>$ sudo fail2ban-client status</b>
<span style="color:blue;"># Если всё нормально должен показать следующее</span>
Status
|- Number of jail:	1
`- Jail list:	sshd</pre>
			</div>
			<p>Для гарантии, что fail2ban не заблокирут компьютер администратора или другой важный узел, предусмотрена настройка исключений с помощью опции ignoreip. Опция может быть применена как на глобальном уровне (default), так и для конкретного правила.</p>
			<p>Для того, чтобы задать общую настроку, откроем наш файл <b>&laquo;default.conf&raquo;</b>:</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/default.conf</b><br><br>
				[DEFAULT]</br>
				...</br>
				ignoreip = 192.168.0.0/24 95.95.95.95
			</p>
			<p>* в данном примере под фильтры не будут попадать адреса с 192.168.0.1 по 192.168.0.255 и адрес 95.95.95.95.</p>
			<p>Файлы с настройкой действий находятся в каталоге <b>&laquo;/etc/fail2ban/action.d&raquo;</b>. Чтобы блокировать адрес, <b>Fail2ban</b> создает правило в брандмауэре <b>netfilter</b>. Для этого, чаще всего, используются утилиты <b>iptables</b> или <b>firewall-cmd</b>. Последняя применяется в последних версиях <b>CentOS / Red Hat / Fedora</b>. <b>Iptables</b> более универсальная и может использоваться, почти, во всех системах <b>Linux</b>.</p>
			<p>Остановимся на описании выше используемых действиях:</p>
			<ul>
				<li><b>iptables</b> — создание простого правила в netfilter с помощью одноименной утилиты;</li>
				<li><b>iptables-multiport</b> — использование модуля multiports, позволяющий добавлять диапазоны портов для блокировки;</li>
				<li><b>iptables-ipset</b> — использование ipset для придания более лаконичного вида правилам;</li>
				<li><b>iptables-allports</b> — блокирует для адреса все порты;</li>
				<li><b>firewallcmd-new</b> — создание простого правила в netfilter с помощью firewall-cmd;</li>
				<li><b>firewallcmd-ipset</b> — добавляет правила с помощью утилиты firewall-cmd, используя ipset;</li>
				<li><b>firewallcmd-rich-rules</b> — создает rich-rules при помощи firewall-cmd.</li>
			</ul>
			<p>Фильтры, в основном, представляют набор регулярных выражений для поиска ключевых слов в log-файлах. Они находятся в каталоге <b>&laquo;/etc/fail2ban/filter.d&raquo;</b>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.4"></a></p>
			<h3>NGINX DDoS (req limit)</h3>
			<p>Данное правило поможет защитить веб-сервер nginx от DDoS-атак. В некоторых сборках, для данного правило может не оказаться готового фильтра, поэтому в данном примере, мы его создадим вручную.</p>
			<p>Для начала, необходимо настроить NGINX:</p>
			<p class="codes">
				$ sudo nano /etc/nginx/nginx.conf
			</p>
			<p>В раздел http добавим:</p>
			<p class="codes">
				http {</br>
				...</br>
				limit_req_zone $binary_remote_addr zone=one:10m rate=5r/s;</br>
				...</br>
			</p>
			<p>* данная настройка создает зону с интенсивностью запросов в 1 запрос в секунду.</p>
			<p>После настраиваем лимит для конкретного виртуального домена в разделе server - location:</p>
			<p class="codes">
				server {</br>
				...</br>
				location / {</br>
				...</br>
				limit_req zone=one burst=5 nodelay;</br>
				...
			</p>
			<p>* данная настройка вместе с предыдущей зоной, созданной в секции http, позволит лимитировать запросы — 1 запрос в секунду при всплеске 5 запросов.</p>
			<p>Проверяем конфигурационный файл nginx и перезапускаем сервис:</p>
			<p class="codes">
				$ sudo nginx -t</br>
				$ sudo systemctl reload nginx
			</p>
			<p>В лог-файле /var/log/nginx/error.log мы должны увидеть запись на подобие:</p>
			<p class="codes">
				2020/11/16 19:11:08 [error] 1330844#1330844: *16640836 limiting requests, excess: 10.520 by zone "one", client: xxx.xxx.xxx.xxx, server: dmosk.ru, request: "GET / HTTP/1.1", host: "dmosk.ru", referrer: "https://dmosk.ru/page1"
			</p>
			<p>Теперь можно приступать к настройке fail2ban. Создаем фильтр. Вообще в <b>&laquo;Fail2Ban&raquo;</b> уже есть встроенный фильтр для <b>&laquo;Nginx&raquo;</b> и он вполне нормальный, да и отрабатывает вполне неплохо. Но, на всякий случай, вот рабочая конфигурация строк, которые надо изменять.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/filter.d/nginx-limit-req.conf</b></br></br>
				[Definition]</br>
				ngx_limit_req_zones = [^"]+</br>
				failregex = ^\s*\[[a-z]+\] \d+#\d+: \*\d+ limiting requests, excess: [\d\.]+ by zone "(?:%(ngx_limit_req_zones)s)", client: &lt;HOST&gt;,</br>
				ignoreregex =
			</p>
			<p>Создаем правило для fail2ban:</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/nginx-ddos.conf</b></br></br>
				[nginx-ddos]</br>
				enabled = true</br>
				port = http,https</br>
				filter = nginx-limit-req</br>
				action = iptables-multiport[name=nginxddos, port="http,https", protocol=tcp]</br>
				<span style="color:blue;"># action = firewallcmd-multiport[name=nginxddos, port="http,https", protocol=tcp]</span></br>
				logpath = /var/log/nginx/error.log
			</p>
			<p>После настройки не забываем перезапустить fail2ban:</p>
			<p class="codes">
				$ systemctl restart fail2ban
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.5"></a></p>
			<h3>NGINX files</h3>
			<p>Настройка <b>upload</b> файлов.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>


http {
	client_max_body_size 100M;
	client_body_buffer_size 256k;
	proxy_max_temp_file_size 0;

...

}</pre>
			</div>
			<p>Эти строки устанавливают максимальный размер тела запроса, размер буфера тела запроса клиента и размер временного файла, создаваемого nginx при передаче данных.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.6"></a></p>
			<h3>NGINX GZIP</h3>
			<p>Создайте файл <b>&laquo;site_gzip.conf&raquo;</b> со следующим содержимым</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/site_gzip.conf</b>

gzip on;
gzip_comp_level 5;
gzip_min_length 256;
gzip_proxied    any;
gzip_vary       on;
gzip_types
application/atom+xml
application/javascript
application/json
application/ld+json
application/manifest+json
application/rss+xml
application/vnd.geo+json
application/vnd.ms-fontobject
application/x-font-ttf
application/x-web-app-manifest+json
application/xhtml+xml
application/xml
font/opentype
image/bmp
image/svg+xml
image/x-icon
text/cache-manifest
text/css
text/plain
text/vcard
text/vnd.rim.location.xloc
text/vtt
text/x-component
text/x-cross-domain-policy;
# text/html is always compressed by gzip module</pre>
			</div>
			<p>Теперь подключите этот файл с помощью соответствующей директивы в конфигурации вашего сервиса в самом низу, обязательно в блоке <b>&laquo;server&raquo;</b>.</p>
			<p class="codes">
				# gzip content<br>
				include /etc/nginx/site_gzip.conf;
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.7"></a></p>
			<h3>NGINX X-XSS-Protection</h3>
			<p>Заголовок X-XSS-Protection может предотвратить некоторые XSS-атаки.</p>
			<p>Вы можете реализовать защиту XSS, используя три варианта в зависимости от конкретной потребности.</p>
			<ul>
				<li><b>X-XSS-Protection: 0;</b> - олностью отключить фильтр.</li>
				<li><b>X-XSS-Protection: 1;</b> - включить фильтр, но очистить только потенциально вредоносные скрипты.</li>
				<li><b>X-XSS-Protection: 1; mode = block;</b> - ключает фильтр и полностью блокирует страницу.</li>
			</ul>
			<p>Вообще настройка добавляет в блок <b>&laquo;server&raquo;</b>, но в принципе можно и в блок <b>&laquo;http&raquo;</b>.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-XSS-Protection "1; mode=block";

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.8"></a></p>
			<h3>NGINX X-Frame-Options</h3>
			<p>Заголовок X-Frame-Options позволяет снизить уязвимость вашего сайта для clickjacking-атак. Этот заголовок служит инструкцией для браузера не загружать вашу страницу в frame/iframe. Не все браузеры поддерживают этот вариант.</p>
			<p>Настроить X-Frame-Options можно тремя способами:</p>
			<ul>
				<li><b>DENY</b> - полностью отключаетт функции iframe.</li>
				<li><b>SAMEORIGIN</b> - iframe может использоваться только кем-то из того же источника.</li>
				<li><b>ALLOW-FROM</b> - позволяет размещать страницы в окнах iframe только с определенных URL-адресов.</li>
			</ul>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Frame-Options "DENY";

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.9"></a></p>
			<h3>NGINX X-Permitted-Cross-Domain-Policies</h3>
			<p>Аналогично механизму браузеров блокировки стороннего контента Adobe Flash имеет свой. Он регулируется файлами crossdomain.xml сайта, начиная с корневого каталога. Проблема с механизмом в том, что на любом уровне вложенности корневой регулирующий файл (политика безопасности) может быть переопределен. Чтобы избежать таких ситуаций, необходимо задать этот HTTP-заголовок.</p>
			<p>Доступно несколько вариантов настройки:</p>
			<ul>
				<li><b>none</b> - Никакая политика не допускается.</li>
				<li><b>master-only</b> - Разрешить только главную политику.</li>
				<li><b>all</b> - Все позволено.</li>
				<li><b>by-content-only</b> - Разрешить только определенный тип контента.</li>
				<li><b>by-ftp-only</b> - Применимо только для FTP-сервера.</li>
			</ul>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Permitted-Cross-Domain-Policies master-only;

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.10"></a></p>
			<h3>NGINX Strict-Transport-Security</h3>
			<p>Заголовок Strict-Transport-Security запрещает использование незащищенного HTTP соединения на сайте, если есть защищенное HTTPS.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  ...
}</pre>
			</div>
			<p>Лучше включить его в <b>&laquo;/etc/letsencrypt/options-ssl-nginx.conf&raquo;</b>. Ниже этот вариант тоже описан.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.11"></a></p>
			<h3>NGINX X-Content-Type-Options</h3>
			<p>Рейтинг наиболее опасных к использованию возможностей браузера возглавляет возможность Internet Explorer «угадывать» тип файла, игнорируя его MIME-тип.</p>
			<p>При передаче от сервера к браузеру все файлы имеют тот или иной тип, который прямо указывает на суть содержимого файла. Однако, Internet Explorer имеет встроенный механизм, который позволяет по-содержимому файла переопределить его тип.</p>
			<p>Таким образом, обычные текстовые файлы могут быть интерпретированы как JavaScript со всеми вытекающими последствиями. Например, если у вас на сайте запрещена загрузка текстовых файлов с расширениями .js пользователями, то они могут загрузить в виде картинок текстовый файл, содержащий JavaScript-код, который может быть исполнен браузером.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Content-Type-Options nosniff;

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.12"></a></p>
			<h3>NGINX SSL</h3>
			<p><b>SSL 90%</b>.</p>
			<p>Отредактируйте файл вашей конфигурации сервера. Например такой.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/sites-available/example</b>

server {
	...
	listen 443 ssl http2; # Включить http2
    server_name example.com;
    ssl on;
    ssl_stapling_verify on;
	...
}
				</pre>
			</div>
			<p>Теперь отредактируйте файл созданный <b>certbot</b>-ом.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/letsencrypt/options-ssl-nginx.conf</b>
<span style="color:blue;"># HSTS. Лучше включить здесь, а не в http.</span>
<span style="color:blue;">#add_header Strict-Transport-Security "max-age=604800; includeSubDomains" always;</span>
add_header Strict-Transport-Security "max-age=63072000; includeSubdomains;";
<span style="color:blue;">#add_header Strict-Transport-Security "max-age=31536000; includeSubDomains;" preload;</span>

<span style="color:blue;">#ssl_session_cache shared:le_nginx_SSL:10m;</span>
ssl_session_cache shared:SSL:50m;
ssl_session_timeout 1440m;
ssl_session_tickets off;

<span style="color:blue;">#ssl_protocols TLSv1.2 TLSv1.3;</span>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers on;

<span style="color:blue;">#ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:
	ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:
	ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
#ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 
EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !RC4 !aNULL !eNULL !LOW 
	!3DES !MD5 !EXP !PSK !SRP !DSS";
#ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES256-SHA384;
#ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:
	ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:
	DHE-RSA-AES256-GCM-SHA384;</span>
ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:
	TLS_AES_128_CCM_8_SHA256:TLS_AES_128_CCM_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:
	ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:
	ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:
	DHE-RSA-AES256-GCM-SHA384;
ssl_ecdh_curve secp384r1;

<span style="color:blue;"># OCSP Stapling</span>
ssl_stapling on;
resolver 8.8.8.8 8.8.4.4 valid=300s;

<span style="color:blue;"># gzip content</span>
include /etc/nginx/site_gzip.conf;

<span style="color:blue;"># Expect CT (Optional)</span>
add_header Expect-CT "max-age=0";</pre>
			</div>
			<p>Наш <b>GZIP</b>, описанный выше, в принципе, можно подключить здесь.</p>
			<p>Здесь, важны все строки, включая <b>&laquo;Expect CT&raquo;</b> и <b>&laquo;OCSP Stapling&raquo;</b>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.13"></a></p>
			<h3>Fail2ban. Работа со списком заблокированных адресов</h3>
			<p>Получить статистику заблокированных адресов можно следующей командой:</p>
			<p class="codes">
				$ sudo fail2ban-client status <имя правила>
			</p>
			<p>Получить список правил можно командой:</p>
			<p class="codes">
				$ sudo fail2ban-client status
			</p>
			<p>При наличие заблокированных IP-адресов мы увидим, примерно, следующее:</p>
			<p class="codes">
				`- action</br>
				|- Currently banned: 2</br>
				|  `- IP list:       31.207.47.55 10.212.245.29</br>
			</p>
			<p>С помощью iptables:</p>
			<p class="codes">
				$ sudo iptables -L -n --line
			</p>
			<p>С помощью firewall-cmd:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --get-all-rules
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.14"></a></p>
			<h3>Fail2ban. Примеры правил</h3>
			<p>CentOS</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/ssh.conf</b></br></br>
				[ssh]</br>
				enabled = true</br>
				port = ssh</br>
				filter = sshd</br>
				action = firewallcmd-new[name=sshd]</br>
				logpath = /var/log/secure
			</p>
			<p>Ubuntu</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/ssh.conf</b></br></br>
				[ssh]</br>
				enabled = true</br>
				port = ssh</br>
				filter = sshd</br>
				action = iptables[name=sshd]</br>
				logpath = /var/log/auth.log
			</p>
			<p>Asterisk</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/asterisk.conf</b></br></br>
				[asterisk]</br>
				enabled = true</br>
				filter = asterisk</br>
				action = iptables-allports[name=asterisk, protocol=all]</br>
				logpath = /var/log/asterisk/messages
			</p>
			<p>NGINX</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/nginx.conf</b></br></br>
				[nginx]</br>
				enabled = true</br>
				port = http,https</br>
				filter = nginx-http-auth</br>
				action = iptables-multiport[name=nginx, port="http,https", protocol=tcp]</br>
				<span style="color:blue;"># action = firewallcmd-multiport[name=nginx, port="http,https", protocol=tcp]</span></br>
				logpath = /var/log/nginx/error.log
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.15"></a></p>
			<h3>Fail2ban. Удаление</h3>
			<p class="pbold">Средствами fail2ban:</p>
			<p>Для удаление адреса из списка вводим:</p>
			<p class="codes">
				$ sudo fail2ban-client set <имя правила> unbanip <IP-адрес>
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo fail2ban-client set ssh unbanip 31.207.47.55
			</p>
			<p class="pbold">С помощью iptables:</p>
			<p class="codes">
				$ sudo iptables -D <цепочка правил> -s IP-адрес
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo iptables -D fail2ban-ssh -s 10.212.245.29
			</p>
			<p class="pbold">С помощью firewall-cmd:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --permanent --remove-rule <правило>
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --permanent --remove-rule ipv4 filter f2b-sshd 0 -s 188.134.7.221
			</p>
			<p>После необходимо перечитать правила:</p>
			<p class="codes">
				$ sudo firewall-cmd --reload
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="about">
			<p>Copyright &copy; 14.01.2021 by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
