<html>
<head>
	<meta charset="utf-8">
	<title>Безопасность сетевых соединений</title>
	<link rel="icon" href="image/The-security-of-network-connections/firewall-favicon.ico">
	<link rel="stylesheet" href="html/main.css" type="text/css">
	<link rel="stylesheet" href="html/zoom.css" type="text/css">
	<link rel="stylesheet" href="html/table.css" type="text/css">
	<link rel="stylesheet" href="html/frame.css">
	<link rel="stylesheet" href="html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Безопасность сетевых соединений</p>
			</div>
		</div>
		<div class="content">
			<center>
				<h1>Теория и практика.</h1>
			</center>
			<center>
				<div class="images">
					<img src="image/The-security-of-network-connections/Superman-Linux-jpg.jpg" width="150px"/>
				</div>
				<div style="clear:both"></div>
			</center>
			</br>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Пароли,</a></li>
				<li><a href="#part2">Настройка роутеров и маршрутизаторв.</a></li>
				<li><a href="#part3">Настройка безопасности ssh соединений.</a></li>
				<li><a href="#part4">Фаерволы.</a></li>
					<ol>
						<li><a href="#part4.1">Фаервол UFW.</a></li>
						<li><a href="#part4.2">Фаервол Firewalld.</a></li>
					</ol>
				<li><a href="#part5.0">Fail2ban.</a></li>
				<ol>
					<li><a href="#part5.1">Установка и запуск.</a></li>
					<li><a href="#part5.2">Базовая настройка.</a></li>
					<li><a href="#part5.3">Фильтры.</a></li>
					<li><a href="#part5.4">Действия.</a></li>
					<li><a href="#part5.5">Настройка правил.</a></li>
					<li><a href="#part5.6">NGINX DDoS (req limit).</a></li>
					<li><a href="#part5.7">NGINX files.</a></li>
					<li><a href="#part5.8">NGINX GZIP.</a></li>
					<li><a href="#part5.9">NGINX X-XSS-Protection.</a></li>
					<li><a href="#part5.10">NGINX X-Frame-Options.</a></li>
					<li><a href="#part5.11">NGINX X-Permitted-Cross-Domain-Policies.</a></li>
					<li><a href="#part5.12">NGINX Strict-Transport-Security.</a></li>
					<li><a href="#part5.13">NGINX X-Content-Type-Options.</a></li>
					<li><a href="#part5.14">NGINX SSL.</a></li>
					<li><a href="#part5.15">Nginx Отключение серверных токенов.</a></li>
					<li><a href="#part5.16">Nginx Задание размеров буферов.</a></li>
					<li><a href="#part5.17">Работа со списком заблокированных адресов.</a></li>
					<li><a href="#part5.18">Примеры правил.</a></li>
					<li><a href="#part5.19">Удаление.</a></li>
				</ol>
				<li><a href="#part6">Блокировка ip адреса или всей подсети.</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>Пароли.</h2>
			<p>
				Первое что каждый пользователь хочет услышать – ваше соединение максимально защищено. Но так ли это на самом деле? Так ли безопасны соединения с вашими серверами как мы думаем? Будь то сервер контроля версий GIT, файловый сервер или любой другой.
			</p><p>
				Наливайте приятную для вас жидкость, присаживайтесь поудобнее – будет интересно.
			</p><p>
				У любого продвинутого пользователя всегда имеется электронная почта. А если он ещё и по совместительству системный администратор, то скорее всего для упрощения рабочей нагрузки, он почти наверняка будет везде использовать одинаковые пароли. Конечно один пароль легче запомнить, но так делать категорически не стоит. Такое допущение упрощает работу злоумышленникам, а вам добавляет нервного напряжения, что наверняка скажется на вашем здоровье. Хорошенько задумайтесь перед тем, как использовать одинаковые пароли. Хорошо, если вы отделаетесь лёгким испугом, но надеятся на это никогда не стоит. Необходимо забодится о безопасности своих данных заблаговременно.
			</p><p>
				Мы можем бесконечно углубляться в тему паролей, но всё-таки коснёмся нескольких важных вопросов, которые повысят ваш уровень знаний, сохранят не толко ваши нервы, а злоумышленникам значительно усложнят работу.
			</p><p>
				С одной стороны все прекрасно знают какие комбинации для паролей не стоит использовать.  С другой стороны запоминать гигантскую строку из различного набора знаков, которую вам создал генератор паролей также не является выходом, ведь вы можете забыть один из символов, что только прибавит вам головной боли пока вы всё вспомните. Сохранять пароль даже на USB носитель не всегда оправдывает себя, т. к. вашим носителем могут воспользоваться нечестные на руку коллеги по работе. Флеш-карту также легко можно случайно где-нибудь забыть или обранить. Нет, я конечно не призываю вас не сохранять ваши пароли или не использовать генераторы, я просто предостерегаю вас от таких казусов, до того как они произошли. 
			</p><p>
				Так как же поступить в такой сложной ситуации, чтобы не запутаться и не забыть свой пароль, особенно если он не один? 
			</p><p>
				Всё гениальное просто. Вам достаточно придумать и запомнить свою определенную цепочку символов из которых будут состоять ваши пароли, т. е. придумать алгоритм, по которому они и будут создаваться с одной только помощью вашей умной головы. А дальше дело техники. Восстановить подобные пароли по памяти не составит труда. Приведу простой пример. Пусть тестовая цепочка паролей будет состоять из следующего набора символов: 1) дата выхода одного из любимых сериалов вместе с точками, 2) Слитное написание фамилии и имени героя выбранного сериала в пункте 1. Такой комбинации уже будет достаточно. Например: «19.11.2020SamVinchester».
			</p><p>
				24 символа. Неплохо, правда? Такая задача злоумышленникам будет явно не по силам. Разумеется данную комбинацию уже не стоит использовать. Она приведена только в качестве примера, а алгоритм вы должны будете придумать самостоятельно под свои нужды. Теперь созданные наборы паролей можно записать на отдельную Флеш-карту и хранить дома в сейфе за 7 замками. Шучу конечно. Просто использовать лишь в крайнем случае.
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h2>Настройка роутеров и маршрутизаторв.</h2>
			<p>Теперь немного уделим внимания настройкам ваших роутеров и маршрутизаторов.</p>
			<p>
				Многие из вас, дорогие друзья, даже не догадываются насколько они уязвимы. А ведь такое упущение может принести для вас много головной боли. Давайте же это исправим.
			</p><p>
				Кусайте печеньку, запивайте чайком, а я пока что приведу пример настроек роутера TP-Link WR741. В других роутера, например D-Link, ищите аналогичные меню и настройки. 
			</p><p>
				Первое что необходимо изменить в конфигурации – это имя администратора и пароль. Теперь доступ к вашему роутеру ограничен, но пока ещё уязвим. После этого найдите настройку базовой защиты, а именно – межсетевой экран, VPN и ALG. Все указанные пункты необходимо установить в положение «Включить». Сохраните настройки и перейдите в следующий пункт настройки безопасности: «Защита от Dos атак» и также установите в положение «Включить». Не забудьте в этом же меню установить галочки напротив всех остальных пунктов с наименованием - «включить фильтрацию от атак…». 
			</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/tplink-wr741-config-1.jpg" class="fz__minimized" alt="клик для увеличения" title="Настройка базовой защиты" />
				<img src="image/The-security-of-network-connections/tplink-wr741-config-2.jpg" class="fz__minimized" alt="клик для увеличения" title="Расширенные настройки защиты" />
			</div>	
			<p>
				Приведу ещё одну настройку, в которой можно легко ошибиться. В этом же меню безопасности имеется пункт «Локальное управление». По умолчанию настройка установлена в положение «Всем компьютерам в локальной сети…». Многие пользователи устанавливают её во второе положение - «Только указанным компьютерам…». Перед изменением этой настройки необходимо обратить внимание на кнопочку возле пункта «Mac-адрес вашего компьютера». Во многих роутерах на ней указано – «Добавить». В моём же роутере (TL-841L), на этой кнопке написано: «Копировать». Т.е. прошивка моего роутера не позволяет добавлять новые Mac-адреса. Будьте осторожны с этой настройкой. Иначе может возникнуть ситуация, что у вас самого не будет доступа к настройкам вашего маршрутизатора и его придётся сбрасывать к заводским настройкам. Вообщем, только потеряте время и деньги. Думаю, данную настройку стоит оставить по умолчанию.
			</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/tplink-wr741-config-3.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление" />
				<img src="image/The-security-of-network-connections/tplink-wr841-config-4.jpg" class="fz__minimized" alt="клик для увеличения" title="Локальное управление2" />
			</div>
			<p>Также не забудьте про протокол UPnP.</p>
			<p>UPnP - это протокол, который позволяет приложениям и другим устройствам в вашей сети автоматически открывать и закрывать порты для подключения друг к другу. Например, если вы решили подключить принтер ко всем устройствам в доме без UPnP, то вам потребуется сделать это вручную, уделяя внимание каждому отдельному девайсу. Но благодаря UPnP можно автоматизировать этот процесс.</p>
			<p>С поддержкой UPnP они могут автоматически подключаться к сети, получать IP-адрес, находить другие устройства в сети и подключаться к ним, и это очень удобно.</p>
			<p>Первоначально предполагалось, что UPnP будет работать только на уровне локальной сети, что означает, что устройства только в вашей сети могут подключаться друг к другу. Однако многие производители маршрутизаторов теперь включают UPnP по умолчанию, что делает их доступными для обнаружения из WAN, а это приводит к многочисленным проблемам безопасности.</p>
			<p>UPnP не использует аутентификацию или авторизацию (только некоторые устройства), предполагая, что устройства, пытающиеся подключиться к нему, являются надежными и поступают из вашей локальной сети. Это означает, что хакеры могут найти бэкдоры в вашей сети. Например, они отправят UPnP-запрос на ваш маршрутизатор и он откроет им порт без лишних вопросов.</p>
			<p>Если вы планируете отключить протокол UPnP, то вам придётся настроить проброс портов вручную для каждого устройства или программы отдельно. При этом также будет необходимо зарезервировать для каждого устройства отдельный IP адрес.</p>
			<p>Например, для каждого Torrent клиента (или сервера) порт подключения + ip адресс ПК, на котором используется тот или иной Torrent клиент. Иначе, рано или поздно, обнаружете что ваши torrent закачки попросту не работают.</p>
			<p>По умолчанию порт uTorrent клиента ОС Windows 35691. Поэтому рекомендую сгенерировать случайный порт с помощью кнопочки "Случайный".</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/tplink-wr841-config-5.png" class="fz__minimized" alt="клик для увеличения" title="Список клиентов DHCP" />
				<img src="image/The-security-of-network-connections/tplink-wr841-config-6.png" class="fz__minimized" alt="клик для увеличения" title="Резервирование адресов" />
				<img src="image/The-security-of-network-connections/tplink-wr841-config-7.png" class="fz__minimized" alt="клик для увеличения" title="UPnP" />
				<img src="image/The-security-of-network-connections/tplink-wr841-config-8.png" class="fz__minimized" alt="клик для увеличения" title="Виртуальный сервер" />
				<img src="image/The-security-of-network-connections/utorrent.png" class="fz__minimized" alt="клик для увеличения" title="uTorrent" />
				<img src="image/The-security-of-network-connections/transmission.png" class="fz__minimized" alt="клик для увеличения" title="Transmission" />
			</div>
			<p>
				Port Forwarding – или проброс портов, который также иногда называемый перенаправлением портов или туннелированием – это процесс пересылки трафика, адресованного конкретному сетевому порту с одного сетевого узла на другой. Этот метод позволяет внешнему пользователю достичь порта на частном IPv4-адресе (внутри локальной сети) извне, через маршрутизатор с поддержкой NAT.
			</p><p>	
				Проброс портов позволяет пользователям в интернете получать доступ к внутренним серверам с помощью адреса порта WAN маршрутизатора и соответствующего номера внешнего порта. Внутренние серверы обычно конфигурируются с частными адресами IPv4 и когда запрос отправляется на адрес порта WAN через Интернет, маршрутизатор перенаправляет запрос на соответствующий сервер в локальной сети. По соображениям безопасности широкополосные маршрутизаторы по умолчанию не разрешают перенаправление любого внешнего сетевого запроса на внутренний хост.
			</p><p>	
				Port Triggering - это параметр конфигурации маршрутизатора с поддержкой NAT, который управляет связью между внутренними и внешними хост-машинами в IP-сети. Он похож на переадресацию портов в том смысле, что позволяет перенаправлять входящий трафик на определенную внутреннюю хост-машину, хотя переадресованный порт не открыт постоянно, а целевая внутренняя хост-машина выбирается динамически.
			</p><p>	
				Разница между Port Forwarding и Port Triggering в том, что первый это доступ из внешней сети к серверу во внутренней сети, а Port Triggering - это доступ из внутренней сети во внешнюю.
			</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/tplink-wr841-config-9.png" class="fz__minimized" alt="клик для увеличения" title="Port Forwarding" />
				<img src="image/The-security-of-network-connections/tplink-wr841-config-10.png" class="fz__minimized" alt="клик для увеличения" title="Port Triggering" />
			</div>
			<p>	
				DMZ — это специализированный локальный сегмент сети, который содержит в себе общедоступные сервисы с полным открытым доступом для внутренней и внешней сети. Т.е. это конфигурация сети, в которой открытые для общего доступа сервера находятся в отдельном изолированном сегменте сети. Данная концепция обеспечивает отсутствие контактов между открытыми для общего доступа серверами и другими сегментами сети в случае взлома сервера.
			</p><p>	
				Одновременно с этим, домашняя (частная) сеть остается закрытой за сетевым устройством и никаких изменений в ее работе нет.
			</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/tplink-wr841-config-11.png" class="fz__minimized" alt="клик для увеличения" title="DMZ" />
			</div>
			<p>
				Если вы ещё не сделали указанных настроек, то поспешите, пока злоумышленники не причинили вред вашему сетевому устройству и не завладели вашими персональными данными. Данных настроек вполне достаточно, чтобы ограничить доступ любому злоумышленнику. Однако всегда помните, что указанные настройки роутера вовсе не универсальны а только усложняют недоброжелателям работу. 
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h2>Настройка безопасности ssh соединений.</h2>
			<p>Наконец мы подошли к главному вопросу дня – «Настройка безопасности ssh соединений».</p>	
			<p>Для начала необходимо установить пакет для ssh:</p>
			<p class="codes">
				$: sudo pacman -S openssh</br>
				$: sudo yum –y install openssh-server openssh-clients</br>
				$: sudo apt-get update &amp;&amp; sudo apt-get install openssh-server openssh-clients
			</p>
			<p>Затем обязательно выполните генерацию ключей по умолчанию для каждого из ключевых типов, для которых ключи хоста не существуют:</p>
			<p class="codes">
				$: /usr/sbin/ssh-keygen -A
			</p>
			<p>А также сделайте резервную копию настроек sshd сервиса, перед его редактированием</p>
			<p class="codes">
				$: sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.factory-defaults
			</p>
			<p>Запустите sshd сервис и добавте его в атозагрузку:</p>
			<p class="codes">
				$: sudo systemctl start sshd</br>
				$: sudo systemctl enable sshd
			</p>
			<p>Перед тем, как отключить проверку пароля, обязательно скопируйте и вставте сгенерированный ключ с вашего удалённого пк на сервер ssh в конец файла пользователя к которому будете подключаться: <b>&laquo;/home/user/.ssh/authorized_keys&raquo;</b>.</p>
			<p><b>&laquo;user&raquo;</b> - имя вашего созданного пользователя.</p>
			<p>Для VPS или VDS команда отправки публичного ключа будет такой.</p>
			<p class="codes">
				$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@host_ip<br>
				<span style="color:blue;"># Если не работает, возможно дополнительные параметры просто не нужны. Например, в Debian 11 не нужны.</span></br>
				$ ssh-copy-id user@host_ip<br><br>
				<span style="color:blue;"># Порт указывается через -p.</span></br>
				$ ssh-copy-id user@host_ip -p 2222</br>
				<span style="color:blue;"># Соответственно вставте свой порт, который вы настроили в sshd_config</span>
			</p>
			<p>В первое подключение у вас скорее всего будет суперпользователь (root). И после того как вы создадите пользователя, отправлять на сервер свой публичный ssh-ключ обязательно необходимо обоим пользователям, чтобы не потерять доступ.</p>
			<p class="codes">
				$ ssh-copy-id root@host_ip<br>
				$ ssh-copy-id user@host_ip<br><br>
				<span style="color:blue;"># Или так, если вдруг поменяли порт по умолчанию.</span></br>
				$ ssh-copy-id root@host_ip -p 2222<br>
				$ ssh-copy-id user@host_ip -p 2222</br>
				<span style="color:blue;"># Соответственно вставте свой порт, который вы настроили в sshd_config</span>
			</p>
			<p>Или вручную, с помощью флеш-карты, если это ваш домашний сервер или в организации.</p>
			<p class="codes">
				$: cat id_rsa.pub >> /home/user/.ssh/authorized_keys
			</p>
			<p><b>&laquo;user&raquo;</b> - имя вашего созданного пользователя.</p>
			<p>Теперь внесем некоторые изменения от имени суперпользователя в файл: <b>/etc/ssh/sshd_config</b></p>
			<p>
				Протокол SSH первой версии имеет проблемы с безопасностью, которые закрыты во второй версии. Внесите эту строчку вручную, её нет в этом файле. </br>
			</p>
			<p class="codes">Protocol 2</p>
			<p>Отключение проверки пароля:</p>
			<p class="codes">PasswordAuthentication no</p>
			<p>Включаем аутентификацию по открытому ключу:</p>
			<p class="codes">PubkeyAuthentication yes</p>
			<p>Параметр <b>AuthorizedKeysFile</b> определяет файл, в котором содержатся публичные ключи, используемые для аутентификации пользователей по открытому ключу. В записи могут присутствовать переменные, например <b>%h</b> означает домашний каталог пользователя, а <b>%u</b> – имя пользователя. В дальнейшем мы планируем использование аутентификации по открытому ключу - раскомментируем эту строку.
			</p>
			<p class="codes">AuthorizedKeysFile .ssh/authorized_keys</p>
			<p>По умолчанию, все системные пользователи имеют возможность подключаться к системе по SSH. Например, разрешим SSH для пользователей root и networks:</br>
			</p>
			<p class="codes">AllowUsers root networks</p>
			<p>Можно разрешить доступ всем, кроме указанных:</p>
			<p class="codes">DenyUsers root networks</p>
			<p>Выбранных пользователей можно добавить в группу и разрешить доступ только этой группе:</p>
			<p class="codes">AllowGroups ssh_group</p>
			<p>Укажем время, в течение которого, неактивная сессия будет завершена, а также количество проверок доступности клиента, которые могут оставаться без ответа:</p>
			<p class="codes">
				TCPKeepAlive yes</br>
				ClientAliveInterval 300</br>
				ClientAliveCountMax 3
			</p>
			<p>Отключаем уязвимость в виде файла .RHOSTS со списком хостов и пользователей:</p>
			<p class="codes">IgnoreRhosts yes</p>
			<p>Отключаем аутентификацию на базе хоста, которая позволяет пользователю с определённого хоста подключаться к серверу:</p>
			<p class="codes">HostbasedAuthentication no</p>
			<p>Отключаем прямое подключение через root:</p>
			<p class="codes">PermitRootLogin no</p>
			<p>За настройку баннера отвечает параметр Banner</p>
			<p>Запрещаем пустые пароли</p>
			<p class="codes">PermitEmptyPasswords no</p>
			<p>Изменяем порт по умолчанию. Обязательно запомните его. Он понадобится при настройке фаервола.</p>
			<p class="codes">Port 962</p>
			<p>Анализ логов, для расширенного контроля над системой:</p>
			<p class="codes">LogLevel INFO</p>
			<p>Отключаем пересылку X11 через ssh, т.к. данный протокол не ориентирован на безопасность.</p>
			<p class="codes">X11Forwarding no</p>
			<p>Сначала нужно задать эти параметры в sshd_config. Поскольку мы вносим изменения в интерфейсы и удалённой, и клиентской системы, нам нужны права root с обеих сторон.</p>
			<p class="codes">
				PermitRootLogin yes</br>
				PermitTunnel yes
			</p>
			<p>Форвардинг портов. С помощью SSH туннелей вы можете строить целые цепочки для форвардинга портов. Включить или отключить SSH туннелирование можно следующими директивами.</p>
			<p class="codes">AllowStreamLocalForwarding yes</br>
				# AllowTcpForwarding remote</br>
				AllowTcpForwarding yes</br>
				GatewayPorts yes</br>
				# AllowAgentForwarding yes
			</p>
			<p>Сохраните файл и перезапустите sshd сервис:</p>
			<p class="codes">
				$: sudo systemctl restart sshd
			</p>
			<p>Подключиться к серверу теперь можно по ssh-ключу. Обязательно согласитесь на обмен fingerprint ключей.</p>
			<p class="codes">
				$ ssh user@host_ip<br><br>
				<span style="color:blue;"># Или так, если вы меняли порт по умолчанию</span></br>
				$ ssh user@host_ip -p 2222</br>
				<span style="color:blue;"># Соответственно вставте свой порт, который вы настроили в sshd_config</span>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>Фаерволы.</h2>
			<p>Наливайте ещё немного чая, осталось совсем немного.</p>
			<p>Ну а я пока расскажу про 2 фаервола, один из которых вам обязательно понадобится, если вы хотите, чтобы ваш сервер был хоть как-то защищен.</p>
			<p><span style="color:red;"><b>Обратите внимание! <br>Не важно какой у вас используется фаервол - когда вы добавляете в любой фаервол какой-либо сервис - вы добавляете заранее настроеный порт по умолчанию для данного имени сервиса. Порт для каждого известного сервиса внесен в свой определенный отдельный конфигурационный файл. Изменить порт у какого-либо сервиса можно только вручную, изменяя конфигурационный файл нужного сервиса. Если у вас порт того или иного сервиса по какому-либо имени изменен - обязательно вносите в фаервол уже не имя сервиса, а конкретно порт и протокол (tcp или udp)!</b></span></p>
			<p><a name="part4.1"></a></p>
			<h3>Фаервол UFW.</h3>
			<p>Не самый хороший фаервол, но самый удобный в плане простоты настройки.</p>
			<p><b>Обратите внимание, что блокировка входящего трафика в docker-контейнеры может нормально не отработывать. <br>По крайней мере в локальной сети между 2-мя ПК.</b></p>
			<p>Не во всех ОС в репозиториях имеется графическая оболочка к консольной версии утилиты, но с консольной версией работается намного быстрее и удобнее. Установка выполняется следующей командой:</p>
			<p class="codes">
				$: sudo pacman -S ufw gufw</br>
				$: sudo yum -y install ufw</br>
				$: sudo apt install ufw gufw
			</p>
			<p>Команды UFW:</p>
			<p class="codes">
				app list - список доступных имён приложений;</br>
				enable - включить фаерволл и добавить его в автозагрузку;</br>
				disable - отключить фаерволл и удалить его из автозагрузки;</br>
				reload - перезагрузить файервол;</br>
				status - посмотреть состояние фаервола;</br>
				show - посмотреть один из отчётов о работе;</br>
				allow - добавить разрешающее правило;</br>
				deny - добавить запрещающее правило;</br>
				reject - добавить отбрасывающее правило;</br>
				limit - добавить лимитирующее правило;</br>
				delete - удалить правило;</br>
				insert - вставить правило.
			</p>
			<p>Например, чтобы открыть порт ufw для SSH, можно добавить одно из этих правил:</p>
			<p class="codes">
				$: sudo ufw allow OpenSSH</br>
				$: sudo ufw allow 22</br>
				$: sudo ufw allow 22/tcp
			</p>
			<p>Теперь необходимо активировать фаервол. Мне в archlinux для автоматического запуска при перезагрузки системы понадобилось выполнить ещё одну команду.</p>
			<p class="codes">
				$: sudo ufw enable</br>
				$: sudo systemctl enable ufw
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4.2"></a></p>
			<h3>Фаервол Firewalld.</h3>
			<p>Самый сильный и хороший фаервол. Единственный недостаток, он же и большой плюс - <b>требует тщательной настройки и понимания как всё устроено!</b></p>
			<p>
				Самое интересное в данном фаерволе то, что вы настраиваете только то, что будет разрешено. <br>Всё остальное по умолчанию будет запрещено. Обычно так во всех фаерволах.
				<br>Например, при использовании UFW и iptables - необходимо последовательно в последнем настроить и разрешения и запреты. <br>В качестве примера Firewalld можно привести правила маршрутизации, которые вносятся через его параметры. Вы вносите только разрешающие правила. Всё остальное по умолчанию запрещается.<br>Т.е. настраивать отдельные запреты необязательно.
			</p>
			<br>
			<p><b><span style="color:red;">Обратите внимание!</span></b> <br>В данном блоке мы не будем рассматривать все варианты команд и примеров как их использовать. Мы рассмотрим конкретный случай, когда у вас установлен <b>&laquo;wireguard + docker + docker-compose&raquo;</b>, чтобы вы могли быстро на конкретных примерах с подробными объяснениями понять как всё устроено и работает. И также быстро разобраться как и что делать у себя на своем сервере. <br>При этом не важно какой <b>nginx</b> у вас установлен - будь то просто <b>&laquo;Nginx + certbot + python3-certbot-nginx + crontab&raquo;</b> для <b>&laquo;Let’s Encrypt&raquo;</b> сертификтов или <b>&laquo;Nginx proxy manager&raquo;</b> в docker-контейнере или что-то другое. <br><b>Работать везде будет примерно одинаково.</b></p>
			<br>
			<p>Перед тем как приступить к установке и настройке firewalld, мы познакомимся с понятием зон, которые используются для определения уровня доверия к различным соединениям. <b>Вот как раз от них и будет зависеть то как будет работать ваш фаервол.</b></p>
			<p>Например, к сожалению, <i>UFW</i> не всегда блокирует входящий трафик по направлению к <i>docker-контейнерам</i>. При правильной настройке <i>Firewalld</i> можно не только ограничить доступ из-вне к определенным ресурсам внутри вашей системы, но и указать в каких случаях разрешать доступ. <i>UFW</i> такого не умеет. У него либо доступ есть, либо его нет.</p>
			<p>Единственный недостаток <b>Firewalld</b>, на мой скромный взгляд, это необходимость работать только с ним, вместо <b>iptables</b> и <b>ufw</b>. Однако, это даёт намного больше пространства для маневров и более глубокую настройку поведения, которая недоступна в <b>ufw</b>.</p>
			<p><b>Firewalld</b> фильтрует входящий трафик по зонам в зависимости от примененных к зоне правил. <br>Если <b>IP-адрес</b> отправителя запроса соответствует правилам какой-либо зоны, то пакет будет отправляться через эту зону. <br>Если же адрес не соответствует ни одной из настроенных на сервере зоне, пакет будет обрабатываться зоной используемой по умолчанию. <br>При установке <b>firewalld</b> зона по умолчанию называется <b>public</b>.</p>
			<p>В <i>firewalld</i> есть зоны, где уже предварительно настроены разрешения для различных служб. Можно использовать эти настройки или создавать собственные зоны.</p>
			<p>Лучше, конечно, создавать собственные зоны и настраивать в них собственное поведение. Дело в том, что если вам понадобиться <b>VPN-сервер</b>, то в публичной зоне <b>public</b> не рекомендуется включать маскарадинг, т.е. <b>NAT-преобразование адресов</b>, во избежание проблем с внутренней адресацией сервисов, которые так или иначе всё равно будут обращаться к этой зоне, даже если по умолчанию будет установлена и настроена другая. Если попробовать включить маскарадинг в публичной зоне - то даже сам фаервол будет предупреждать вас, выдавая соответствующие <b>&laquo;wrong&raquo;</b> предупреждения - о том, что включать маскарадинг в стандартных зонах фаервола не рекомендуется.</p>
			<p>Однако, такая практика существует и, при необходимости, вполне можно настроить.</p>
			<p>Итак.</p>
			<table>
				<caption>Зоны фаервола Firewalld.</caption>
				<tr>
					<td><b>drop</b></td>
					<td>минимальный уровень доверия. Все входящие соединения блокируются без ответа, допускаются только исходящие соединения;</td>
				</tr>
				<tr>
					<td><b>block</b></td>
					<td>зона схожа с предыдущей, но при отклонении входящих запросов отправляется сообщение icmp-host-prohibited для Ipv4 или icmp6-adm-prohibited для Ipv6;</td>
				</tr>
				<tr>
					<td><b>public</b></td>
					<td>представляет общественные, недоверенные сети. Можно разрешать избранные входящие соединения в индивидуальном порядке;</td>
				</tr>
				<tr>
					<td><b>external</b></td>
					<td>внешние сети при использовании брандмауэра в качестве шлюза. Она настроена для маскирования NAT, поэтому ваша внутренняя сеть остается частной, но доступной;</td>
				</tr>
				<tr>
					<td><b>internal</b></td>
					<td>антоним зоны external. Хост обладают достаточным уровнем доверия, доступен ряд дополнительных служб;</td>
				</tr>
				<tr>
					<td><b>dmz</b></td>
					<td>используется для компьютеров, расположенных в DMZ (изолированные компьютеры без доступа к остальной сети). Разрешены только определенные входящие соединения;</td>
				</tr>
				<tr>
					<td><b>work</b></td>
					<td>зона для рабочих машин (большинство компьютеров в сети доверенные);</td>
				</tr>
				<tr>
					<td><b>home</b></td>
					<td>зона домашней сети. Можно доверять большинству ПК, но поддерживаются только определенные входящие соединения;</td>
				</tr>
				<tr>
					<td><b>trusted</b></td>
					<td>доверять всем машинам в сети. Наиболее открытая из всех доступных опций, требует сознательного использования.</td>
				</tr>
			</table>
			<p>В <i>firewalld</i> используется два набора правил — постоянные и временные. Временные правила работают до перезагрузки сервера. По умолчанию при добавлении правил в firewalld, правила считаются временными <b>&laquo;runtime&raquo;</b>. Чтобы добавить правило на постоянной основе нужно использовать флаг <u>&laquo;--permanent&raquo;</u>. Такие правила будут применяться после перезагрузки сервера.</p>
			<p>Итак, прежде чем установить этот фаервол, необходимо выключить и убрать всё что будет с ним конфликтовать. А именно - <u>ufw</u> и <u>iptables</u>.</p>
			<h3><span style="color:red;"><b>Обратите внимание!</b></span></h3>
			<p><span style="color:red;">Маскировать или полностью удалять <span style="color:blue;">&laquo;iptables.service&raquo;</span>, как рекомендуют большинство источников интернета - не рекомендуется во избежание проблем не только с самим &laquo;Firewalld&raquo;, но и с &laquo;Fail2Ban&raquo;.</span> <span style="color:blue;">&laquo;iptables.service&raquo;, если он вообще есть, необходимо только выключить!</span></p>
			<p>Дело в том, что <b>&laquo;IPTABLES&raquo;</b> и <b>&laquo;Firewalld&raquo;</b> взаимодействуют с системой следующим образом.</p>
			<div id="page" class="clearfix">
				<img src="image/The-security-of-network-connections/IptablesConcepts.png" width="424px"/>
			</div>
			<p>Теперь можно приступать к выполнению команд.</p>
			<p class="codes">
				$ sudo ufw disable</br>
				$ sudo systemctl stop ufw</br>
				$ sudo systemctl disable ufw</br>
				</br>
				$ sudo systemctl stop iptables</br>
				$ sudo systemctl disable iptables</br>
				<span style="color:blue;"># Проверяем</span><br>
				$ sudo systemctl status iptables
			</p>
			<p>Устанавливаем <b>Firewalld</b>, запускаем и проверяем.</p>
			<p class="codes">
				$ sudo apt -y install firewalld</br>
				$ sudo systemctl enable firewalld</br>
				$ sudo systemctl start firewalld</br>
				<span style="color:blue;"># Проверяем</span><br>
				$ sudo systemctl status firewalld</br>
			</p>
			<p>Далее я часто буду употреблять следующие 2 команды:</p>
			<p class="codes">
				$ sudo firewall-cmd --list-all</br>
				<span style="color:blue;"># Покажет в активной зоне все настройки</span></br>
				<span style="color:blue;"># и</span></br>
				$ sudo firewall-cmd --get-active-zones</br>
				<span style="color:blue;"># покажет все активные зоны</span><br>
				$ sudo firewall-cmd --get-services<br>
				<span style="color:blue;"># Список всех сервисов доступных firewalld</span>
			</p>
			<p><b>Обязательно выполните эти 2 команды сверху, чтобы убедиться, что в данный момент у вас в активной зоне по умолчанию (а это скорее всего <u>public</u>) имеется сервис <b>ssh</b> или порт сервиса (если порт изменен). Иначе вы можете потерять доступ к своему серверу. Это важно!</b></p>
			<p>Если <i>ssh</i> сервиса там нет, его можно добавить 2-мя следующими командами:</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhcp<br>
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhcpv6<br>
				<span style="color:blue;"># Сначала DHCP-IPV4, т.к. по умолчанию там только DHCP-IPV6 (dhcpv6-client)</span></br>
				$ sudo firewall-cmd --permanent --zone=public --add-service=ssh</br>
				<span style="color:blue;"># Если порт отличается нужно заменить эту команду на следующую</span></br>
				$ sudo firewall-cmd --permanent --zone=public --add-port=2222/tcp</br>
				<span style="color:blue;"># Обязательно указывайте протокол для порта - иначе получите ошибку добавления</span></br></br>
				$ sudo firewall-cmd --reload</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
			</p>
			<p>К сожалению сервиса <b>&laquo;dhclient&raquo;</b> для <b>ipv4</b> в <b>Firewalld</b> нет, т.е. <b>&laquo;.xml&raquo;</b>-файла с указанными портами и протоколами. Имеется введу конкретно сервис для клиента, чтобы сервер мог отдать клиенту заданные в настройках <b>IP</b> адреса.</p>
			<p>Такой сервис можно создать самостоятельно.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Создаем сервис для firewalld в виде xml-файла</span>
<b>$ sudo nano /usr/lib/firewalld/services/dhclient.xml</b>

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service&gt;
  &lt;short&gt;dhclient&lt;/short&gt;
  &lt;description&gt;This allows a DHCLIENT to accept messages from DHCP server and relay agents.&lt;/description&gt;
  &lt;port protocol="udp" port="67"/&gt;
  &lt;port protocol="udp" port="68"/&gt;
&lt;/service&gt;


<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Обязательно перезагружаем правила</span>
<b>$ sudo firewall-cmd --reload</b>
<span style="color:blue;"># Проверяем, что у нас получилось</span>
<b>$ sudo firewall-cmd --info-service=dhclient</b>
dhclient
  ports: 67/udp 68/udp
  protocols:
  source-ports:
  modules:
  destination:
  includes:
  helpers:</pre>
			</div>
			<p>После чего добавляем в нужную зону.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=public --add-service=dhclient</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br>
				<span style="color:blue;"># Проверяем</span></br>
				$ sudo firewall-cmd --info-zone=public
			</p>
			<p>В случае, если вы не меняли настройки сетевых карт сервера по умолчанию на ручные (<i>&laquo;/etc/network/interfaces&raquo;</i>), то добавлять <i>DHCP-сервисы</i> обязательная процедура, чтобы сервер смог получить свой адрес. Если у вас ручные настройки сетевых карт, можно не добавлять ни один <i>DHCP-сервис</i>. Но, обычно в любой <b>VPS</b> или <b>VDS</b> не рекомендуется ставить ручные настройки сетевых карт, хотя это вполне возможно и нормально. Ручные настройки чаще всего прописывают на своих собственных серверах, на которых как раз и установлен <i>DHCP-сервер</i>, который как раз и раздаёт всем ПК в локальной сети IP адреса. Однако, в таком случае, все <i>DHCP-сервисы</i> необходимо добавлять в нужные зоны. Иначе ПК в сети не смогут получить свои адреса, а сервер раздать их.</p>
			<p>И ещё раз убедитесь, что <i>ssh</i> или порт появились в зоне <i>public</i>.</p>
			<p class="codes">
				$ sudo firewall-cmd --list-all<br>
				<span style="color:blue;"># или</span></br>
				$ sudo firewall-cmd --info-zone=public
			</p>
			<p>Далее у вас уже должен быть запущен <b>wireguard</b> и <b>docker</b> сервисы, чтобы их сети были включены и доступны.</p>
			<p>Сразу выполним команду, с помощью которой определим все необходимые нам наименования сетей - сеть по которому идёт интернет, сети ваших контейнеров (при появлении новых, обязательно вносить их в дальнейшие настройки), и сеть VPN wireguard.</p>
			<p class="codes">
				$ ip a
			</p>
			<p>У меня в виртуальной машине используются следующие сети. У вас могут быть другие. Пока просто запомним их. Они нам далее пригодятся.</p>
			<ul>
				<li><b>enp0s3</b> - интернет сетевая карта.</li>
				<li><b>wg0</b> - wireguard сеть.</li>
				<li><b>br-00aaad17d4b5</b> - docker сеть.</li>
				<li><b>br-c2ecab4afa7c</b> - docker сеть.</li>
				<li><b>docker0</b> - docker сеть.</li>
			</ul>
			<p><span style="color:red;">Теперь, перед тем, как продолжать необходимо понять несколько важных аспектов, т.к. без этих настроек у вас могут возникнуть <span style="color:blue;">БОЛЬШИЕ ПРОБЛЕМЫ</span>.</span></p>
			<p>Дело в том, что <i>firewalld</i> сервис стартует сразу после запуска сети. А <i>docker</i> сервис несколько позже. И также несколько позже стартует <i>wireguard</i>. Поэтому если вы просто добавить сети <i>docker</i>-а куда-либо, то после перезагрузки сервера мало того, что фаервол не запуститься, тык ещё и <i>docker</i>-сервис также не сможет запуститься.</p>
			<p>Чтобы отрабатывал <i>nginx</i> - ему нужны сети, которые есть в <i>docker</i>-контейнерах. Сервису <i>firewalld</i> нужны все сети - и те что в <i>docker-ах</i>, и от <i>wireguard-а</i>. Ну а чтобы он правильно маршрутизировал трафик ему нужен запущенный <i>nginx</i>. И последний <i>fail2ban-у</i> нужен в первую очередь <i>firewalld-сервис</i>, чтобы правильно отрабатывали все ловушки.</p>
			<p>Если вы попытаетесь добавить строку вида: <b>&laquo;After=docker.service&raquo;</b> в службу <b>firewalld.service</b>, то после перезагрузки сервера вы также получите те же ошибки и проблемы запуска.</p>
			<p>Лучше всего будет <b>firewalld.service</b> запускать по таймеру <b>systemd</b>, что решит все проблемы.</p>
			<p>Поэтому, чтобы всё правильно запускалось, в правильной последовательности и не вызывало ошибок - уберем из автозагрузки <b>docker</b> и <b>nginx</b> сервисы и создадим для них <b>systemd-таймеры</b>. Таким образом, сначала будет запускаться <b>wireguard</b>, затем <b>docker</b>, <b>nginx</b>, <b>firewalld</b> и только после этого <b>fail2ban</b>.</p>
			<p>Убираем nginx и docker из автозагрузки.</p>
			<p class="codes">
				$ sudo systemctl disable nginx</br>
				$ sudo systemctl disable docker</br>
			</p>
			<p>Создадим таймеры <b>docker</b> и <b>nginx</b>, добавим в автозагрузки и запустим их.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/systemd/system/docker.timer</b>

[Unit]
Description=Starting Docker on after services wireguard
Wants=wg-quick.target
After=wg-quick.target

[Timer]
Unit=docker.service
OnBootSec=5s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>

<b>$ sudo nano /etc/systemd/system/nginx.timer</b>

[Unit]
Description=Starting Nginx on after services docker
Wants=docker.timer
After=docker.timer

[Timer]
Unit=nginx.service
OnBootSec=10s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>

<b>$ sudo systemctl start docker.timer</b>
<b>$ sudo systemctl enable docker.timer</b>
<b>$ sudo systemctl start nginx.timer</b>
<b>$ sudo systemctl enable nginx.timer</b></pre>
			</div>
			<p>Вот теперь переходим к таймеру <b>firewalld</b>.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># <span style="color:red;">Выключим</span> стандартный способ включения фаервола</span>
<b>$ sudo systemctl disable firewalld</b>
<span style="color:blue;"># и создадим systemd таймер для нормального запуска firewalld сервиса без ошибок</span>
<b>$ sudo nano /etc/systemd/system/firewalld.timer</b>

[Unit]
Description=Starting Firewalld on after services nginx
Wants=nginx.timer
After=nginx.timer

[Timer]
Unit=firewalld.service
OnBootSec=15s
AccuracySec=1s

[Install]
WantedBy=timers.target

<span style="color:blue;"># Сохранение настроек, выход</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Добавление таймера в автозапуск</span>
<b>$ sudo systemctl enable firewalld.timer</b>
<b>$ sudo systemctl start firewalld.timer</b></pre>
			</div>
			<p>Таймер не обязательно должен называться точно также как и сервис, но расширение должно быть именно <b>&laquo;.timer&raquo;</b>.</p>
			<p>Параметры таймера:</p>
			<ul>
				<li><b>Unit</b> - какой сервис необходимо запускать по таймеру.</li>
				<li><b>AccuracySec</b> - точность таймера равна 1 секунде. По умолчанию точность таймера равно 1 минуте. Поэтому для заданий, которые выполняются чаще 1 минуты, нужно использовать этот параметр.</li>
				<li><b>OnUnitActiveSec</b> - определяет отсчёт времени от момента запуска юнита, который был активирован таймером. Другими словами отсчет ведётся с момента запуска test-timer.service, и когда он доходит до нуля, таймер срабатывает вновь. Вместо этого параметра можно использовать следующие:</li>
				<ul>
					<li><b>OnActiveSec</b> - отсчёт относительно момента активации самого таймера.</li>
					<li><b>OnBootSec</b> - отсчёт ведётся с момента запуска компьютера, например через 30 секунд, после запуска компьютера.</li>
					<li><b>OnUnitInactiveSec</b> - отсчёт начинается с момента деактивации юнита, который запускается таймером. Этот параметр противоположен <b>OnUnitActiveSec</b>.</li>
					<li><b>OnCalendar</b> - определяет таймер реального времени. Этот параметр может быть указан несколько раз, если нужно.</li>
				</ul>
			</ul>
			<p><b>Только после этого, можно подготавливать дальнейшую работу фаервола.</b></p>
			<p>Теперь необходимо добавить все <u>docker-сети</u> к внутренней зоне фаервола <u>internal</u>. Т.е. к этим сетям будет иметь доступ только сам хост сервера. Из-вне доступа ни у кого не будет, кроме <u>wireguard</u>-а при подключении к нему. Всё нормально, мы этот момент дальше поправим, чтобы иметь к контейнерам доступ по доменам через 80 и 443 порт на входе в систему.</p>
			<p>Это необходимо сделать не только ради ограничения доступа, но ещё по 1 причине.</p>
			<p>Дело в том, что после перезагрузки <b>firewalld</b> сканирует все доступные сети и если не находит во всех имеющихся зонах какой-либо существующий интерфейс - автоматически создаст новую зону с этими наименованиями интерфейсов сетей.</p>
			<p><b>Это проблема.</b> Т.к. если будет существовать зона с указанными сетями - у вас будет случайный доступ из-вне к одному из ваших контейнеров (может даже ко всем контейнерам), даже если вы не указывали порт доступа.</p>
			<p>Создавать скрипт и отдельный сервис ради удаления новой зоны бессмесленно, т.к. мы и устанавливали <b>&laquo;firewalld&raquo;</b> ради правильного и беспощадного ограничения доступа, какого нет в <b>&laquo;ufw&raquo;</b>.</p>
			<p>Кстати говоря, на заметку, именно так обычно и происходит в <b>ufw</b> фаерволе. Поэтому в нём ограничить доступ из-вне значительно сложнее.</p>
			<p>Чтобы такого не происходило - и не появлялось случайного доступа - необходимо при каждом новом контейнере, если у него есть своя новая сеть - обязательно добавлять её во внутреннюю зону фаервола. Так, при каждом перезапуске сервера - он не будет создавать новых зон, т.к. все сети будут уже заняты - каждая в свой зоне. И у вас не будет появляться случайного доступа из-вне.</p>
			<p>С помощью команды <b>&laquo;$ ip a&raquo;</b> выше мы получили нужные нам списки сетей. Теперь используем их.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=br-00aaad17d4b5</br>
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=br-c2ecab4afa7c</br>
				$ sudo firewall-cmd --permanent --zone=internal --add-interface=docker0</br>
				<span style="color:blue;"># Обязательно перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:blue;"># и проверяем что у нас получилось</span></br>
				$ sudo firewall-cmd --info-zone=internal
			</p>
			<p>Теперь можно создавать зоны фаервола с нужным нам доступом. Создадим зоны, например, <b>&laquo;mysite&raquo;</b> и <b>&laquo;mywg&raquo;</b>. Пока поработаем надо зоной <b>&laquo;mysite&raquo;</b>.</p>
			<p>Добавим в эту зону <i>&laquo;DHCP&raquo;</i> и <i>&laquo;SSH&raquo;</i>, несколько портов, включая <i>&laquo;wireguard&raquo;</i>, а также включим <b>&laquo;NAT&raquo;</b>, чтобы при подключении к <i>&laquo;wireguard&raquo;</i> у нас были свои <i>IP</i> адреса, заданные в <i>&laquo;.conf&raquo;</i>-файле. У меня порт <i>&laquo;SSH&raquo;</i> остался в виртуальной машине по умолчанию. Лучше так не делать и менять его на другой. Тогда вместо добавления сервиса надо будет добавлять конкретно порт, а не менять его в конфигурационных файлах, что будет более наглядно для вас самих и работать будет абсолютно также, но не правильнее.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --new-zone=mysite</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=dhcp</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=dhcpv6</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=ssh</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=http</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-service=https</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-port=51820/udp</br>
				$ sudo firewall-cmd --permanent --zone=mysite --add-masquerade</br></br>
				$ sudo firewall-cmd --reload
			</p>
			<p>Мы ешё не закончили с этой зоной. Это только подготовительная часть - чтобы в процессе не потерять доступ.</p>
			<p>Теперь добавим к этой зоне интерфейс и убедимся, что всё правильно работает. Вот теперь у нас есть доступ к нашим контейнерам по 80 и 443 портам по именам доменов + доступ к vpn сервису.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Добавляем интерфейс, у вас будет свой</span>
<b>$ sudo firewall-cmd --permanent --zone=mysite --add-interface=enp0s3</b>
<span style="color:blue;"># Меняем зону по умолчанию</span>
<b>$ sudo firewall-cmd --set-default-zone=mysite</b>
<span style="color:blue;"># Обязательно перезагружаем правила</span>
<b>$ sudo firewall-cmd --reload</b>

<span style="color:blue;"># Всё проверяем</span>
<b>$ sudo firewall-cmd --get-default-zone</b>
mysite
<b>$ sudo firewall-cmd --info-zone=mysite</b>
mysite (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3
  sources: 
  services: dhcp dhcpv6-client http https ssh
  ports: 51820/udp
  protocols: 
  forward: no
  masquerade: yes
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
<b>$ sudo firewall-cmd --info-zone=public</b>
public
  target: default
  icmp-block-inversion: no
  interfaces: 
  sources: 
  services: dhcp dhcpv6-client ssh
  ports: 
  protocols: 
  forward: no
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
<b>$ sudo firewall-cmd --get-active-zones</b>
internal
  interfaces: br-00aaad17d4b5 br-c2ecab4afa7c docker0
mysite
  interfaces: enp0s3
<b>$ sudo firewall-cmd --list-all</b>
mysite (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3
  sources: 
  services: dhcp dhcpv6-client http http ssh
  ports: 51820/udp
  protocols: 
  forward: no
  masquerade: yes
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:</pre>
			</div>
			<p>Теперь займемся зоной <b>&laquo;mywg&raquo;</b>. Здесь немного посложнее.</p>
			<p>Здесь помимо всего остального доступа необходимо будет настроить таблицы маршрутизации, но т.к. у нас нет <b>&laquo;iptables&raquo;</b>,то это делается через <b>&laquo;firewalld&raquo;</b>.</p>
			<p class="codes">
				<span style="color:blue;"># Создаем новую зону</span></br>
				$ sudo firewall-cmd --permanent --new-zone=mywg</br></br>
				<span style="color:blue;"># Обязательно перезагружаем правила для применения зименений</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:blue;"># Добавляем в зону интерфейс</span></br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-interface=wg0</br></br>
				<span style="color:blue;"># Перезагружаем правила</span></br>
				$ sudo firewall-cmd --reload</br></br>
				<span style="color:red;"># Правило POSTROUTING добавлять не нужно, если уже включен маскарадинг в зоне.</span>
				<span style="color:blue;"></br># Правило POSTROUTING отвечает за изменение исходящих IP-адресов на маршрутизаторе или компьютере, который является шлюзом по умолчанию. </br># Если маскарадинг уже включен в зоне, то этого достаточно для настройки NAT-преобразования IP-адресов. </br># Однако, такая возможность существует и настраивается он не через iptables, а в firewalld следующим образом.</span></br>
				$ sudo firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -o enp0s3 -j MASQUERADE</br></br>
				<span style="color:red;"># Для разрешения пропуска трафика из одной сети в другую, необходимо добавить правило в FORWARD в firewalld.</span></br>
				<span style="color:blue;"># Это правило указывает, какой трафик должен быть разрешен для маршрутизации между различными сетями. </br># Без правила FORWARD маршрутирование между сетями может быть заблокировано.</span></br>
				<span style="color:blue;"># Добавляем в iptables в таблицу FORWARD разрешение на пропуск трафика из одной сети в другую</span></br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter FORWARD 0 -i enp0s3 -o wg0 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter FORWARD 0 -i wg0 -o enp0s3 -m state --state RELATED,ESTABLISHED -j ACCEPT</br></br>
				<span style="color:blue;"># Перезагружаем весь фаервол для применение таблиц маршрутизации</span></br>
				$ sudo systemctl restart firewalld</br></br>
				<span style="color:blue;"># И смотрим на добавленные правила маршрутизации - если что-то не правильно - вы сразу увидите</span></br>
				$ sudo firewall-cmd --direct --get-all-rules</br>
			</p>
			<p>Добавим доступ по <i>&laquo;SSH&raquo;</i>, откроем доступ к <i>&laquo;Portainer-у&raquo;</i> через <i>&laquo;wireguard&raquo;</i>, если <i>&laquo;portainer&raquo;</i> имеется, и посмотрим на все внесенные изменения.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Добавляем ssh и 9000 порт portainer-а и перезагружаем правила</span>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=ssh</b>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=http</b>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-service=https</b>
<b>$ sudo firewall-cmd --permanent --zone=mywg --add-port=9000/tcp</b>
<span style="color:blue;"># Для Portainer-а, визуального контроля контейнеров, 9000 порт.</span>
<b>$ sudo firewall-cmd --reload</b>

<span style="color:blue;"># Всё проверяем</span>
<b>$ sudo firewall-cmd --info-zone=mywg</b>
<b>$ sudo firewall-cmd --info-zone=public</b>
<b>$ sudo firewall-cmd --get-active-zones</b>
internal
  interfaces: br-00aaad17d4b5 br-c2ecab4afa7c docker0
mysite
  interfaces: enp0s3
mywg
  interfaces: wg0</pre>
			</div>
			<p>Всё! На этом настройки данного фаервола завершены.</p>
			<h3>Переходим к настройкам wireguard-а.</h3>
			<p>Настроим конфигурацию сервера. Закоментируем строки с маршрутизацией и перезапустим сервис.</p>
			<p class="codes">
				<b>$ sudo nano /etc/wireguard/wg0.conf</b></br></br>
				[Interface]</br>
				... </br>
				<span style="color:blue;"># PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE</br></br>
				# PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o enp0s3 -j MASQUERADE</span></br>
				... </br></br>
				<b>$ sudo systemctl restart wg-quick@wg0</b></br>
			</p>
			<p>К сожалению, совместить как-то по другому, увы, нельзя. Ну а на этом настройки фаервола и wireguard для совместной работы завершены.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.0"></a></p>
			<h2>Fail2ban</h2>
			<p><a name="part5.1"></a></p>
			<h3>5.1. Установка и запуск</h3>
			<p>Описывая <b>Fail2ban</b> в двух словах, можно сказать, что он позволяет на основе анализа логов блокировать тех, кто злоупотребляет доступностью сервера по сети. Например, защитить почтовые ящики от взлома путем перебора паролей или многократного запроса какого-либо ресурса.</p>
			<p>Установка производится следующей командой:</p>
			<p class="codes">
				$ sudo yum install fail2ban</br>
				$ sudo apt-get install fail2ban</br>
				$ sudo pacman -S fail2ban
			</p>
			<p>Для запуска службы вводим команду:</p>
			<p class="codes">
				$ sudo systemctl start fail2ban
			</p>
			<p>А вот сразу добавлять <i>fail2ban</i> в автозапуск - не рекомендую.</p>
			<p class="codes">
				<s>$ sudo systemctl enable fail2ban</s>
			</p>
			<p><b>Объясню небольшую проблему запуска <i>fail2ban-а</i></b>. Дело в том, что он запускается раньше всех, даже раньше <i>firewalld</i> и значительно раньше <i>docker</i>-а. В результате правила просто не действуют. А вот если бы он стартовал позже нашего фаервола, который уже настроен на запуск позже <i>docker-сервиса</i> - это было бы идеально. Поэтому создаём таймер аналогичный запуску фаервола, за исключением того, что указываем запуск после него.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/systemd/system/fail2ban.timer</b>

[Unit]
Description=Starting Fail2Ban on after services Firewalld
Wants=firewalld.timer
After=firewalld.timer

[Timer]
Unit=fail2ban.service
OnBootSec=20s
AccuracySec=1s

[Install]
WantedBy=timers.target
				</pre>
			</div>
			<p>Вот теперь запускаем.</p>
			<p class="codes">
				$ sudo systemctl enable fail2ban.timer<br>
				$ sudo systemctl start fail2ban.timer
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.2"></a></p>
			<h3>5.2. Базовая настройка.</h3>
			<p>Процесс настройки fail2ban не зависит от дистрибутива Linux. Основной конфигурационный файл находится по пути <b>&laquo;/etc/fail2ban/jail.conf&raquo;</b>. Однако, его не рекомендуется менять и для настройки используют подключаемые файлы из каталога <b>&laquo;/etc/fail2ban/jail.d&raquo;</b>.</p>
			<p>Для начала создаем первый файл, в котором будут храниться настройки по умолчанию.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/default.conf</b></br></br>
				[DEFAULT]</br>
				maxretry = 5</br>
				findtime = 5m</br>
				bantime = 10m</br>
				action = firewallcmd-ipset</br>
				ignoreip = 127.0.0.1/8 192.168.0.100</br>
			</p>
			<p>* где:</p>
			<ul>
				<li><b>maxretry</b> &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;количество действий, которые разрешено совершить до бана</li>
				<li><b>findtime</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время, в течение которого учитывается maxretry;</li>
				<li><b>bantime</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;время, на которое будет блокироваться IP-адрес;</li>
				<li><b>action</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;действие, которое будет выполняться, если Fail2ban обнаружит активность, соответствующую критериям поиска;</li>
				<li><b>ignoreip</b> &nbsp;&nbsp;&nbsp;&nbsp;— &nbsp;&nbsp;игнорировать защиту, если запросы приходят с перечисленных адресов.</li>
			</ul>
			<p>* В секции [DEFAULT] хранятся общие настройки для всех правил. Каждую из настроек можно переопределить при конфигурировании самого правила.</p>
			<p>Время указывается в следующих выборках:</p>
			<ul>
				<li><b>&laquo;s&raquo;</b> - секунды;</li>
				<li><b>&laquo;m&raquo;</b> - минуты;</li>
				<li><b>&laquo;h&raquo;</b> - часы.</li>
			</ul>
			<p>В данном примере, если в течение 5 минут будет найдено 5 строк (maxretry = 5), содержащих критерий фильтра, Fail2ban заблокирует IP-адрес, с которого идет подключение на 10 минут.<br>Т.е. если вы ошибетесь 5 раз в течении 5 минут - вас заблокирует на 10 минут.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.3"></a></p>
			<h3>5.3. Фильтры.</h3>
			<p>По умолчанию в Fail2ban встроено несколько фильтров, позволяющих обеспечить базовую защиту большинству веб-интерфейсов вашего сервера: ssh, веб-серверы и т.д.</p>
			<p>Фильтры можно найти в каталоге <b>&laquo;/etc/fail2ban/filter.d&raquo;</b>.</p>
			<p>Но иногда возникают ситуации, когда атака на сервер ведётся более изобретательно, и стандартные шаблоны Fail2ban с ней не справляются. В этом случае можно самостоятельно написать фильтр, который будет отслеживать конкретные паттерны в поведении ботов или хакеров и блокировать их попытки проникновения на сервер.</p>
			<p>Фильтр можно создать самостоятельно и далее использовать его в той или иной конфигурации настроек правил. Например, для отслеживания состояния доступа к вашему сайту.</p>
			<p>Основной признак попыток — «подозрительная активность» в логах. Это могут быть регулярные попытки подключения с разных IP-адресов, запросы к различным портам сервера, запросы на те или иные ресурсы.</p>
			<p>Фильтры, в основном, представляют набор регулярных выражений для поиска ключевых слов в файлах логов. Причем самое забавное, что это регулярные варажения <b>BASH</b>. Таким образом создать такое выражение будет не сильно сложным, и справиться сможет даже новичок. Нужно лишь соблюдать несколько простых правил.</p>
			<p></p>
			<ul>
				<li><b>^</b> - обязательно прописывается в начале строки регулярного выражения. Говорит о том, что строка начинается со следующего символа. Если же у вас строгая заись с чего начинается строка - в принципе, можно не указывать символ, однако, лучше тогда прописать чего перед вашей строгой записью начала строки.</li>
				<li><b>$</b> - обязательно ставится в конце строки, чтобы строка регулярного выражения была завершённой. Иначе строка не будет оконченой, и регулярное выражение не будет работать.</li>
				<li><b>^.*</b> - поиск должен с чего-то начинаться. Если у вас в логах четкая запись того, с чего начинаются все подозрительные вами строки, то именно с этой части строки и надо начинать строку регулярного выражения. Если начало строки всегда разное - лучше указать конкретно символ начала строки и то, что за ним может быть любой символ или неопределённое количество символов.</li>
				<li><b>&lt;HOST&gt;</b> - обязательно указываете в том месте строки вашего регулярного выражения, где вы встречаете ip адрес вместе с одинарными угловыми скобками влево и вправо.</li>
				<li><b>.*$</b> - ставиться в конце строки. Показывает, что строка заканчивается неопределённым набором символов, или о том, что от строки к строке конец строки каждый раз будет сильно розница.</li>
				<li><b>.*[]^${}\+?|()</b> - Мета и спец символы. Если используете как обычный символ - необходимо экранировать обратным слешем.</li>
				<li>Символ &laquo;точка&raquo; - используется для поиска любого одиночного символа, за исключением символа перевода строки.</li>
				<li><b>[]</b> - классы символов. Можно организовать поиск любого символа из заданного набора. Например, [a-zA-Z] - символы от <b>a</b> до <b>z</b> и также прописные символы. в данном случае через тире получается целый диапазон символов. Добавьте точку и запятую без пробелов - и поиск будет ещё точки и запятой. Так, например можно указать конкретно одни цифры - [0-9]. В классе можно указывать несколько диапазонов, как со строчными или прописными символами.</li>
				<li><b>[^]</b> - отрицание класса символов.</li>
				<li>Специальные классы символов.</li>
				<ol>
					<li><b>[[:alpha:]]</b> - соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.</li>
					<li><b>[[:alnum:]]</b> - соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах 0-9, A-Z, a-z.</li>
					<li><b>[[:blank:]]</b> - соответствует пробелу и знаку табуляции.</li>
					<li><b>[[:digit:]]</b> - любой цифровой символ от 0 до 9.</li>
					<li><b>[[:upper:]]</b> - алфавитные символы в верхнем регистре — A-Z.</li>
					<li><b>[[:lower:]]</b> - алфавитные символы в нижнем регистре — a-z.</li>
					<li><b>[[:print:]]</b> - соответствует любому печатаемому символу.</li>
					<li><b>[[:punct:]]</b> - соответствует знакам препинания.</li>
					<li><b>[[:space:]]</b> - пробельные символы, в частности — пробел, знак табуляции, символы NL, FF, VT, CR.</li>
				</ol>
				<li>Символ &laquo;«звёздочка»&raquo; - это будет означать, что регулярное выражение сработает, если символ появляется в строке любое количество раз — включая и ситуацию, когда символ в строке отсутствует. Звёздочку можно использовать и с классами символов.</li>
				<li>Вопросительный знак - указывает на то, что предшествующий символ может встретиться в тексте один раз или не встретиться вовсе. Этот символ — один из метасимволов повторений.</li>
				<li>Символ &laquo;плюс&raquo; - указывает на то, что регулярное выражение обнаружит искомое в том случае, если предшествующий символ встретится в тексте один или более раз. При этом на отсутствие символа такая конструкция реагировать не будет.</li>
				<li>Фигурные скобки <b>&laquo;{}&raquo;</b> - позволяют точнее задавать необходимое число вхождений предшествующего им символа. Указывать ограничение можно в двух форматах.</li>
				<ul>
					<li><b>n</b> — число, задающее точное число искомых вхождений.</li>
					<li><b>n, m</b> — два числа, которые трактуются так: &laquo;как минимум n раз, но не больше чем m&raquo;.</li>
				</ul>
				<li>Символ логического &laquo;или&raquo; - Символ | — вертикальная черта, означает в регулярных выражениях логическое &laquo;или&raquo;. Обрабатывая регулярное выражение, содержащее несколько фрагментов, разделённых таким знаком.</li>
				<li>Фрагменты регулярных выражений можно группировать./li>
			</ul>
			<p>Это основные правила создания <b>BASH</b> регулярных выражений. <u>Перейдём к практике</u>.</p>
			<p>Начнём создавать регулярное выражение. Для 2 примеров будет отслеживать все ошибки <b>NGINX</b> в логах доступа и просто ошибки самого <b>NGINX</b>.</p>
			<p>Сначала создадим регулярное выражение отслеживания ошибок.</p>
			<p>Чтобы это сделать просмотрим либо стандартный файл логов <b>NGINX</b>, либо созданый вами для отдельной конфигурации. У меня же он стандартный - <b>&laquo;/var/log/nginx/access.log&raquo;</b>. Однако, просматривать лог вручную - то ещё удовольствие. Поэтому немного его отфильтруем, для понимания того, какие виды строк нам вообще необходимо отслеживать.</p>
			<p>Вообще у <b>NGINX</b> есть строго определённые виды статусов. Они имеют следующий вид:</p>
			<ul>
				<li><b>1xx informational response</b> - запрос получен, процесс продолжается.</li>
				<li><b>2xx successful</b> - запрос был успешно получен, понят и принят.</li>
				<li><b>3xx redirection</b> - необходимо предпринять дальнейшие действия для выполнения запроса.</li>
				<li><b>4xx client error</b> - запрос содержит неправильный синтаксис или не может быть выполнен.</li>
				<li><b>5xx server error</b> - серверу не удалось выполнить явно допустимый запрос.</li>
			</ul>
			<p>Теперь можно попробовать хоть немного отфильтровать файл логов.</p>
			<p class="codes">
				<b>$</b> sudo cat /var/log/nginx/access.log | grep -Ei "(GET|POST|HEAD)" | grep -Ei "(4[0-9]{2}|5[0-9]{2})"</br>
			</p>
			<p>Оба выражения из утилиты <b>&laquo;Grep&raquo;</b> будем использовать в регулярном выражении для Fail2ban-а. В фильтре необходимо указать как минимум 3 строки, даже если одна из них будет пустой.</p>
			<p>В принципе в конфигурациях <b>Fail2ban</b>-а пустая строка в определении какой-либо переменной - обычное дело. Т.е. это не bash. В bash-е обычно пустая строка указывается просто двумя кавычками, иногда двойными. А здесь если строка пустая - даже пробел не ставится.</p>
			<p>Итак, фильтр <b>&laquo;/etc/fail2ban/filter.d/nginx-access.conf&raquo;</b>.</p>
			<p class="codes">
				[Definition]</br></br>
				failregex = ^&lt;HOST&gt;.*"(GET|POST|HEAD).*" (4[0-9]{2}|5[0-9]{2}) .*$</br></br>
				ignoreregex =
			</p>
			<p>Таким же образом отфильтруем просто ошибки <b>NGINX</b> - <b>&laquo;/var/log/nginx/error.log&raquo;</b>, сначала вручную, а затем создадим на этой основе регулярное выражение и запишем его в новый фильтр <b>Fail2ban</b>-а.</p>
			<p class="codes">
				[Definition]</br></br>
				failregex = ^.* client: &lt;HOST&gt;, server: .*$</br></br>
				ignoreregex =
			</p>
			<p>После создания фильтра его обязательно необходимо проверить, т.е. протестировать.</p>
			<p>Синтаксис команды для тестирования выглядит следующим образом:</p>
			<p class="codes">
				<b>$</b> sudo fail2ban-regex &lt;Файл-лога&gt; &lt;Файл-фильтра&gt; &lt;Файл-исключений-из-правил&gt;
			</p>
			<p>Если исключения и правила мы указываем в одном и том же файле, то дважды прописываем путь к нему.</p>
			<p>Например, в первом и втором случае команды тестирования будут выглядить следующим образом.</p>
			<p class="codes">
				<b>$</b> sudo fail2ban-regex /var/log/nginx/access.log /etc/fail2ban/filter.d/nginx-access.conf /etc/fail2ban/filter.d/nginx-access.conf</br>
				<b>$</b> sudo fail2ban-regex /var/log/nginx/error.log /etc/fail2ban/filter.d/nginx-error.conf /etc/fail2ban/filter.d/nginx-error.conf
			</p>
			<p>Если мы всё сделали правильно, на выходе будет <u>примерно</u> следующая информация для <b>&laquo;access.log&raquo;</b>.</p>
			<p class="codes">
				Lines: 437 lines, 0 ignored, 154 matched, 283 missed</br>
				[processed in 0.12 sec]
			</p>
			<p>И для <b>&laquo;error.log&raquo;</b>.</p>
			<p class="codes">
				Lines: 13 lines, 0 ignored, 13 matched, 0 missed</br>
				[processed in 0.00 sec]
			</p>
			<p><u><b>Теперь наш созданный фильтр можно использовать в jail-правилах.</b></u></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.4"></a></p>
			<h3>5.4. Действия.</h3>
			<p>Действия <b>Fail2ban</b>-а имеют гораздо большее применение, чем кажется на первый взгляд.</p>
			<p>Чаще всего, большинство из вас для того, чтобы отслеживать состояние Fail2ban-а - заблокированные адреса скорее всего будут это делать напрямую с помощью скриптов и регулярных выражений, для фильтрации и акцентирования внимания только на самом заблокированном адресе.</p>
			<p>Ничего не имею против такого способа. Однако, обращу ваше внимание на следующее. Со временем вывод команды Fail2ban может измениться. В результате регулярное выражение придётся переписывать. Это один момент.</p>
			<p>Это ни разу не круто!</p>
			<p>Зачем так сильно заморачиваться, если для того же самого результата придуманы так называемы  экшены - <b>action.d</b> действия у <b>Fail2ban</b>-а.</p>
			<p>Вы могли бы сразу начать менять стандартные действия - дописывая в них что-то своё.</p>
			<p>Да, так можно делать, это будет прекрасно работать. Однако, после обновления все ваши старания слетят в круглый ноль и придётся настраивать всё заново.</p>
			<p>Это второй момент.</p>
			<p>Так как же тогда быть? Спросите вы.</p>
			<p>Опять таки, всё гениально и просто - создать собственный  <b>custom action</b>!</p>
			<p>Приведу в пример экшен для своего скрипта, который просто добавляет ip адреса в некий заранее предопределенный файл в json формате. А затем опишу некоторые особенности создания таких экшенов.</p>
			<div class="codeses">
				<pre><span style="color:red;"># Fail2Ban configuration file
#
# Author: Mikhail Artamonov
# Modified by maximalisimus
# 
# /etc/fail2ban/action.d/blacksimple.conf</span>

<span style="color:blue;">[INCLUDES]

after =

before =

[Init]</span>

<span style="color:red;"># Option:  Programs
# Notes.:  A script for working with a blacklist and whitelist.
# Values:  system command
#</span>
<span style="color:blue;">blacklistip = blacklist</span>

<span style="color:red;"># Option: count
# Notes.: The number of locks after which the ip-address 
#         is entered in {IP,IP6,NF}TABLES.
# Values: NUM Default: 3
#</span>
<span style="color:blue;">count = 3</span>

<span style="color:red;"># Option: mask
# Notes.: The network mask.
# Values: NUM Default: 32
#</span>
<span style="color:blue;">mask = 32</span>

<span style="color:red;"># Option: ipv6
# Notes.: Select {IP6/NF}TABLES.
# Values: STRING Default: ""
#</span>
<span style="color:blue;">ipv = ""

[Definition]</span>

<span style="color:red;"># Option:  actionstart
# Notes.:  command executed once at the start of Fail2Ban.
# Values:  CMD
#</span>
<span style="color:blue;">actionstart =</span>

<span style="color:red;"># Option:  actionstop
# Notes.:  command executed once at the end of Fail2Ban
# Values:  CMD
#</span>
<span style="color:blue;">actionstop =</span>

<span style="color:red;"># Option:  actioncheck
# Notes.:  command executed once before each actionban command
# Values:  CMD
#</span>
<span style="color:blue;">actioncheck =</span>

<span style="color:red;"># Option:  actionban
# Notes.:  command executed when banning an IP. Take care that the
#          command is executed with Fail2Ban user rights.
# Tags:    See jail.conf(5) man page
# Values:  CMD
#</span>
<span style="color:blue;">actionban = &lt;blacklistip&gt; -nft &lt;ipv&gt; black -ip &lt;ip&gt; -a -save</span>

<span style="color:red;"># Option:  actionunban
# Notes.:  command executed when unbanning an IP. Take care that the
#          command is executed with Fail2Ban user rights.
# Tags:    See jail.conf(5) man page
# Values:  CMD
#</span>
<span style="color:blue;">actionunban = &lt;blacklistip&gt; -nft &lt;ipv&gt; -c &lt;count&gt; service -start

[Init?family=inet6]</span>

<span style="color:red;"># Option:  ipv6
# Note:    Select {IP6/NF}TABLES.
# Values:  STRING Default: "-ipv6"
#</span>
<span style="color:blue;">ipv = -ipv6</span>

<span style="color:red;"># Option: mask (ipv6)
# Notes.: 
# Values: NUM Default: 128
#</span>
<span style="color:blue;">mask = 128</span></pre>
			</div>
			<p>Первым делом в закоментированных строках необходимо указать авторство и путь сохранения. Это делается не столько для других людей, сколько для вас самих - чтобы вы не запутались в своих же экшенах.</p>
			<p>В секции <b>INCLUDES</b> указываются другие экшены, которые должны быть сюда подключены в качестве стартовых. Если файлов экшенов не существует - ошибки не будет. Обычно в других экшенх <b>Fail2ban</b>-а таким образом указываются пользовательские экшены с расширением <b>&laquo;.local&raquo;</b>. Т.е. вы создали свой экшен и не задумываетесь о том, что он точно будет подключен в какой-нибудь стандартный экшен.</p>
			<p>В секции <b>Init</b> определяют переменные, которые необходимо использовать в вашем экшене, и эти же переменные можно и нужно будет использовать в <b>jail</b> правилах.</p>
			<p>В моём случае указано наименование символической ссылки, которая расположена в <b>&laquo;/usr/bin/&raquo;</b>. Ссылаться такая ссылка может на любую утилиту, любой ваш исполняемый скрипт. Соответственно и расположен может быть где угодно в системе - на ваше усмотрение.</p>
			<p>В принципе здесь можно просто прописать полный путь к вашему исполняемому скрипту. Например, так.</p>
			<p class="codes">
				<span style="color:blue;">[Init]</br></br>
				blacklistip = /etc/myscript-folder/myscrip.sh</span>
			</p>
			<p><u>В принципе всю секцию <b>Init</b> вместе с секцией <b>Init?family=inet6</b> можно вынести в отдельный файл в ту же директорию с другим наименованием файла соответственно и затем просто указать наименование этого файла в секции <b>INCLUDES</b>.</u></p>
			<p>Далее в секции <b>Definition</b> указываются действия при обнаружении особо активного и ретивого ip адреса.</p>
			<p>Насчет состояний: &laquo;actionstart&raquo;, &laquo;actionstop&raquo; и &laquo;actioncheck&raquo; - особо выделить ничего не могу. Однако, вы можете посмотреть в качестве примера в указанной папке <b>action.d</b> 2 файла, чтобы разобраться зачем нужны эти строки. Обратите внимание только на то, что если у вас нет этих действий - оставляйте строку пустой.</p>
			<p>В <b>actionban</b> и <b>actionunban</b> - соответственно указываются действия при блокировании пойманного ip адреса и его разблокировании спустя заданное <b>Fail2ban</b>-ом времени.</p>
			<p>В моём случае помимо добавления ip адреса в некий json файл при блокировке, запускается ещё один процес.</p>
			<p>Секция <b>Init?family=inet6</b> переопределяет нужные вам переменные для протокола <b>IPV6</b>. Т.е. при обнаружении ip адреса с протоколом <b>IPV6</b> - <b>Fail2ban</b> автоматически переопределит нужные вам переменные и сразу же их применит в секции <b>Definition</b> во всех строках исполняемого кода, будь блокировка <b>actionban</b> или разблокировка <b>actionunban</b>, запуск или завершение работы экшена ...</p>
			<p>Обратите внимание ещё на одну вещь - ip адрес указывается угловых одинарных скобках - <b>&lt;ip&gt;</b>.</p>
			<p><u>Самое забавное в том, что дополнительный скрипт использовать в принципе не обязательно. Просто напишите <b>BASH</b> команду в строке <b>actionban</b> вывода адреса в файл, а <b>все остальные строки оставьте пустыми, т.е. после знака равно ничего не надо писать, но строки обязательно должны быть!</b> Этого будет вполне достаточно.</u></p>
			<p>Например, так.</p>
			<p class="codes">
				actionban = &lt;ip&gt; &gt;&gt; /etc/blacklist.txt
			</p>
			<p>В принципе, по большому счету, в секции <b>actionunban</b> можно указать постоянную блокировку всех пойманных ip адресов.</p>
			<p class="codes">
				actionunban = cat /etc/fail2ban/ip.blacklist | while read IP; do iptables -I f2b-&lt;name&gt; 1 -s $IP -j DROP; done
			</p>
			<p>Тогда в секции <b>Init</b> обязательно прописать параметр <b>&lt;name&gt;</b>, также как это сделано в других подключаемых модулях экшенов - <b>&laquo;*-common.conf&raquo;</b> - директории <b>&laquo;/etc/fail2ban/action.d/&raquo;</b>.</p>
			<p class="codes">
				<span style="color:blue;">[Init]</span></br></br>
				<span style="color:red;"># Default name of the chain</br>
				#</span></br>
				<span style="color:blue;">name = default</span>
			</p>
			<p>Ну и соответственно использовать <b>&laquo;name&raquo;</b> в правилах.</p>
			<p><u>Обратите внимание ещё на одну вещь!</u> В данном случае при каждой разблокировке одного какого-нибудь ip адреса - в <b>IPTABLES</b> будут многократно задублированы все пойманные ip адреса, которые записаны в заданный вами файл. <u>Я бы так просто не стал указывать такой параметр при разблокировке ip адресов</u>. Лучше сделать некий скрипт, который будет проверять есть ли такой адрес в <b>IP(6)TABLES</b> и только потом добавлять его туда, если его там нету.</p>
			<p><b>Таким образом вы можете отслеживать ip адреса в Fail2ban-е, без особых усилий и дополнительных скриптов.</b></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.5"></a></p>
			<h3>5.5. Настройка правил.</h3>
			<p>В <b>Debian</b> по умолчанию вместо стандартной настройки есть такой файл: <b>&laquo;/etc/fail2ban/jail.d/defaults-debian.conf&raquo;</b>.</p>
			<p>Обычно в нём заданы настройки SSH-ловушки по умолчанию. Сейчас она не работает. Мы её перезапишем в новой конфигурации: <b>&laquo;/etc/fail2ban/jail.d/ssh.conf&raquo;</b>.</p>
			<p>Не забудьте перед этим создать нужный файл лога и дать ему соответствующие права доступа. Иначе при перезапуске <b>&laquo;fail2ban-сервиса&raquo;</b> получите ошибку.</p>
			<p class="codes">
				$ sudo touch /var/log/sshd.log</br>
				$ sudo chown root:adm /var/log/sshd.log</br>
				$ sudo chmod 640 /var/log/sshd.log
			</p>
			<p><span style="color:red;"><b>Обратите внимание!</b></span> Перед настройкой конфигураций необходимо понимать ещё один важный момент.</p>
			<p>Дело в том, что стандартный <b>&laquo;action=firewallcmd...&raquo;</b>, т.е. через firewald не всегда хорошо отрабатывает. В процессе всесторонней проверке на виртуальной машине выяснилась одна проблема.</p>
			<p>IP-адреса блокирует только один раз. В таблице маршрутизации фаервола адрес, который блокирован находится не по порядку, из-за чего - он по сути <u>не блокируется</u>.</p>
			<p>Исправляет этот момент только перезапуском и фаервола и fail2ban-а. Чтобы такого не происходило - <b>action</b> вполне можно взять другой, пусть даже с <b>iptables</b> - это вполне нормально. У нас нет <i>&laquo;iptables-сервиса&raquo;</i>, а не самого <i>&laquo;iptables&raquo;</i> как такового. Таким образом один бан другому мешать никак не будет. И разбан будет работать так как должен.</p>
			<p>Выходит, что работать на блокировку будут таблицы маршрутизации <i>&laquo;iptables&raquo;</i>, а не <i>&laquo;firewalld&raquo;</i>. Т.е. пакет свободно пройдет через <i>&laquo;firewalld&raquo;</i> и остановится на <i>&laquo;iptables&raquo;</i>. Фаервол и так уже нагружен, поэтому разгрузить его было бы хорошо. К тому же <i>&laquo;iptables&raquo;</i> по сути вообще не нагружен.</p>
			<p>Поэтому в дальнейших конфигурациях я буду комментировать один из <b>action-ов</b>. Таким образом он никак в управлении участвовать не будет. Но останется в качестве напоминания, о том, что такая конфигурация может и не функионировать, но имеет место быть.</p>
			<p>Вообще-то то, что закоментировано как раз и предлагают страницы интернета, не думая, о том, будет ли это нормально работать в комплексе с другими утилитами.</p>
			<p></p>
			<p>Теперь создаем файл конфигурации: <b>&laquo;ssh.conf&raquo;</b>.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/ssh.conf</b><br><br>
				[sshd]</br>
				enabled = true</br>
				port = ssh</br>
				<span style="color:blue;"># action = iptables-ipset[name=sshd, port=ssh, protocol=tcp]</span><br>
				action = firewallcmd-ipset[name=sshd, port=ssh, protocol=tcp]</br>
				logpath = /var/log/sshd.log</br>
				ignoreregex =
			</p>
			<p>* где:</p>
			<ul>
				<li><b>sshd</b> — название для правила;</li>
				<li><b>enabled</b> - позволяет быстро включать (true) или отключать (false) правило;</li>
				<li><b>port</b> — порт целевого сервиса. Принимается буквенное или цифирное обозначение;</li>
				<li><b>action</b> — действие, совершаемое в случае срабатывания правила. В квадратных скобках указаны название для правила, сетевой порт и протокол для блокировки;</li>
				<li><b>logpath</b> - файл лога.</li>
				<li><b>ignoreregex</b> - исключения из правил.</li>
			</ul>
			<p>Самое интересное в том, что в строке <b>logpath</b> вы можете указать несколько файлов логов. Для этого просто перенесите следующий файл на следующую строку пробелами примерно на один уровень с предыдущим логом.</p>
			<p>Например.</p>
			<div class="codeses">
				<pre>logpath = /var/log/nginx/access.log
          /var/log/mylog/access.log</pre>
			</div>
			<p>В строке <b>action</b> правил вы также можете указывать несколько действий по тому же принципу. Приведу полный текст примера правила для <b>SSH</b> правила.</p>
			<div class="codeses">
				<pre>[sshd]
enabled = true
port = ssh
action = firewallcmd-ipset[name=sshd, port=ssh, protocol=tcp]
         blacksimple[count=3]
logpath = /var/log/sshd.log</pre>
			</div>
			<p><u><b>Таким образом вы можете добавлять любые дополнительные действия с ip адресами непосредственно внутри Fail2ban-а и при этом вам не нужные никакие дополнительные сервисы или скрипты с регулярными выражениями.</b></u></p>
			<p>Чтобы изменения вступили в силу, перезапускаем сервис и проверяем.</p>
			<div class="codeses">
				<pre><b>$ sudo systemctl restart fail2ban</b>
<b>$ sudo fail2ban-client restart</b>
<span style="color:blue;"># Этот вариант, в отличие от предыдущего, показывает ошибки при перезапуске, но не перезапускает свой сервис</span>
<b>$ sudo fail2ban-client status</b>
<span style="color:blue;"># Если всё нормально должен показать следующее</span>
Status
|- Number of jail:	1
`- Jail list:	sshd</pre>
			</div>
			<p>Для гарантии, что fail2ban не заблокирут компьютер администратора или другой важный узел, предусмотрена настройка исключений с помощью опции ignoreip. Опция может быть применена как на глобальном уровне (default), так и для конкретного правила.</p>
			<p>Для того, чтобы задать общую настроку, откроем наш файл <b>&laquo;default.conf&raquo;</b>:</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/default.conf</b><br><br>
				[DEFAULT]</br>
				...</br>
				ignoreip = 192.168.0.0/24 95.95.95.95
			</p>
			<p>* в данном примере под фильтры не будут попадать адреса с 192.168.0.1 по 192.168.0.255 и адрес 95.95.95.95.</p>
			<p>Файлы с настройкой действий находятся в каталоге <b>&laquo;/etc/fail2ban/action.d&raquo;</b>. Чтобы блокировать адрес, <b>Fail2ban</b> создает правило в брандмауэре <b>netfilter</b>. Для этого, чаще всего, используются утилиты <b>iptables</b> или <b>firewall-cmd</b>. Последняя применяется в последних версиях <b>CentOS / Red Hat / Fedora</b>. <b>Iptables</b> более универсальная и может использоваться, почти, во всех системах <b>Linux</b>.</p>
			<p>Остановимся на описании выше используемых действиях:</p>
			<ul>
				<li><b>iptables</b> — создание простого правила в netfilter с помощью одноименной утилиты;</li>
				<li><b>iptables-multiport</b> — использование модуля multiports, позволяющий добавлять диапазоны портов для блокировки;</li>
				<li><b>iptables-ipset</b> — использование ipset для придания более лаконичного вида правилам;</li>
				<li><b>iptables-allports</b> — блокирует для адреса все порты;</li>
				<li><b>firewallcmd-new</b> — создание простого правила в netfilter с помощью firewall-cmd;</li>
				<li><b>firewallcmd-ipset</b> — добавляет правила с помощью утилиты firewall-cmd, используя ipset;</li>
				<li><b>firewallcmd-rich-rules</b> — создает rich-rules при помощи firewall-cmd.</li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.6"></a></p>
			<h3>5.6. NGINX DDoS (req limit).</h3>
			<p>Данное правило поможет защитить веб-сервер nginx от DDoS-атак. В некоторых сборках, для данного правило может не оказаться готового фильтра, поэтому в данном примере, мы его создадим вручную.</p>
			<p>Для начала, необходимо настроить NGINX:</p>
			<p class="codes">
				$ sudo nano /etc/nginx/nginx.conf
			</p>
			<p>В раздел http добавим:</p>
			<p class="codes">
				http {</br>
				...</br>
				limit_req_zone $binary_remote_addr zone=one:10m rate=5r/s;</br>
				...</br>
			</p>
			<p>* данная настройка создает зону с интенсивностью запросов в 1 запрос в секунду.</p>
			<p>После настраиваем лимит для конкретного виртуального домена в разделе server - location:</p>
			<p class="codes">
				server {</br>
				...</br>
				location / {</br>
				...</br>
				limit_req zone=one burst=5 nodelay;</br>
				...
			</p>
			<p>* данная настройка вместе с предыдущей зоной, созданной в секции http, позволит лимитировать запросы — 1 запрос в секунду при всплеске 5 запросов.</p>
			<p>Проверяем конфигурационный файл nginx и перезапускаем сервис:</p>
			<p class="codes">
				$ sudo nginx -t</br>
				$ sudo systemctl reload nginx
			</p>
			<p>В лог-файле /var/log/nginx/error.log мы должны увидеть запись на подобие:</p>
			<p class="codes">
				2020/11/16 19:11:08 [error] 1330844#1330844: *16640836 limiting requests, excess: 10.520 by zone "one", client: xxx.xxx.xxx.xxx, server: dmosk.ru, request: "GET / HTTP/1.1", host: "dmosk.ru", referrer: "https://dmosk.ru/page1"
			</p>
			<p>Теперь можно приступать к настройке fail2ban. Создаем фильтр. Вообще в <b>&laquo;Fail2Ban&raquo;</b> уже есть встроенный фильтр для <b>&laquo;Nginx&raquo;</b> и он вполне нормальный, да и отрабатывает вполне неплохо. Но, на всякий случай, вот рабочая конфигурация строк, которые надо изменять.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/filter.d/nginx-limit-req.conf</b></br></br>
				[Definition]</br>
				ngx_limit_req_zones = [^"]+</br>
				failregex = ^\s*\[[a-z]+\] \d+#\d+: \*\d+ limiting requests, excess: [\d\.]+ by zone "(?:%(ngx_limit_req_zones)s)", client: &lt;HOST&gt;,</br>
				ignoreregex =
			</p>
			<p>Создаем правило для fail2ban:</p>
			<p class="codes">
				<b>$ sudo nano /etc/fail2ban/jail.d/nginx-ddos.conf</b></br></br>
				[nginx-ddos]</br>
				enabled = true</br>
				port = http,https</br>
				filter = nginx-limit-req</br>
				action = iptables-multiport[name=nginxddos, port="http,https", protocol=tcp]</br>
				<span style="color:blue;"># action = firewallcmd-multiport[name=nginxddos, port="http,https", protocol=tcp]</span></br>
				logpath = /var/log/nginx/error.log
			</p>
			<p>После настройки не забываем перезапустить fail2ban:</p>
			<p class="codes">
				$ systemctl restart fail2ban
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.7"></a></p>
			<h3>5.7. NGINX files.</h3>
			<p>Настройка <b>upload</b> файлов.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>


http {
	client_max_body_size 100M;
	client_body_buffer_size 256k;
	proxy_max_temp_file_size 0;

...

}</pre>
			</div>
			<p>Эти строки устанавливают максимальный размер тела запроса, размер буфера тела запроса клиента и размер временного файла, создаваемого nginx при передаче данных.</p>
			<p>Более подробно о них написано в <a href="#part5.14"><b>&laquo;Пункте 5.14&raquo;</b>.</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.8"></a></p>
			<h3>5.8. NGINX GZIP.</h3>
			<p>Создайте файл <b>&laquo;site_gzip.conf&raquo;</b> со следующим содержимым</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/site_gzip.conf</b>

gzip on;
gzip_comp_level 5;
gzip_min_length 256;
gzip_proxied    any;
gzip_vary       on;
gzip_types
application/atom+xml
application/javascript
application/json
application/ld+json
application/manifest+json
application/rss+xml
application/vnd.geo+json
application/vnd.ms-fontobject
application/x-font-ttf
application/x-web-app-manifest+json
application/xhtml+xml
application/xml
font/opentype
image/bmp
image/svg+xml
image/x-icon
text/cache-manifest
text/css
text/plain
text/vcard
text/vnd.rim.location.xloc
text/vtt
text/x-component
text/x-cross-domain-policy;
# text/html is always compressed by gzip module</pre>
			</div>
			<p>Теперь подключите этот файл с помощью соответствующей директивы в конфигурации вашего сервиса в самом низу, обязательно в блоке <b>&laquo;server&raquo;</b>.</p>
			<p class="codes">
				# gzip content<br>
				include /etc/nginx/site_gzip.conf;
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.9"></a></p>
			<h3>5.9. NGINX X-XSS-Protection.</h3>
			<p>Заголовок X-XSS-Protection может предотвратить некоторые XSS-атаки.</p>
			<p>Вы можете реализовать защиту XSS, используя три варианта в зависимости от конкретной потребности.</p>
			<ul>
				<li><b>X-XSS-Protection: 0;</b> - олностью отключить фильтр.</li>
				<li><b>X-XSS-Protection: 1;</b> - включить фильтр, но очистить только потенциально вредоносные скрипты.</li>
				<li><b>X-XSS-Protection: 1; mode = block;</b> - ключает фильтр и полностью блокирует страницу.</li>
			</ul>
			<p>Вообще настройка добавляет в блок <b>&laquo;server&raquo;</b>, но в принципе можно и в блок <b>&laquo;http&raquo;</b>.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-XSS-Protection "1; mode=block";

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.10"></a></p>
			<h3>5.10. NGINX X-Frame-Options.</h3>
			<p>Заголовок X-Frame-Options позволяет снизить уязвимость вашего сайта для clickjacking-атак. Этот заголовок служит инструкцией для браузера не загружать вашу страницу в frame/iframe. Не все браузеры поддерживают этот вариант.</p>
			<p>Настроить X-Frame-Options можно тремя способами:</p>
			<ul>
				<li><b>DENY</b> - полностью отключаетт функции iframe.</li>
				<li><b>SAMEORIGIN</b> - iframe может использоваться только кем-то из того же источника.</li>
				<li><b>ALLOW-FROM</b> - позволяет размещать страницы в окнах iframe только с определенных URL-адресов.</li>
			</ul>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Frame-Options "DENY";

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.11"></a></p>
			<h3>5.11. NGINX X-Permitted-Cross-Domain-Policies.</h3>
			<p>Аналогично механизму браузеров блокировки стороннего контента Adobe Flash имеет свой. Он регулируется файлами crossdomain.xml сайта, начиная с корневого каталога. Проблема с механизмом в том, что на любом уровне вложенности корневой регулирующий файл (политика безопасности) может быть переопределен. Чтобы избежать таких ситуаций, необходимо задать этот HTTP-заголовок.</p>
			<p>Доступно несколько вариантов настройки:</p>
			<ul>
				<li><b>none</b> - Никакая политика не допускается.</li>
				<li><b>master-only</b> - Разрешить только главную политику.</li>
				<li><b>all</b> - Все позволено.</li>
				<li><b>by-content-only</b> - Разрешить только определенный тип контента.</li>
				<li><b>by-ftp-only</b> - Применимо только для FTP-сервера.</li>
			</ul>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Permitted-Cross-Domain-Policies master-only;

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.12"></a></p>
			<h3>5.12. NGINX Strict-Transport-Security.</h3>
			<p>Заголовок Strict-Transport-Security запрещает использование незащищенного HTTP соединения на сайте, если есть защищенное HTTPS.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  ...
}</pre>
			</div>
			<p>Лучше включить его в <b>&laquo;/etc/letsencrypt/options-ssl-nginx.conf&raquo;</b>. Ниже этот вариант тоже описан.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.13"></a></p>
			<h3>5.13. NGINX X-Content-Type-Options.</h3>
			<p>Рейтинг наиболее опасных к использованию возможностей браузера возглавляет возможность Internet Explorer «угадывать» тип файла, игнорируя его MIME-тип.</p>
			<p>При передаче от сервера к браузеру все файлы имеют тот или иной тип, который прямо указывает на суть содержимого файла. Однако, Internet Explorer имеет встроенный механизм, который позволяет по-содержимому файла переопределить его тип.</p>
			<p>Таким образом, обычные текстовые файлы могут быть интерпретированы как JavaScript со всеми вытекающими последствиями. Например, если у вас на сайте запрещена загрузка текстовых файлов с расширениями .js пользователями, то они могут загрузить в виде картинок текстовый файл, содержащий JavaScript-код, который может быть исполнен браузером.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
  ...

  add_header X-Content-Type-Options nosniff;

  ...
}</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.14"></a></p>
			<h3>5.14. NGINX SSL.</h3>
			<p><b>SSL 90%</b>.</p>
			<p>Отредактируйте файл вашей конфигурации сервера. Например такой.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/sites-available/example</b>

server {
	...
	listen 443 ssl http2; # Включить http2
    server_name example.com;
    ssl on;
    ssl_stapling_verify on;
	...
}
				</pre>
			</div>
			<p>Теперь отредактируйте файл созданный <b>certbot</b>-ом.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/letsencrypt/options-ssl-nginx.conf</b>
<span style="color:blue;"># HSTS. Лучше включить здесь, а не в http.</span>
<span style="color:blue;">#add_header Strict-Transport-Security "max-age=604800; includeSubDomains" always;</span>
add_header Strict-Transport-Security "max-age=63072000; includeSubdomains;";
<span style="color:blue;">#add_header Strict-Transport-Security "max-age=31536000; includeSubDomains;" preload;</span>

<span style="color:blue;">#ssl_session_cache shared:le_nginx_SSL:10m;</span>
ssl_session_cache shared:SSL:50m;
ssl_session_timeout 1440m;
ssl_session_tickets off;

<span style="color:blue;">#ssl_protocols TLSv1.2 TLSv1.3;</span>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers on;

<span style="color:blue;">#ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:
	ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:
	ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
#ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 
EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !RC4 !aNULL !eNULL !LOW 
	!3DES !MD5 !EXP !PSK !SRP !DSS";
#ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES256-SHA384;
#ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:
	ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:
	DHE-RSA-AES256-GCM-SHA384;</span>
ssl_ciphers TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:
	TLS_AES_128_CCM_8_SHA256:TLS_AES_128_CCM_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:
	ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:
	ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:
	DHE-RSA-AES256-GCM-SHA384;
ssl_ecdh_curve secp384r1;

<span style="color:blue;"># OCSP Stapling</span>
ssl_stapling on;
resolver 8.8.8.8 8.8.4.4 valid=300s;

<span style="color:blue;"># gzip content</span>
include /etc/nginx/site_gzip.conf;

<span style="color:blue;"># Expect CT (Optional)</span>
add_header Expect-CT "max-age=0";</pre>
			</div>
			<p>Наш <b>GZIP</b>, описанный выше, в принципе, можно подключить здесь.</p>
			<p>Здесь, важны все строки, включая <b>&laquo;Expect CT&raquo;</b> и <b>&laquo;OCSP Stapling&raquo;</b>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.15"></a></p>
			<h3>5.15. Nginx Отключение серверных токенов.</h3>
			<p>В обычном режиме сервер будет отображать используемую версию NGINX. Поэтому зллоумышленники будут точно знать уязвимости вашего сервера, т.к. в разных версиях они разные и со временем nginx обновляли и устраняли эти уязвимости.</p>
			<p>Давайте посмотрим на эту информацию, чтобы точно убедиться. У меня же для примера запрос будет к виртуальной машине. Дату я убрал, чтобы она вас не смущала.</p>
			<div class="codeses">
				<pre>
<b>$ curl -I 191.168.0.110</b>

HTTP/1.1 200 OK
Server: nginx/1.18.0
Date: ************************* GMT
Content-Type: text/html
Content-Length: 162
Connection: keep-alive

<span style="color:blue;"># Или, может быть и такой ответ</span>

HTTP/1.1 301 Moved Permanently
Server: nginx/1.18.0
Date: ************************* GMT
Content-Type: text/html
Content-Length: 162
Connection: keep-alive</pre>
			</div>
			<p>Давайте те устраним эту уязвимость. Для этого отредактируем стандартную конфигурацию Nginx.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/nginx/nginx.conf</b>

http {
	server_tokens off;
	...
}

<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>

<span style="color:blue;"># Обязательно проверяем конфигурацию и перезагружаем сервер Nginx</span>
<b>$ sudo nginx -t</b>
<b>$ sudo systemctl restart nginx</b></pre>
			</div>
			<p>Теперь ответ сервера на любой запрос будет такой.</p>
			<div class="codeses">
				<pre>
<b>$ curl -I 191.168.0.110</b>

HTTP/1.1 200 OK
Server: nginx
Date: ************************* GMT
Content-Type: text/html
Content-Length: 162
Connection: keep-alive

<span style="color:blue;"># Или такой</span>

HTTP/1.1 301 Moved Permanently
Server: nginx
Date: ************************* GMT
Content-Type: text/html
Content-Length: 162
Connection: keep-alive</pre>
			</div>
			<p><b>Отлично!</b></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.16"></a></p>
			<h3>5.16. Nginx Задание размеров буферов.</h3>
			<p>Буферы Nginx задают возможность использования оперативной памяти для сохранения представляющей ценность информации. Их размер задается в конфигурационном файле и определяет будет ли использоваться оперативная память или все будет записываться на диск.</p>
			<p>Размер буферов задается в зависимости от количества доступных серверу ресурсов. Если их много значения можно можно увеличивать.</p>
			<p>Размер буферов определяется четырьмя директивами в конфигурационном файле, в секции <b>server</b> либо в <b>http</b>:</p>
			<ol>
				<li><b>&laquo;client_body_buffer_size&raquo;</b></li>
				<li><b>&laquo;client_header_buffer_size&raquo;</b></li>
				<li><b>&laquo;client_max_body_size&raquo;</b></li>
				<li><b>&laquo;large_client_header_buffers&raquo;</b></li>
			</ol>
			<p>Первая директива определяет размер буфера под основное содержимое поступившего от клиента запроса, вторая — размер буфера под заголовок запроса. <b>client_max_body_size</b> — максимальный размер основного содержимого клиентского запроса.</p>
			<p><b>large_client_header_buffers</b> принимает два значения, разделенных пробелами: максимальное числом и размер буферов для чтения большого заголовка запроса клиента.</p>
			<p>Значение размера буфера всегда должно быть меньше <b>client_body_buffer_size</b>, иначе возникнет ошибка <b>414</b> (<b>Request-URI Too Large</b>).</p>
			<p>Также оно должно быть меньше <b>client_header_buffer_size</b>. В противном случае вернется ошибка <b>400</b> (<b>Bad Request</b>).</p>
			<p>В конфигурационном файле для не самого мощного сервера значения буферов могут быть такими.</p>
			<p class="codes">
				client_body_buffer_size 20K;</br>
				client_header_buffer_size 4k;</br>
				client_max_body_size 12m;</br>
				large_client_header_buffers 2 12k;
			</p>
			<p>Менять их стоит если имеют место проблемы с производительностью или возникает одна из упомянутых выше ошибок.</p>
			<p>Задать их можно для каждого виртуального хоста — для каждого сайта (в секции <b>server</b>) или для всего сервера (в секции <b>http</b> - <b>&laquo;/etc/nginx/nginx.conf&raquo;</b>).</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.17"></a></p>
			<h3>5.17. Fail2ban. Работа со списком заблокированных адресов.</h3>
			<p>Получить статистику заблокированных адресов можно следующей командой:</p>
			<p class="codes">
				$ sudo fail2ban-client status <имя правила>
			</p>
			<p>Получить список правил можно командой:</p>
			<p class="codes">
				$ sudo fail2ban-client status
			</p>
			<p>При наличие заблокированных IP-адресов мы увидим, примерно, следующее:</p>
			<p class="codes">
				`- action</br>
				|- Currently banned: 2</br>
				|  `- IP list:       31.207.47.55 10.212.245.29</br>
			</p>
			<p>С помощью iptables:</p>
			<p class="codes">
				$ sudo iptables -L -n --line
			</p>
			<p>С помощью firewall-cmd:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --get-all-rules
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.18"></a></p>
			<h3>5.18. Fail2ban. Примеры правил</h3>
			<p>Настройки <b>Fail2ban</b> - <b>&laquo;/etc/fail2ban/jail.d/default.conf&raquo;</b>, при условии использования <b>Wireguard</b>. Хотя, последнее не обязательно. У вас просто появятся пару новых ip адресов в строке игнора, т.е. белых адресов.</p>
			<p class="codes">
				[DEFAULT]</br>
				maxlines = 4</br>
				maxretry = 5</br>
				findtime = 5m</br>
				bantime = 10m</br>
				action = firewallcmd-ipset</br>
				ignoreip = 127.0.0.1/8 10.10.10.0/24
			</p>
			<p>Конфигурация <b>SSH</b> - <b>&laquo;/etc/fail2ban/jail.d/ssh.conf&raquo;</b>.</p>
			<p class="codes">
				[sshd]</br>
				enabled = true</br>
				port = ssh</br>
				<span style="color:blue;">#action = iptables-ipset[name=sshd, port=ssh, protocol=tcp]</br>
				#action = nftables-allports[name=sshd, protocol=tcp]</span></br>
				action = firewallcmd-ipset[name=sshd, port=ssh, protocol=tcp]</br>
				logpath = /var/log/sshd.log
			</p>
			<p>С помощью знака <b>&laquo;#&raquo;</b> решетки закоментированы не активные настройки. Таким образом я напоминаю о возможных других вариантах запуска. Однако, лучше использовать рекомендованные, раскоментированные, работоспособность которых неоднократно проверена как на виртуальной машине, так и на реальных серверах.</p>
			<p>Настройка <b>Nginx-DDOS</b> - <b>&laquo;/etc/fail2ban/jail.d/nginx-ddos.conf&raquo;</b>.</p>
			<p class="codes">
				[nginx-ddos]
				enabled = true</br>
				port = http,https</br>
				maxretry = 5</br>
				findtime = 10s</br>
				bantime = 10m</br>
				filter = nginx-limit-req</br>
				<span style="color:blue;">#action = firewallcmd-ipset[name=nginxddos, port=ssh, protocol=tcp]</br>
				#action = firewallcmd-multiport[name=nginxddos, port="http,https", protocol=tcp]</span></br>
				action = iptables-multiport[name=nginxddos, port="http,https", protocol=tcp]</br>
				logpath = /var/log/nginx/error.log</br>
				ignoreregex = \.(jpg|jpeg|png|gif|js|css)
			</p>
			<p>Отслеживание доступа в <b>NGINX</b> - <b>&laquo;/etc/fail2ban/jail.d/access-nginx.conf&raquo;</b>, при помощи собственного фильтра.</p>
			<div class="codeses">
				<pre>[anginx]
enabled  = true
port = all
filter = nginx-access
logpath = /var/log/nginx/access.log
          /var/log/myservices/fwg/access.log<span style="color:blue;">
#action = firewallcmd-ipset[name=anginx, port=ssh, protocol=tcp]
#action = firewallcmd-multiport[name=anginx, port="http,https", protocol=tcp]</span>
action = iptables-allports[name=anginx, protocol=all]
ignoreregex = \.(jpg|jpeg|png|gif|js|css)</pre>
			</div>
			<p>Отдельное отслеживание ошибок <b>NGINX</b> - <b>&laquo;/etc/fail2ban/jail.d/error-nginx.conf&raquo;</b>, при помощи собственного фильтра.</p>
			<div class="codeses">
				<pre>[enginx]
enabled  = true
port = all
filter = nginx-error
logpath = /var/log/nginx/error.log<span style="color:blue;">
#action = firewallcmd-ipset[name=enginx, port=ssh, protocol=tcp]
#action = firewallcmd-multiport[name=enginx, port="all", protocol=tcp]</span>
action = iptables-allports[name=enginx, protocol=all]
ignoreregex = \.(jpg|jpeg|png|gif|js|css)</pre>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5.19"></a></p>
			<h3>5.19. Fail2ban. Удаление.</h3>
			<p class="pbold">Средствами fail2ban:</p>
			<p>Для удаление адреса из списка вводим:</p>
			<p class="codes">
				$ sudo fail2ban-client set <имя правила> unbanip <IP-адрес>
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo fail2ban-client set ssh unbanip 31.207.47.55
			</p>
			<p class="pbold">С помощью iptables:</p>
			<p class="codes">
				$ sudo iptables -D <цепочка правил> -s IP-адрес
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo iptables -D fail2ban-ssh -s 10.212.245.29
			</p>
			<p class="pbold">С помощью firewall-cmd:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --permanent --remove-rule <правило>
			</p>
			<p>например:</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --permanent --remove-rule ipv4 filter f2b-sshd 0 -s 188.134.7.221
			</p>
			<p>После необходимо перечитать правила:</p>
			<p class="codes">
				$ sudo firewall-cmd --reload
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part6"></a></p>
			<h2>6. Блокировка ip адреса или всей подсети.</h2>
			<p>С помощью <b>Firewalld</b> это будет выглядеть следующим образом.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --add-rich-rule="rule family='ipv4' source address='192.168.2.0/24' reject"</br>
				$ sudo firewall-cmd --reload</br>
				$ sudo firewall-cmd --list-all
			</p>
			<p>С помощью <b>IPTABLES</b> так.</p>
			<p>При этом у <b>DROP</b> в ответ запрашивающей стороне ничего не будет отправляться, а у <b>REJECT</b> будет автоматически сформирован ответ. Таким образом, если это злоумышленники, то при использовании последнего, т.е. <b>REJECT</b>, они просто будут знать о том, что вы их заблокировали. И тоже самое с блокировкой через <b>Firewalld</b> - лучше использовать <b>DROP</b>, а не <b>REJECT</b>.</p>
			<p><u>Обратите внимание на ключ <b>&laquo;-A&raquo;</b>.</u></p>
			<p class="codes">
				$ sudo iptables -t filter <b>-A</b> INPUT -s 34.124.185.0/24 -j DROP</br>
				$ sudo iptables -t filter <b>-A</b> INPUT -s 45.79.221.110/24 -j REJECT
			</p>
			<p>А вот так будет выглядить разрешающее <b>ACCEPT</b> правило правило.</p>
			<p class="codes">
				$ sudo iptables -t filter <b>-A</b> INPUT -s 192.168.0.110/32 -j ACCEPT
			</p>
			<p>При этом ключ <b>&laquo;-A&raquo;</b> используется для добавления значения в <b>IPTABLES</b>, а ключ <b>&laquo;-D&raquo;</b> удаляет значение из <b>IPTABLES</b>. Т.е. первый <b><u>блокирует</u></b>, второй <b><u>раз</u></b>блокирует.</p>
			<p>Разблокировка тех же адресов будет идентична, за исключением ключа <b>&laquo;-A&raquo;</b>.</p>
			<p class="codes">
				$ sudo iptables -t filter <b>-D</b> INPUT -s 34.124.185.0/24 -j DROP</br>
				$ sudo iptables -t filter <b>-D</b> INPUT -s 45.79.221.110/24 -j REJECT
			</p>
			<p>Соответственно удаление разрешающего <b>ACCEPT</b> правила будет выглядеть так.</p>
			<p class="codes">
				$ sudo iptables -t filter <b>-D</b> INPUT -s 192.168.0.110/32 -j ACCEPT
			</p>
			<p>Блокировать с помощью <b>&laquo;NFTABLES&raquo;</b> немного сложнее, в том плане, что разблокировать придётся уже 2 командами, а не изменением ключа в одной команде.</p>
			<p>Для начала нам нужно определиться с какой таблицей мы вообще работаем, а затем с какой цепочкой. Дело в том, что в <b>&laquo;NFTABLES&raquo;</b> все таблицы и цепочки вы создаете только самостоятельно. Есть стандартные таблицы, но могут отсутствовать стандартные цепочки. Посмотрим на таблицы, которые у нас есть.</p>
			<p class="codes">
				<b>$</b> sudo nft list tables
			</p>
			<p>Стандартно, скорее всего у вас будет таблица <b>&laquo;ip filter&raquo;</b>.</p>
			<p>Теперь посмотрим на цепочки данной таблицы.</p>
			<p class="codes">
				<b>$</b> sudo nft list table ip filter
			</p>
			<p>Видим в ней цепочку <b>&laquo;chain INPUT&raquo;</b>. Если нет, то её придётся создавать. Создаётся цепочка примерно так.</p>
			<p class="codes">
				<b>$</b> sudo nft add chain ip filter INPUT '{ type filter hook input priority 0; policy accept; }'
			</p>
			<p>Теперь можно заблокировать надоедливый адрес, например, некой bootnet-сети.</p>
			<p class="codes">
				<b>$</b> sudo nft 'add rule ip filter INPUT ip saddr 165.22.60.249 counter drop'
			</p>
			<p>А вот так будет выглядеть разрешающиее правило, аналогично разрешающему в <b>IPATBLES</b>.</p>
			<p class="codes">
				<b>$</b> sudo nft 'add rule ip filter INPUT ip saddr 192.168.0.110 counter accept'
			</p>
			<p>Чтобы разблокировать адрес, т.е. удалить его из <b>NFTABLES</b>, необходимо узнать его <b>&laquo;handle&raquo;</b>. Сделать это можно так. Стандартная команда для определения рукопожатия и далее по конвееру небольшая фильтрация для более или менее приличного вида вывода. Все что идет по конвееру можно удалить, т.е. выполнять не обязательно.</p>
			<p class="codes">
				<span style="color:blue;"># Вот так выглядит обычная команда.</span></br>
				<b>$</b> sudo nft --handle --numeric list chain ip filter INPUT</br></br>
				<span style="color:blue;"># А вот так с конвеером.</span></br>
				<b>$</b> sudo nft --handle --numeric list chain ip filter INPUT | grep -Ei "ip saddr|# handle" | sed 's/^[ \t]*//' | awk '!/^$/{print $0}'
			</p>
			<p>В конце каждой строки напротив ip-адреса как раз и будет заветный <b>&laquo;handle&raquo;</b>. Теперь зная его, можно удалить ip-адрес из <b>NFTABLES</b>.</p>
			<p class="codes">
				<b>$</b> sudo nft delete rule ip filter INPUT handle 10
			</p>
			<p>Да, вот так просто удалить по <b>&laquo;handle&raquo;</b>-у.</p>
			<p><b>Учтите!</b> Что после перезагрузки все правила будут сброшены. Чтобы они сохранились их надо сохранить в файл, и загружать при старте системы дополнительным скриптом - примерно как <b>IPATBLES</b>, или отдельным <b>bash</b> скриптом и сервисом <b>systemd</b>.</p>
			<p>Сохраним <b>IPTABLES</b> и посмотрим как восстанавливать внесенные изменения.</p>
			<p class="codes">
				$ sudo iptables-save</br></br>
				$ sudo mkdir /etc/iptables-conf/</br>
				$ sudo iptables-save -f /etc/iptables-conf/iptables_rules.ipv4</br>
				<span style="color:blue;"># Или</span></br>
				$ sudo iptables-save > /etc/iptables-conf/iptables_rules2.ipv4</br></br>
				$ ls -la /etc/iptables-conf/</br></br>
				<span style="color:blue;"># Восстановить</span></br>
				$ sudo iptables-restore -vV /etc/iptables-conf/iptables_rules.ipv4</br>
				$ sudo iptables-restore -nvV /etc/iptables-conf/iptables_rules.ipv4
			</p>
			<p>Применение с перезагрузкой.</p>
			<div class="codeses">
				<pre><b>$ sudo nano /etc/network/if-pre-up.d/iptables</b>

#!/bin/sh
/sbin/iptables-restore &lt; /etc/iptables-conf/iptables_rules.ipv4

<span style="color:blue;"># Сохраняем, выходим</span>
<b><span style="color:blue;">CTRL + o</span></b>
<b><span style="color:blue;">CTRL + x</span></b>
<span style="color:blue;"># Делаем исполняемым</span>
<b>$ sudo chmod +x /etc/network/if-pre-up.d/iptables</b>
<span style="color:blue;"># Загружаем до запуска интерфейсов</span>
<b>$ sudo -t filter iptables -L</b></pre>
			</div>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
		</div>
		<div class="about">
			<p>Copyright &copy; 14.01.2021 by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
