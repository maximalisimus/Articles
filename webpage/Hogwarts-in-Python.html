<html>
<head>
	<meta charset="utf-8">
	<title>Hogwarts in Python</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-favicon.png">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/img.css" type="text/css">
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Hogwarts in Python</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/project-logo-0.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h1>Волшебный Python или как не споткнуться о pathlib.</h1>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Введение</a></li>
				<ol>
					<li><a href="#part1_1">Предисловие</a></li>
					<li><a href="#part1_2">Введение</a></li>
				</ol>
				<li><a href="#part2">Структура &laquo;проекта-примера&raquo;</a></li>
				<li><a href="#part3">Cодержимое файлов &laquo;проекта-примера&raquo;</a></li>
				<ol>
					<li><a href="#part3_1">Пакет: compatible</a></li>
					<li><a href="#part3_2">Под-пакет: subpackage_a</a></li>
					<li><a href="#part3_3">Под-пакет: subpackage_b</a></li>
				</ol>
				<li><a href="#part4">Импорт пакетов</a></li>
				<ol>
					<li><a href="#part4_1">Как работает импорт?</a></li>
					<li><a href="#part4_2">Абсолютные и относительные пути</a></li>
				</ol>
				<li><a href="#part5">Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></a></li>
				<li><a href="#part6">Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</a></li>
				<ol>
					<li><a href="#part6_1">Введение в pathlib.</a></li>
					<li><a href="#part6_2">Гайд по pathlib на реальных примерах.</a></li>
					<ol>
						<li><a href="#part6_2_1">Базовое имя пути</a></li>
						<ol>
							<li><a href="#part6_2_1_1">Имя файла</a></li>
							<li><a href="#part6_2_1_2">Базовые директории</a></li>
						</ol>
						<li><a href="#part6_2_2">Расширение файла</a></li>
						<li><a href="#part6_2_3">Абсолютный и относительные пути</a></li>
						<li><a href="#part6_2_4">Соединение путей</a></li>
						<li><a href="#part6_2_5">Права доступа</a></li>
						<ol>
							<li><a href="#part6_2_5_1">Права доступа (chmod)</a></li>
							<li><a href="#part6_2_5_2">Смена владельца и/или группы (os.chown)</a></li>
							<li><a href="#part6_2_5_3">Смена владельца и/или группы (shutil.chown)</a></li>
						</ol>
						<li><a href="#part6_2_6">Создание файлов и папок</a></li>
						<ol>
							<li><a href="#part6_2_6_1">Чтение и Запись файлов</a></li>
							<li><a href="#part6_2_6_2">Создание файлов и каталогов</a></li>
							<li><a href="#part6_2_6_3">Жесткие и символьные ссылки</a></li>
							<li><a href="#part6_2_6_4">Булевы операции</a></li>
						</ol>
						<li><a href="#part6_2_7">Переименование файлов и папок</a></li>
						<li><a href="#part6_2_8">Перемещение файлов и папок</a></li>
						<li><a href="#part6_2_9">Удаление файлов и папок</a></li>
						<li><a href="#part6_2_10">Cписок файлов и директорий в папке</a></li>
						<li><a href="#part6_2_11">Рекурсивные операции</a></li>
					</ol>
					<li><a href="#part6_3">Вывод</a></li>
				</ol>
				<li><a href="#part7">Задачи с решениями</a></li>
				<ol>
					<li><a href="#part7_1">Задача №1</a></li>
					<li><a href="#part7_2">Задача №2</a></li>
					<li><a href="#part7_3">Задача №3</a></li>
				</ol>
				<li><a href="#part8">Немного <span style="color:Red;">&laquo;unittest&raquo;</span></a></li>
				<li><a href="#part9">О Python в Windows 7, 10 и выше, а также WINE</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h1>1. Введение</h1>
			<p><a name="part1_1"></a></p>
			<h2>1.1. Предисловие.</h2>
			<p>Для всех тестов и примеров для условий наиболее приближенных к реальным я буду использовать виртуальную машину с <b>Debian 10</b>, и 2 мя <b>SHELL</b>-ами: <b>Fish (Default)</b> и <b>Bash</b> и <b>Python 3.10</b>.</p>
			<p><b>Fish</b> используется только для удобства - у него прекрасное автозавершение команд, а также их цветная подсветка.</p>
			<p>Пользователь также использован временный.</p>
			<p>Виртуальное окружение для подобных тестов не требуется.</p>
			<hr class="hr_chapter">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<p><a name="part1_2"></a></p>
			<h2>1.2. Введение.</h2>
			<p>При создании любого <i>python-проекта</i> или одиночного скрипта с кодом мы часто пользуемся импортом, не совсем понимая или не помня, как именно он работает. В связи с чем, иногда могут возникать казусы и непредвиденные ситуации, которые порой сложно решить даже с использованием <i>&laquo;Google&raquo;</i> поиска.</p>
			<p>Сегодня моя задача объяснить почему возникают ошибки импорта пакетов или модулей, а также рассказать сложные темы простыми словами.
			Темы нашего сегодняшнего разговора очень простые, не смотря на то, что кажутся жутко сложными на первый взгляд. Однако, даже не углубляясь глубоко в дебри языка можно легко прийти к выводу - что любая задача решается очень легко.</p>
			<p>Даже если мы не знаем какая библиотека сможет решить ту или иную задачу, мы всегда должны понимать что способов решений может быть много, а может быть ни одного. В любом случае каждый раз вам придётся не только искать то или иное решение, но и искать его самостоятельно. Порою вы сможете найти сразу готовое решение и оно вам подойдет. <b>Однако, так будет не всегда.</b></p>
			<p>В любом случае вам нужно опираться на несколько базовых понятий:</p>
			<ol>
				<li>Какой нужен результат ?</li>
				<li>Решается ли задача, хотя бы на бумаге ?</li>
				<li>Алгоритмизация решения.</li>
			</ol>
			<p><b>Допустим</b>, вы уже решили ту или иную объемную задачу на бумаге, создали не только алгоритм решения, но и создали собственный python-пакет для обработки подобных задач в будущем.</p>
			<p>После этого вам наверняка понадобится протестировать свой пакет не только на ошибки, но и на избыточность кода, а также соблюдение отступов, синтаксиса и многого другого.</p>
			<p>Вы конечно можете создать отдельный файл скрипта, например &laquo;test.py&raquo; в конкретной директории вашего пакета и протестировать модуль или метод модуля отдельно, так сказать, вручную. <b>Однако, это мягко говоря неудобно!</b></p>
			<p>Для каждого модуля вам придётся мучиться не только с отдельными скриптами-тестами, но с импортом своих модулей в этих скриптах. Мало того, эти файлы-тесты будут включены в ваш пакет и мешать вам отлаживать его работу.</p>
			<p>Не говоря уже про попытку теста всего пакета в целом, ведь в этом случае - относительный импорт не работает и вам придется переместить ваш тест-скрипт на директорию выше, а может и вообще перед директорией вашего пакета. И так будет с каждым скриптом-тестом.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.1.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №1" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.2.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №2" />
			</div>
			<p>В результате вам всё-таки придётся создать отдельную директорию для тестирования своего кода, в которой вы и будете хранить все <b>скрипты-тесты</b> вашего кода.</p>
			<p><b><span style="color:Green;">Это как раз правильный подход!</span> Однако, есть нюансы.</b></p>
			<p>Вот тут то и начинается вся магия <b>&laquo;Абры-Кадабры&raquo;</b> с импортом, т.к. в этом случае <span style="color:Red;">относительный импорт - не работает!</span></p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.3.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №3" />
			</div>
			<p>Что же тогда делать и как решить такую задачу?</p>
			<p><span style="color:Green;">Всё решается буквально 1...2 строчками кода </span> <b>-</b> <span style="color:Red;">но их необходимо понимать, чтобы применять правильно.</span></p>
			<p><b>Но - обо всём по порядку!</b></p>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h1>2. Структура &laquo;проекта-примера&raquo;</h1>
			<h2>Общая структура.</h2>
			<p>Для примера пусть будет следующая структура проекта.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-1.png" class="fz__minimized" alt="клик для увеличения" title="Strukture Project" />
			</div>
			<div class="codeses">
				<pre>
.
└── pkg
    ├── compatible
    │   ├── functions.py
    │   ├── __init__.py
    │   ├── subpackage_a
    │   │   ├── a.py
    │   │   └── __init__.py
    │   ├── subpackage_b
    │   │   ├── b.py
    │   │   ├── __init__.py
    │   │   └── test-pathlib-1.py
    │   └── test.py
    ├── test.py
    └── tests
        ├── __init__.py
        ├── test-abs-path.py
        ├── test-pathlib-1.py
        ├── test-pathlib-2.py
        ├── test-pkg-simple.py
        ├── test.py
        └── tmp.txt</pre>
			</div>
			<br>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h1>3. Cодержимое файлов &laquo;проекта-примера&raquo;</h1>
			<p>Определим содержимое всех указанных файлов-проекта. Для примера, пусть будет следующим.</p>
			<p><a name="part3_1"></a></p>
			<h3>3.1 Пакет: compatible</h3>
			<p>Файл: <b>pkg/compatible/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .functions <span style="color:#069;"><b>import *</b></span></br>
				<span style="color:#069;"><b>from</b></span> .subpackage_a <span style="color:#069;"><b>import *</b></span></br>
				<span style="color:#069;"><b>from</b></span> .subpackage_b <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл: <b>pkg/compatible/functions.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getDateTimeStr'</span>]

<span style="color:#069;"><b>from</b></span> datetime <span style="color:#069;"><b>import</b></span> datetime

<span style="color:#069;"><b>def</b></span> getDateTimeStr(strFormat = <span style="color:Blue;">"%d.%m.%Y-%H:%M:%S"</span>) -> <span style="color:#ff1493;">str</span>:
	dateTime = datetime.now()
	outDateTime = dateTime.strftime(strFormat)
	<span style="color:#069;"><b>return</b></span> outDateTime</pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part3_2"></a></p>
			<h3>3.2. Под-пакет: subpackage_a</h3>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .a <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/a.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getPackageA'</span>]

<span style="color:#069;"><b>from</b></span> ..functions <span style="color:#069;"><b>import *</b></span>

<span style="color:#069;"><b>def</b></span> getPackageA():
	<span style="color:#069;"><b>return</b></span> <span style="color:Blue;">'Package A:'</span> + getDateTimeStr()</pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part3_3"></a></p>
			<h3>3.3. Под-пакет: subpackage_b</h3>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .b <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/b.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getPackageB'</span>]

<span style="color:#069;"><b>from</b></span> ..functions <span style="color:#069;"><b>import *</b></span>

<span style="color:#069;"><b>def</b></span> getPackageB():
	<span style="color:#069;"><b>return</b></span> <span style="color:Blue;">'Package B:'</span> + getDateTimeStr()</pre>
			</div>
			<hr class="hr_main">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
		</div>
		<div class="content">
			<p><a name="part4"></a></p>
			<h1>4. Импорт пакетов</h1>
			<p><a name="part4_1"></a></p>
			<h2>4.1. Как работает импорт?</h2>
			<p>При относительном импорте в пакете мы обращаемся к заданному каталогу относительно текущего. Тогда почему при запуске скрипта мы всё равно не можем импортировать пакет или модуль пакета на уровень выше?</p>
			<p><b>Это немного ошибочное мнение.</b></p>
			<p>Дело в том, что модуль внутри пакета - по команде <i>import</i> или <i>from</i> обращается относительно себя. Между модулями или между пакетами такое относительное обращение вполне нормальное явление.</p>
			<p>Например, находясь в одном из подкаталогов пакета <i>compatible</i>: <b>from ..compatible.functions import getDateTimeStr</b></p>
			<p>При простом запуске скрипта, т.е. исполняемого файла, по команде <i>import</i> или <i>from</i> Python ищет пакеты по заданному наименованию в каталогах, которые заданны в <b>sys.path</b>. Относительного импорта при запуске python-скрипта нет. Поэтому при попытке относительного импорта в запускаемом скрипте мы видим различные ошибки.</p>
			<p><span style="color:Red;">Т.е. в запускаемом файле при импорте необходимо указывать именно наименование модуля, в то время как внутри пакета в модулях при импорте необходимо соблюдать относительность путей.</span></p>
			<p>Например: <b>import pathlib</b>, или <b>from pathlib import Path</b>.</p>
			<p>Оказывается, просто, необходимо добавить директорию родителя в данную переменную среды.</p>
			<p><b>Однако, остаётся ещё один вопрос:</b> <span style="color:Blue;">А какой именно каталог необходимо добавить: ../, ./ или абсолютный путь ?</span></p>
			<p>Давайте узнаем всё это на практике.</p>
			<p>Сначала добавим относительный путь и посмотрим - появился ли он в <b>sys.path</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> sys</br>
				sys.path.append(<span style="color:Blue;">'../'</span>)
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.4.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №4" />
			</div>
			<p>Есть.</p>
			<p>Теперь попробуем импортировать наш модуль.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.5.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №5" />
			</div>
			<p>Хм, ошибка. Может неправильно указали относительную директорию? Давайте попробуем с помощью модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.6.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №6" />
			</div>
			<p>Опять ошибка. Может опять относительность импорта указали не верно? Попробуем ещё раз.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.7.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №7" />
			</div>
			<p>Хм, снова ошибка.</p>
			<p><u>Однако, здесь не всё так просто, как показалось на первый взгляд.</u></p>
			<p><b>Давайте разбираться!</b></p>
			<hr class="hr_chapter">
			<p><a href="#part4">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part4_2"></a></p>
			<h2>4.2. Абсолютные и относительные пути.</h2>
			<p>Давайте сначала посмотрим как получить полную директорию из относительной при помощи того же модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-3.png" class="fz__minimized" alt="клик для увеличения" title="Относительные и абсолютные пути" />
			</div>
			<p>Хорошо. С директориями разобрались.</p>
			<p>Есть такая встроенная переменная как &laquo;<b>__file__</b>&raquo;. Она указавает на текущий скрипт.</p>
			<p>Добавим новый путь поиска пакетов и попробуем импортировать наш пакет. Заодно посмотрим на пространстфо имен запускаемого скрипта, а также пространство имен импортируемого модуля. Если всё получится в консоль будут выведены все указанные значения.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>import</b></span> pathlib
<span style="color:#069;"><b>import</b></span> sys

sys.path.append(<span style="color:#ff1493;">str</span>(pathlib.Path(__file__).resolve().parent.parent))

<span style="color:#069;"><b>def</b></span> main():
	<span style="color:#069;"><b>for</b></span> i <span style="color:#069;"><b>in</b></span> sys.path:
		<span style="color:#ff1493;">print</span>(i)
	<span style="color:#069;"><b>import</b></span> compatible
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(sys.modules[__name__]))
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(compatible), <span style="color:Blue;">'\n'</span>)
	<span style="color:#ff1493;">print</span>(compatible.getPackageA())
	<span style="color:#ff1493;">print</span>(compatible.getPackageB())

if __name__ == <span style="color:Blue;">'__main__'</span>:
	main()</pre>
			</div>
			<p>Смотрим на результат.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-7.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.append" />
			</div>
			<p><span style="color:Green;">Ура! Заработало!</span></p>
			<p><span style="color:Brown;">Однако, такой способ добавления не совсем правильный!</span> Однако, вполне рабочий.</p>
			<p>Обратите внимание на то, что необходимый путь поиска добавился в последнюю строку в &laquo;<b>sys.path</b>&raquo;.</p>
			<p>Таким образом, <b>Python</b> сначала переберет все остальные пути поиска, и только в последнюю очередь будет обращаться к вашей заданной директории.</p>
			<p>Лучшим решением, будет - добавление вашей директории на первое место. С этим как раз и поможет метод <b>insert</b>.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>import</b></span> pathlib
<span style="color:#069;"><b>import</b></span> sys

sys.path.insert(<span style="color:Green;">0</span>, <span style="color:#ff1493;">str</span>(pathlib.Path(__file__).resolve().parent.parent))

<span style="color:#069;"><b>def</b></span> main():
	<span style="color:#069;"><b>for</b></span> i <span style="color:#069;"><b>in</b></span> sys.path:
		<span style="color:#ff1493;">print</span>(i)
	<span style="color:#069;"><b>import</b></span> compatible
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(sys.modules[__name__]))
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(compatible), <span style="color:Blue;">'\n'</span>)
	<span style="color:#ff1493;">print</span>(compatible.getPackageA())
	<span style="color:#ff1493;">print</span>(compatible.getPackageB())

if __name__ == <span style="color:Blue;">'__main__'</span>:
	main()
				</pre>
			</div>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-8.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.insert" />
			</div>
			<br>
			<hr class="hr_main">
			<p><a href="#part4">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
		</div>
		<div class="content">
			<p><a name="part5"></a></p>
			<h1>5. Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></h1>
			<p>Не все пары функций/методов ниже эквивалентны. Некоторые из них частично совпадают, некоторые имеют разную семантику. К ним относятся <i>os.path.abspath()</i> и <i>Path.resolve()</i>, <i>os.path.relpath()</i> и <i>Path.relative_to()</i>.</p>
			<p>Функция <i>os.path.abspath()</i> не разрешает символические ссылки, в то время как <i>Path.resolve()</i> это делает.</p>
			<p>Метод <i>Path.relative_to()</i> требует, чтобы путь <i>pathlib.Path</i> был подпутем аргумента, однако, <i>os.path.relpath()</i> этого не требует.</p>
			<p>Подробные примеры использования разберем в следующей главе.</p>
			<table>
				<caption>Эквивалентные функции модулей.</caption>
				<tr>
					<th>Функции модулей os и os.path</th>
					<th>Функции модуля pathlib</th>
				</tr>
				<tr>
					<td>os.path.abspath()</td>
					<td>Path.resolve()</td>
				</tr>
				<tr>
					<td>os.chmod()</td>
					<td>Path.chmod()</td>
				</tr>
				<tr>
					<td>os.mkdir()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.makedirs()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.rename()</td>
					<td>Path.rename()</td>
				</tr>
				<tr>
					<td>os.replace()</td>
					<td>Path.replace()</td>
				</tr>
				<tr>
					<td>os.rmdir()</td>
					<td>Path.rmdir()</td>
				</tr>
				<tr>
					<td>os.remove(), os.unlink()</td>
					<td>Path.unlink()</td>
				</tr>
				<tr>
					<td>os.getcwd()</td>
					<td>Path.cwd()</td>
				</tr>
			    <tr>
			        <td>os.path.exists()</td>
			        <td>Path.exists()</td>
			    </tr>
				<tr>
					<td>os.path.expanduser()</td>
					<td>Path.expanduser() и Path.home()</td>
				</tr>
				<tr>
					<td>os.listdir()</td>
					<td>Path.iterdir()</td>
				</tr>
				<tr>
					<td>os.path.isdir()</td>
					<td>Path.is_dir()</td>
				</tr>
				<tr>
					<td>os.path.isfile()</td>
					<td>Path.is_file()</td>
				</tr>
				<tr>
					<td>os.path.islink()</td>
					<td>Path.is_symlink()</td>
				</tr>
				<tr>
					<td>os.link()</td>
					<td>Path.hardlink_to()</td>
				</tr>
				<tr>
					<td>os.symlink()</td>
					<td>Path.symlink_to()</td>
				</tr>
				<tr>
					<td>os.readlink()</td>
					<td>Path.readlink()</td>
				</tr>
				<tr>
					<td>os.path.relpath()</td>
					<td>Path.relative_to()</td>
				</tr>
				<tr>
					<td>os.stat()</td>
					<td>Path.stat(), Path.owner(), Path.group()</td>
				</tr>
				<tr>
					<td>os.path.isabs()</td>
					<td>PurePath.is_absolute()</td>
				</tr>
				<tr>
					<td>os.path.join()</td>
					<td>PurePath.joinpath()</td>
				</tr>
				<tr>
					<td>os.path.basename()</td>
					<td>PurePath.name</td>
				</tr>
				<tr>
					<td>os.path.dirname()</td>
					<td>PurePath.parent</td>
				</tr>
				<tr>
					<td>os.path.samefile()</td>
					<td>Path.samefile()</td>
				</tr>
				<tr>
					<td>os.path.splitext()</td>
					<td>PurePath.suffix</td>
				</tr>
			</table>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part6"></a></p>
			<h1>6. Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</h1>
			<p><a name="part6_1"></a></p>
			<h2>6.1. Введение в pathlib.</h2>
			<p>Каждая операционная система имеет разные правила построения путей к файлам. Например, Linux использует прямые косые черты для путей, в то время как Windows использует обратную косую черту.</p>
			<p>Это небольшое различие может вызвать проблемы, если вы работаете над проектом и хотите, чтобы другие разработчики из разных операционных систем расширили ваш код.</p>
			<p>К счастью, если вы пишете на Python, модуль Pathlib выполняет тяжелую работу, позволяя вам убедиться, что ваши пути к файлам работают одинаково в разных операционных системах. Кроме того, он предоставляет функциональные возможности и операции, которые помогут вам сэкономить время при обработке и манипулировании путями.</p>
			<p>Откройте файл, например main.py и введите следующее содержимое:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>
				p = pathlib.Path(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(p), <span style="color:Blue;">':'</span>, p)
			</p>
			<p>Сохраните и запустите. У меня вывод получился следующий:</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'pathlib.PosixPath'&#8250; : /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p>Как показано выше, Pathlib создает путь к этому файлу, помещая этот конкретный скрипт в объект Path. Pathlib разделяет пути файловой системы на два разных класса, которые представляют два типа объектов path: чистый путь и конкретный путь.</p>
			<div class="imageClear">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/pathlib-diagram.png" width="512px" />
			</div>
			<p>Чистый путь предоставляет утилиты для обработки и управления вашим путем к файлу без выполнения операций записи, в то время как конкретный путь позволяет вам манипулировать и выполнять операции записи в вашем пути к файлу.</p>
			<p>Другими словами, конкретный путь является подклассом чистого пути. Он наследует манипуляции от родительского класса и добавляет операции ввода / вывода, которые выполняют системные вызовы.</p>
			<p>Чистые пути манипулируют путем к файлу на вашем компьютере, даже если он принадлежит другой операционной системе. Например, допустим, вы работаете в Linux и хотите использовать путь к файлу Windows. Здесь объекты класса PurePath помогут вам заставить путь работать на вашем компьютере с некоторыми базовыми операциями, такими как создание дочерних путей или доступ к отдельным частям пути.</p>
			<p><b>Но чистые пути не смогут имитировать некоторые другие операции, такие как создание каталога или файла, потому что вы на самом деле не в этой операционной системе.</b></p>
			<p>Модифицируем код представленный выше и одной командой получим на выходе прежний str:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>
				p = <span style="color:#ff1493;">str</span>(pathlib.Path(__file__))<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(p), <span style="color:Blue;">':'</span>, p)
			</p>
			<p>Сохраните и запустите:</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p>Как видите преобразовать объекты типа <b>Path</b> в строку не так уж и сложно.</p>
			<hr class="hr_main">
			<p><a href="#part6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2"></a></p>
			<h2>6.2. Гайд по pathlib на реальных примерах.</h2>
			<p>А теперь давайте сравним &laquo;pathlib&raquo; с &laquo;os&raquo; и &laquo;os.path&raquo; на практике на наиболее часто используемых методах.</p>
			<p><a name="part6_2_1"></a></p>
			<h3>6.2.1. Базовое имя пути</h3>
			<p><a name="part6_2_1_1"></a></p>
			<h4>6.2.1.1. Имя файла</h4>
			<p><i>Добавим в вывод дополнительную информацию, чтобы понимать какой объект мы получаем и выводем содержимое на экран.</i></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				names = os.path.basename(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(names), <span style="color:Blue;">':'</span>, names)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : main.py
				</span>
			</p>
			<p><b>А теперь тоже самое в pathlib.</b></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				filename = pathlib.Path('/path/to/somefile.txt').name<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(filename), <span style="color:Blue;">':'</span>, filename)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : somefile.txt
				</span>
			</p>
			<p>Пока неясно какой модуль лучше. Результат у обоих абсолютно одинкавый.</p>
			<p>У библиотеки <b>os</b> не так много методов для работы с путями. Однако, <b>pathlib</b> предоставляет гораздо более широкий спектр возможностей. Рассмотрим несколько других свойств, которые могут помочь в той или иной ситуации.</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_1_1">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_1_2"></a></p>
			<h4>6.2.1.2. Базовые директории</h4>
			<p>Как получить пути к основным директориям системы? Например, к текущей, из которой запущен скрипт и к домашнему каталогу.</p>
			<p>Рассмотрим пример 3 библиотек: <b>os</b>, <b>os.path</b> и <b>pathlib</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> os.path<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>

				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib:'</span>)<br>
				<span style="color:#ff1493;">print</span>(pathlib.Path.cwd())<br>
				<span style="color:#ff1493;">print</span>(pathlib.Path.home())<br>
				<span style="color:#ff1493;">print</span>(pathlib.Path(<span style="color:Blue;">'~/Downloads'</span>).expanduser())<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os and os.path:'</span>)<br><br>

				<span style="color:#ff1493;">print</span>(os.getcwd())<br>
				<span style="color:#ff1493;">print</span>(os.path.expanduser(<span style="color:Blue;">"~"</span>))<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br><span style="color:Blue;">
				pathlib:<br>
				/home/mikl/003/Primer<br>
				/home/mikl<br>
				/home/mikl/Downloads<br>
				os and os.path:<br>
				/home/mikl/003/Primer<br>
				/home/mikl</span>
			</p>
			<p>На самом деле следующие методы чатично работают и в <b>Linux</b>.</p>
			<p><b>PurePath.parts</b> - возвращает кортеж, последовательность сегментов пути, проанализированных на основе значения разделителя пути.</p>
			<p><b>PurePath.drive</b> - возвращает строку, представляющую букву или имя диска, если она есть.</p>
			<p><b>PurePath.root</b> - возвращает строку, представляющую локальный или глобальный корень, если он есть.</p>
			<p><b>PurePath.anchor</b> - возвращает строку, представляющую конкатенацию диска и корня.</p>
			<p><b>PurePath.parent</b> - возвращает строку, представляющую логический родительский путь.</p>
			<p><b>PurePath.name</b> - возвращает строку, представляющую конечный компонент пути, исключая диск и корень, если он есть. Другими словами это имя файла или название последней директории в пути.</p>
			<p><b>PurePath.suffix</b> - возвращает строку, представляющую расширение файла, если он есть.</p>
			<p><b>PurePath.suffixes</b> - возвращает список, представляющий расширения файла, если он есть.</p>
			<p><b>PurePath.stem</b> - возвращает строку, представляющую последний компонент пути без суффикса.</p>
			<p><b>PurePath.as_posix()</b> - возвращает строковое представление пути с косыми чертами '/'.</p>
			<p><b>PurePath.as_uri()</b> - возвращает строку, представляющую путь как file URI. если путь не абсолютен, то поднимается исключение <span style="color:#ff9933;">ValueError</span>.</p>
			<p>Пример использования.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> tar -cvzf ./strukture.txt.tar.gz ./strukture.txt<br>
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>

				p = pathlib.Path(<span style="color:Blue;">'./strukture.txt.tar.gz'</span>).resolve()<br>
				print(p.parts)<br>
				print(p.drive)<br>
				print(p.root)<br>
				print(p.anchor)<br>
				print(p.parent)<br>
				print(p.name)<br>
				print(p.suffix)<br>
				print(p.suffixes)<br>
				print(p.stem)<br>
				print(p.as_posix())<br>
				print(p.as_uri())<br><br>
				<b>mikl ~/003/Primer $</b> wine-cmd<br>
				<b>Z:\home\mikl\003\Primer></b> cmd.bat<br>
				<b>Z:\home\mikl\003\Primer></b> python main.py<br><span style="color:Blue;">
				('Z:\\', 'home', 'mikl', '003', 'Primer', 'strukture.txt.tar.gz')<br>
				Z:<br>
				\<br>
				Z:\<br>
				Z:\home\mikl\003\Primer<br>
				strukture.txt.tar.gz<br>
				.gz<br>
				['.txt', '.tar', '.gz']<br>
				strukture.txt.tar<br>
				Z:/home/mikl/003/Primer/strukture.txt.tar.gz<br>
				file:///Z:/home/mikl/003/Primer/strukture.txt.tar.gz</span>
			</p>
			<p>А вот так выполнение этого же кода выглядит в <b>Linux</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py <br><span style="color:Blue;">
				('/', 'home', 'mikl', '003', 'Primer', 'strukture.txt.tar.gz')<br><br>

				/<br>
				/<br>
				/home/mikl/003/Primer<br>
				strukture.txt.tar.gz<br>
				.gz<br>
				['.txt', '.tar', '.gz']<br>
				strukture.txt.tar<br>
				/home/mikl/003/Primer/strukture.txt.tar.gz<br>
				file:///home/mikl/003/Primer/strukture.txt.tar.gz</span>
			</p>
			<p>Непонятные для вас команды уточняйте в <a href="#part9">пункте-9</a> данной статьи.</p>
			<p>Стоит отдельно выделить метод <b>Path.samefile(other_path)</b>.</p>
			<p>
				Этот метод вернет <i>True</i>, если путь <i>path</i> указывает на тот же файл, что и аргумент <i>other_path</i>, который может быть либо объектом <i>pathlib.Path</i>, либо <i>строкой</i>.<br>
				Семантика похожа на функции <b>os.path.samefile()</b> и <b>os.path.samestat()</b>.
			</p>
			<p>Вот так выглядит использование этого метода.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'cmd.bat'</span>)<br>
				q = Path(<span style="color:Blue;">'strukture.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.samefile(q))<br>
				<span style="color:#ff1493;">print</span>(p.samefile(<span style="color:Blue;">'cmd.bat'</span>))<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">False<br>
				True</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_2"></a></p>
			<h3>6.2.2. Расширение файла</h3>
			<p><b>Получаем расширение файла.</b></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				filename, file_extension = os.path.splitext(<span style="color:Blue;">'/path/to/somefile.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(file_extension), <span style="color:Blue;">':'</span>, file_extension)<br>
				<span style="color:Green;"># pathlib</span><br>
				file_extension = pathlib.Path(<span style="color:Blue;">'/path/to/somefile.txt'</span>).suffix<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(file_extension), <span style="color:Blue;">':'</span>, file_extension)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : .txt<br>
					&#8249;class 'str'&#8250; : .txt
				</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_3"></a></p>
			<h3>6.2.3. Абсолютный и относительные пути</h3>
			<p>А теперь рассмотрим следующие методы библиотек: <b>полный путь, получение родительской директории и соединение путей.</b></p>
			<p><b>Полный путь, т.е. абсолютный путь.</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				realdir = os.path.abspath(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(realdir), realdir)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				pathdir = pathlib.Path(__file__).resolve()<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(pathdir), pathdir)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; /home/mikl/003/Primer/main.py<br>
					&#8249;class 'pathlib.PosixPath'&#8250; /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p><b>Получение родительской директории, например, на 2 уровня вверх.</b> Т.е. наименование директории, в которой находится файл, а также получить директорию на уровень вверх.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				two_up = os.path.dirname(os.path.dirname(__file__))<br>
				<span style="color:#ff1493;">print</span>(two_up)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				two_up = pathlib.Path(__file__).parent.parent<br>
				<span style="color:#ff1493;">print</span>(two_up)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				/home/mikl/003<br>
				/home/mikl/003</span>
			</p>
			<p>В <b>os.path</b> без вложенных вызовов самой библиотеки не бойтись. А вот в <b>pathlib.Path</b> такой последовательный вызов команд вполне нормальное явление.</p>
			<p><span style="color:Green;">Согласитесь - с <b>pathlib</b> код становится красивым, менее громоздким и более читабельным.</span></p>
			<p><b>Канонический путь в os.path</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				src = <span style="color:Blue;">'./pkg/test.py'</span><br>
				dst = <span style="color:Blue;">'./test.py'</span><br>
				<span style="color:Green;"># При наличии имеющейся символической ссылки на файл, необходимо её удалить</span><br>
				<span style="color:Green;"># Чтобы создание символической ссылки не вызывало исключение</span> <span style="color:#ff9933;">FileExistsError</span><br>
				os.remove(dst)<br>
				os.symlink(src, dst)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.symlink:'</span>, os.readlink(dst))<br>
				link = os.path.realpath(dst)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path.realpath:'</span>, link)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				os.symlink: ./pkg/test.py<br>
				os.path.realpath: /home/mikl/003/Primer/pkg/test.py<br></span>
			</p>
			<p><b>Вычисление относительных путей в pathlib</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				shark = pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>, <span style="color:Blue;">"fish"</span>, <span style="color:Blue;">"shark.txt"</span>)<br>
				below_ocean = shark.relative_to(pathlib.Path(<span style="color:Blue;">"ocean"</span>))<br>
				below_animals = shark.relative_to(pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>))<br>
				<span style="color:#ff1493;">print</span>(shark)<br>
				<span style="color:#ff1493;">print</span>(below_ocean)<br>
				<span style="color:#ff1493;">print</span>(below_animals)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				ocean/animals/fish/shark.txt<br>
				animals/fish/shark.txt<br>
				fish/shark.txt<br></span>
			</p>
			<p>Метод relative_to возвращает новый объект Path, относящийся к данному аргументу.</p>
			<p><b>Если relative_to не сможет вычислить ответ, он выдаст ValueError.</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				shark = pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>, <span style="color:Blue;">"fish"</span>, <span style="color:Blue;">"shark.txt"</span>)<br>
				shark.relative_to(pathlib.Path(<span style="color:Blue;">"unrelated"</span>, <span style="color:Blue;">"path"</span>))<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				Traceback (most recent call last):<br>
				  File "/home/mikl/003/Primer/main.py", line 4, in &#8249;module&#8250;<br>
				    shark.relative_to(pathlib.Path("unrelated", "path"))<br>
				  File "/usr/lib/python3.10/pathlib.py", line 816, in relative_to<br>
				    raise ValueError("{!r} is not in the subpath of {!r}"<br>
				<b>ValueError</b>: 'ocean/animals/fish/shark.txt' is not in the subpath of 'unrelated/path' OR one path is relative and the other is absolute.</span>
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-4.2.png" class="fz__minimized" alt="клик для увеличения" title="pathlib.Path().relative_to()" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_4"></a></p>
			<h3>6.2.4. Соединение путей</h3>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				one = os.path.join(<span style="color:Blue;">'home'</span>, <span style="color:Blue;">'User'</span>, <span style="color:Blue;">'Desktop'</span>, <span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path'</span>, one)<br>
				<span style="color:Green;"># os.path для абсолютного пути</span><br>
				asb_one = os.path.abspath(one)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path'</span>, asb_one)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				<span style="color:Green;"># Можно так</span><br>
				two = pathlib.Path(<span style="color:Blue;">'home'</span>, <span style="color:Blue;">'User'</span>, <span style="color:Blue;">'Desktop'</span>, <span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, two)<br>
				<span style="color:Green;"># Можно и так</span><br>
				troyka = pathlib.Path(<span style="color:Blue;">'home'</span>).joinpath(<span style="color:Blue;">'User'</span>).joinpath(<span style="color:Blue;">'Desktop'</span>).joinpath(<span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, troyka)<br>
				<span style="color:Green;"># В pathlib для абсолюнтого пути не требуются вложенные вызовы</span><br>
				four = troyka.resolve()<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, four)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				os.path home/User/Desktop/file.txt<br>
				os.path /home/mikl/003/Primer/home/User/Desktop/file.txt<br>
				pathlib home/User/Desktop/file.txt<br>
				pathlib home/User/Desktop/file.txt<br>
				pathlib /home/mikl/003/Primer/home/User/Desktop/file.txt<br></span>
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-4.png" class="fz__minimized" alt="клик для увеличения" title="Код name, suffix, resolve, joinpath" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-5.png" class="fz__minimized" alt="клик для увеличения" title="Выполнение кода name, suffix, resolve, joinpath" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_5"></a></p>
			<h3>6.2.5. Права доступа</h3>
			<p><a name="part6_2_5_1"></a></p>
			<h4>6.2.5.1. Права доступа (chmod)</h4>
			<p>Представьте себе ситуацию, в которой вам срочно понадобилось програмно создать папку, дать её определённые права доступа, а по окончании работы удалить её. Такое может понадобится при создании некой программы с уникальным шифрованием, или программы с шифрованием <b>GPG</b> для неких целей защиты того или иного доступа. Например, пакет <b>python-gnupg</b> поддерживает такой функционал.</p>
			<p>Прежде, чем мы рассмотрим как раздавать права доступа, давайте посмотрим как их получить, а также как вывести на экран.</p>
			<p>Для преобразования в нормальный и понятный для нас вид воспользуемся библиотекой <b>stat</b>, а именно, методами <b>filemode</b> и <b>S_IMODE</b>.</p>
			<center>
				<table style="width: 750px">
					<caption>Права доступа в команде chmod</caption>
					<tr>
						<th width="250px"><center>Восьмеричное число</center></th>
						<th width="250px"><center>Двоичное число</center></th>
						<th width="250px"><center>Маска доступа</center></th>
					</tr>
					<tbody>
						<tr>
							<td width="250px"><center>0</center></td>
							<td width="250px"><center>000</center></td>
							<td width="250px"><center>---</center></td>
						</tr>
						<tr>
							<td width="250px"><center>1</center></td>
							<td width="250px"><center>001</center></td>
							<td width="250px"><center>--x</center></td>
						</tr>
						<tr>
							<td width="250px"><center>2</center></td>
							<td width="250px"><center>010</center></td>
							<td width="250px"><center>-w-</center></td>
						</tr>
						<tr>
							<td width="250px"><center>3</center></td>
							<td width="250px"><center>011</center></td>
							<td width="250px"><center>-wx</center></td>
						</tr>
						<tr>
							<td width="250px"><center>4</center></td>
							<td width="250px"><center>100</center></td>
							<td width="250px"><center>r--</center></td>
						</tr>
						<tr>
							<td width="250px"><center>5</center></td>
							<td width="250px"><center>101</center></td>
							<td width="250px"><center>r-x</center></td>
						</tr>
						<tr>
							<td width="250px"><center>6</center></td>
							<td width="250px"><center>110</center></td>
							<td width="250px"><center>rw-</center></td>
						</tr>
						<tr>
							<td width="250px"><center>7</center></td>
							<td width="250px"><center>111</center></td>
							<td width="250px"><center>rwx</center></td>
						</tr>
					</tbody>
				</table>
			</center>
			<p>Где восьмеричное число - это:</p>
			<ul>
				<li><b>0</b> - никаких прав</li>
				<li><b>1</b> - только выполнение</li>
				<li><b>2</b> - только запись</li>
				<li><b>3</b> - выполнение и запись</li>
				<li><b>4</b> - только чтение</li>
				<li><b>5</b> - чтение и выполнение</li>
				<li><b>6</b> - чтение и запись</li>
				<li><b>7</b> - чтение запись и выполнение</li>
			</ul>
			<p>Права доступа складываются из 3 категорий:</p>
			<ul>
				<li><b>u</b> - владелец файла</li>
				<li><b>g</b> - группа файла</li>
				<li><b>o</b> - все остальные пользователи</li>
			</ul>
			<p>Например.</p>
			<ul>
				<li><b>u+x</b> - разрешить выполнение для владельца</li>
				<li><b>ugo+x</b> - разрешить выполнение для всех</li>
				<li><b>ug+w</b> - разрешить запись для владельца и группы</li>
				<li><b>o-x</b> - запретить выполнение для остальных пользователей</li>
				<li><b>ugo+rwx</b> - разрешить всё для всех</li>
				<li><b>777</b> - Аналогично, разрешить всё для всех</li>
				<li><b>755</b> - разрешить владельцу всё, а группе и остальным пользователям только читать и выполнять</li>
			</ul>
			<p>Я заранее создал каталог <b>gpgtest</b> и дал ему права <b>700</b> вручную, т.е. полный доступ только владельцу каталога. Дело в том, что утилита <b>GNUPG</b> требует для рабочей директории именно такие права доступа.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-10.png" class="fz__minimized" alt="клик для увеличения" title="Title" />
			</div>
			<p>Посмотрим как получить права доступа при помощи библиотек <b>os</b> и <b>pathlib</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:#069;"><b>from</b></span> stat <span style="color:#069;"><b>import</b></span> S_IMODE, filemode<br>
				<span style="color:Green;"># Pathlib.Path.stat</span><br>
				p = pathlib.Path(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.stat().st_mode, filemode(p.stat().st_mode), <span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br>
				<span style="color:Green;"># os.stat</span><br>
				statinfo = os.stat(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(statinfo.st_mode, filemode(statinfo.st_mode), <span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
				16832 drwx------ 0o700<br>
				16832 drwx------ 0o700</span>
			</p>
			<p><b>Всё работает!</b></p>
			<p>Оставим только <b>pathlib.Path.stat</b>, и <b>oct</b> вывод прав доступа для одного из следующих примеров.</p>
			<p>У нас имеется строка в виде последовательно записанных <b>нуля</b> и английской буквы <b>'o'</b>. Попробуем преобразовать заданные из ввода права доступа в правильный формат и обратно.</p>
			<p>Введём, например 755 и посмотрим что получится.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				mode = <span style="color:Blue;">'0o'</span> + <span style="color:#ff1493;">str</span>(<span style="color:#ff1493;">int</span>(<span style="color:#ff9933;">input</span>(<span style="color:Blue;">'Введите права доступа: '</span>)))<br>
				real_mode = int(mode, 8)<br>
				<span style="color:#ff1493;">print</span>(mode, real_mode, <span style="color:#ff9933;">oct</span>(real_mode))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
				Введите права доступа: 755<br>
				0o755 493 0o755<br></span>
			</p>
			<p>Работает. Попробуем изменить права доступа к каталогу <b>gpgtest</b> и файлу <b>strukture.txt</b> разными библиотеками и посмотрим чем они отличаются.</p>
			<p><b>pathlib.Path.chmod</b>. Поменяем права с <b>700</b> на <b>755</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:#069;"><b>from</b></span> stat <span style="color:#069;"><b>import</b></span> S_IMODE<br><br>
				p = pathlib.Path(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br>
				mode = <span style="color:Blue;">'0o755'</span><br>
				real_mode = int(mode, 8)<br>
				pathlib.Path(p).chmod(real_mode)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
					0o700<br>
					0o755
				</span>
			</p>
			<p>У <b>pathlib</b> есть ещё один метод - <b>Path.lchmod(mode)</b>.</p>
			<p><b>Path.lchmod()</b> не следует символическим ссылкам. Т.е. если путь <b>Path</b> указывает на символическую ссылку, изменяется режим <b>chmod</b> символической ссылки, а не целевого объекта, на который она указывает.</p>
			<p><b>os.chmod</b>. Поменяем права обратно на <b>700</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>from</b></span> stat import S_IMODE<br><br>

				my_dir = <span style="color:Blue;">'./gpgtest'</span><br>
				statinfo = os.stat(my_dir)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br>
				mode = <span style="color:Blue;">'0o700'</span><br>
				real_mode = int(mode, 8)<br>
				os.chmod(my_dir, real_mode)<br>
				<u>statinfo = os.stat(my_dir)</u><br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
					0o755<br>
					0o700
				</span>
			</p>
			<p>
				<b>Обратите внимание на подчеркнутую строку.</b> Для получения статуса в <b>OS</b> необходимо повторно запрашивать права доступа к файлу или папке. В <b>pathlib</b> запрос прав доступа происходит автоматически во время обращения к команде статуса файла или папки.
			</p>
			<p>Можно немного уменьшить количество кода вложенными запросами.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>from</b></span> stat import S_IMODE<br><br>

				my_dir = <span style="color:Blue;">'./gpgtest'</span><br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(os.stat(my_dir).st_mode)))<br>
				mode = <span style="color:Blue;">'0o700'</span><br>
				real_mode = int(mode, 8)<br>
				os.chmod(my_dir, real_mode)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(os.stat(my_dir).st_mode)))
			</p>
			<p><b>Однако, помните, что для библиотеки OS запрашивать права доступа, т.е. обращаться к статусу состояния файла или папки необходимо повторно.</b></p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-6.png" class="fz__minimized" alt="клик для увеличения" title="Status" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_5_2"></a></p>
			<h4>6.2.5.2. Смена владельца и/или группы (os.chown)</h4>
			<p>У <b>pathlib</b> нет методов chown. Поэтому здесь всё-таки придётся использовать библиотеку <b>os</b>.</p>
			<p>Вообще у <b>os</b> есть два метода: <b>os.chown()</b> и <b>os.lchown()</b>.</p>
			<p>Синтаксис у них следующий:</p>
			<ul>
				<li>os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)</li>
				<li>os.lchown(path, uid, gid)</li>
			</ul>
			<p>Параметры означают следующее:</p>
			<ul>
				<li><b>path</b> - <span style="color:#069;">str</span> путь в файловой системе.</li>
				<li><b>uid</b> - <span style="color:#069;">числовой</span> идентификатор пользователя</li>
				<li><b>gid</b> - <span style="color:#069;">числовой</span> идентификатор группы</li>
				<li><b>dir_fd</b> - <span style="color:#069;">дескрипторов каталога</span></li>
				<li><b>follow_symlinks</b> - <span style="color:#069;">bool</span>, переходить ли по ссылкам.</li>
			</ul>
			<p><b>Данный метод не возвращает никаких значений!</b></p>
			<p>Чтобы оставить один из идентификаторов без изменений, установите его на -1.</p>
			<p>Функция <i>os.lchown()</i> эквивалентна вызову функции <i>os.chown()</i> с установленным аргументом <i>follow_symlinks=False</i>, например, <i>os.chown(path, uid, gid, follow_symlinks=False)</i>.</p>
			<p>Аргумент <i>path</i> в обоих функциях можно вставить как <i>pathlib.PurePath</i>.</p>
			<p>Пример использования.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				f = <span style="color:Blue;">'strukture.txt'</span><br>
				os.stat(f).st_gid<br>
				# 1000<br>
				os.stat(f).st_uid<br>
				# 1000<br><br>

				os.chown(f, -1, 1001)<br>
				os.stat(f).st_gid<br>
				# 1001<br>
				os.stat(f).st_uid<br><br>

				<b>mikl ~/003/Primer $</b> sudo python main.py<br>
				<b>[sudo] пароль для mikl:</b><br>
				<span style="color:Blue;">
				985<br>
				1000<br>
				1001<br>
				1000<br></span>
				<b>mikl ~/003/Primer $</b> ls -lha<br>
				<span style="color:Blue;">
				итого 32K<br>
				drwxr-xr-x 3 mikl users 4,0K июл 24 09:12 .<br>
				drwxr-xr-x 3 mikl users  16K июл 22 17:35 ..<br>
				-rw-r--r-- 1 mikl users  234 июл 24 09:12 main.py<br>
				drwxr-xr-x 4 mikl users 4,0K июл 22 00:04 pkg<br>
				-rwxr-xr-x 1 mikl  1001   73 июл 24 00:28 strukture.txt</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_5_3"></a></p>
			<h4>6.2.5.3. Смена владельца и/или группы (shutil.chown)</h4>
			<p>На самом деле это не столько правильный, сколько более понятный метод.</p>
			<p>Синтаксис у него следующий:</p>
			<ul>
				<li>shutil.chown(path, user=None, group=None)</li>
			</ul>
			<p>Где параметры:</p>
			<ul>
				<li><b>path</b> - путь к файлу/каталогу</li>
				<li><b>user</b> - пользователь</li>
				<li><b>group</b> - группа</li>
			</ul>
			<p>Этот метод тоже не возвращает никаких значений.</p>
			<p>Функция <i>chown()</i> модуля <i>shutil</i> меняет владельца пользователя и/или группы по указанному пути.</p>
			<p>Рассмотрим пример.</p>
			<div class="codeses">
				<pre>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> os
<span style="color:#069;"><b>import</b></span> shutil, pathlib
<span style="color:#069;"><b>import</b></span> pwd

username = os.getlogin()
on_uid = pwd.getpwnam(username).pw_uid
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"username: {<span style="color:Black;">username</span>}, uid: {<span style="color:Black;">on_uid</span>}"</span>)

my_dir = <span style="color:Blue;">'test_dir'</span>
on_dir = pathlib.Path(my_dir)
if not on_dir.exists():
	on_dir.mkdir(parents=True, exist_ok=True)
<span style="color:Green;"># пользователь с id 1000 и группа 'games' должны существовать
#  а учетная запись должна иметь право на изменение прав  
# доступа, иначе будет ошибка <span style="color:#ff9933;">'PermissionError'</span></span>

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f" Изменение прав доступа на папку: &#8249;{<span style="color:Black;">on_dir.resolve()</span>}&#8250;,\n \
Папка создана:\n \
	Владелец: {<span style="color:Black;">on_dir.owner()</span>},\n \
	Группа: {<span style="color:Black;">on_dir.group()</span>}"</span>)

shutil.chown(<span style="color:Blue;">'test_dir'</span>, user=on_uid, group=<span style="color:Blue;">'games'</span>)
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f" Папка: &#8249;{<span style="color:Black;">on_dir.resolve()</span>}&#8250;,\n \
Изменение владельца:\n \
	Владелец: '{<span style="color:Black;">on_dir.owner()</span>}',\n \
	Группа: '{<span style="color:Black;">on_dir.group()</span>}'"</span>)

<b>mikl@mikl ~/0/Primer></b> python main.py<span style="color:Blue;">
username: mikl, uid: 1000
 Изменение прав доступа на папку: &#8249;/home/mikl/003/Primer/test_dir&#8250;,
 Папка создана:
 	Владелец: mikl,
 	Группа: users
 Папка: &#8249;/home/mikl/003/Primer/test_dir&#8250;,
 Изменение владельца:
 	Владелец: 'mikl',
 	Группа: 'games'</span></pre>
			</div>
			<p>Здесь, чтобы не искать и не думать о пресловутом <i>id</i> пользователя, мы сначала получаем имя пользователя запустившего терминал, а затем запрашиваем его <i>id</i> (<i>username = os.getlogin()</i> и <i>on_uid = pwd.getpwnam(username).pw_uid</i>). А затем выводим эти значения на экран, с помощью <i>f-строки</i>.</p>
			<p>Далее вводим каталог, который нам необходимо создать. Перед созданием - на всякий случай проверяем - не создан ли он уже. Если нет  - создаем его, включая все вложенные директории.</p>
			<p>Проверяем, точнее перед изменения выводим группу и пользователя этого каталога на экран. И только после этого меняем группу. Владелец остаётся прежним. Потому что при создании директорий владелец будет всегда тот, кто запустил терминал. А мы его запросили в самом начале. <b>Это была не обязательная операция.</b> Просто, чтобы вы знали как это можно сделать.</p>
			<p>Далее строкой <b>shutil.chown</b> меняем группу, и затем выводим изменения на экран, также с помощью <i>f-строки</i>.</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_6"></a></p>
			<h3>6.2.6. Создание файлов и папок</h3>
			<p><a name="part6_2_6_1"></a></p>
			<h4>6.2.6.1. Чтение и Запись файлов</h4>
			<p>Прежде всего необходимо понять, что в библиотеке <b>OS</b> нет команды для создания файла. А в библиотеке <b>pathlib</b> есть.</p>
			<p>При попытке прочитать или записать файла мы всегда путаемся - как правильно это сделать. Первым делом вы скорее всего будете обращаться к команде <b>open</b> - что-то вроде следующего:</p>
			<p class="codes">
				handle = open(<span style="color:Blue;">"test.txt"</span>, <span style="color:Blue;">"r"</span>)<br>
				data = handle.readline() <span style="color:Green;"># read just one line</span><br>
				<span style="color:#ff1493;">print</span>(data)<br>
				handle.close()
			</p>
			<p><b>Обратите внимание!</b></p>
			<p>Дело в том, что при таком обращении в случае возникновения какой-либо ошибки при работе с файлом (ошибка доступа, невозможно открыть файл, нет такого файла и многие другие) вы не сможете закрыть этот файл. Он так и останется висеть в памяти ПК. Try excpet в этом случае хоть и обрабатывают исключения, однако, опять таки не закрывают сам файл.</p>
			<p>Как же правильно это сделать? Через оператор <b>with</b>. Например, так.</p>
			<div class="codeses">
				<pre><span style="color:#069;">with</span> open(<span style="color:Blue;">"strukture.txt"</span>, <span style="color:Blue;">"r"</span>) <span style="color:#069;">as</span> file_handler:
	<span style="color:#069;">for</span> line <span style="color:#069;">in</span> file_handler:
		<span style="color:#ff1493;">print</span>(line)</pre>
			</div>
			<p>Если необходимо сохранить данные в переменную, можно сделать так.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;">with</span> open(<span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">"r"</span>) <span style="color:#069;">as</span> f:
	<span style="color:Green;">#lines = f.readlines()</span>
	lines = f.read()

<span style="color:#ff1493;">print</span>(lines)<span style="color:Green;">
#for item in lines:
#	print(item, end = ' ')</span>
				</pre>
			</div>
			<p><b>Обратите внимание на комментарии!</b> Комментариями отмечен вариант построчного получения данных и соответственно построчный вывод, т.к. в этом случае у вас будет список строк, а не одна большая строка.</p>
			<p>Вот у нас есть комманда: <b>with open ("data.txt", "r") as myfile</b>. А что это за параметр <b>"r"</b>?</p>
			<p>Если не указывать этот параметр, то файл будет открыть только для чтения. Этот параметр указывает на режим доступа к файлу.</p>
			<p>Текстовые файлы можно использовать в следующих режимах:</p>
			<ul>
				<li><b>r</b> - Только для чтения.</li>
				<li><b>w</b> - Только для записи. Создаст новый файл, если не найдет с указанным именем.</li>
				<li><b>rb</b> - Только для чтения (бинарный).</li>
				<li><b>wb</b> - Только для записи (бинарный). Создаст новый файл, если не найдет с указанным именем.</li>
				<li><b>r+</b> - Для чтения и записи.</li>
				<li><b>rb+</b> - Для чтения и записи (бинарный).</li>
				<li><b>w+</b> - Для чтения и записи. Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>wb+</b> - Для чтения и записи (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>a</b> - Откроет для добавления нового содержимого. Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>a+</b> - Откроет для добавления нового содержимого. Создаст новый файл для чтения записи, если не найдет с указанным именем.</li>
				<li><b>ab</b> - Откроет для добавления нового содержимого (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>ab+</b> - Откроет для добавления нового содержимого (бинарный). Создаст новый файл для чтения записи, если не найдет с указанным именем.</li>
			</ul>
			<p>Скорее всего вам понадобится пользоваться только 4 режимами: <b>r</b>, <b>r+</b>, <b>rb</b> и <b>rb+</b>.</p>
			<p>В режимах <b>'w'</b> и <b>wb'</b> происходит перезапись файла. В режимах <b>'w+'</b> и <b>'wb+'</b> файл в любом случае будет перезаписан. Однако, он также ведь открывается и для чтения. Поэтому для того, чтобы хоть что-то прочитать, сначала необходимо хоть что-то в него записать, иначе вы получите на выходе пустые данные!</p>
			<p><b>Необходимо понимать, что в режимах 'w' и 'w+' добавление в файл данных не будет, будет происходить именно перезапись файла! Для добавления необходимо использовать другой режим.</b> Например, <b>'r+'</b>, <b>'a'</b>, <b>'a+'</b>.</p>
			<p>Дело в том, что в режимах <b>'r+'</b> и <b>'a+'</b> вы можете как прочитать данные, так и дозаписать в файл какие-нибудь данные. Необходимо лишь устанавливать курсор в начало или конец файла <b>file.seek()</b>. А вот в режимах без плюса <b>'+'</b> вы можете либо только прочитать данные, либо только записать. Тоже самое, насчет использования плюса, касается всех режимов.</p>
			<p>Во всех режимах добавления данных <b>'a'</b>, с плюсом и без, бинарный или нет - устанавливать курсор <b>file.seek()</b> в конец файла не обязательно. При старте, он сразу автоматически будет находится в конце файла для дозаписи. А вот во всех режимах <b>'r'</b> с плюсом - обязательно контролируйте где находится курсор, ну или принудительно ставьте его в начало или конец файла. Иначе, при записи данных, вы рискуете потерять предыдущие данные.</p>
			<p><b>Чтобы понимать как пользоваться всеми этими режимами, вам необходимо ознакомится ещё с несколькими важными понятиями.</b></p>
			<p>И первое это метод <b>file.seek(offset, whence)</b> и переменная <b>file.tell()</b>.</p>
			<p><b>file.tell()</b> получает текущую позицию указателя чтения/записи файла.</p>
			<p class="codes">
				>>> text = <span style="color:Blue;">'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'</span><br>
				>>> fp = <span style="color:Green;">open</span>(<span style="color:Blue;">'foo.txt'</span>, <span style="color:Blue;">'w+'</span>)<br>
				>>> fp.write(text)<br>
				# 51<br>
				>>> fp.tell()<br>
				# 51<br>
				>>> fp.seek(0)<br>
				# 0<br>
				>>> fp.read(10)<br>
				# 'This is 1s'<br>
				>>> fp.tell()<br>
				# 10<br>
				>>> fp.read(15)<br>
				# 't line\nThis is '<br>
				>>> fp.tell()<br>
				# 25<br>
				>>> fp.close()
			</p>
			<p><b>file.seek</b>(<span style="color:Green;">offset</span>, <span style="color:#069;">whence</span>) перемещает указатель чтения/записи в файле.</p>
			<ul>
				<li><b>offset</b> - смещение указателя чтения/записи файла на <span style="color:#069;">int</span> байтов.</li>
				<li><b>whence</b> - абсолютное позиционирование указателя в формате <span style="color:#069;">int</span>.</li>
			</ul>
			<p>Аргумент <b>whence</b> является необязательным и по умолчанию равен 0.</p>
			<ul>
				<li>0 - смещает указатель на <b>offset</b> относительно начала файла.</li>
				<li>1 - смещает указатель на <b>offset</b> относительно относительно текущей позиции.</li>
				<li>2 - смещает указатель на <b>offset</b> относительно конца файла.</li>
			</ul>
			<p><b>Использование whence имеет одну важную особенность. Значение 1 можно использовать только для бинарных файлов. Также и file.seek() использовать в обычных текстовых (не бинарных) файлах можно только следующими способами:</b></p>
			<ul>
				<li>file.seek(N, 0) - Где N &ge; 0.</li>
				<li>file.seek(0, 2).</li>
			</ul>
			<p>Иначе вы рискуете получить 2 вида исключений: <b><span style="color:#ff9933;">io.UnsupportedOperation</span></b> и <b><span style="color:#ff9933;">ValueError</span></b>.</p>
			<p><b>Ещё несколько важных моментов.</b></p>
			<ul>
				<li>Если файл открыт для добавления с помощью <b>'a'</b> или <b>'a+'</b>, все операции <b>file.seek()</b> будут отменены при следующей записи.</li>
				<li>Если файл открыт только для записи в режиме добавления с использованием <b>'a'</b>, Этот метод по существу используется, но он остается полезным для файлов, открытых в режиме добавления с включенным чтением - режим <b>'a+'</b>.</li>
				<li>Если файл открыт в текстовом режиме с помощью <b>'t'</b>, то допустимы только смещения, возвращаемые функцией <b>file.tell()</b>. Использование других смещений вызывает неопределенное поведение.</li>
			</ul>
			<p class="codes">
				>>> text = b<span style="color:Blue;">'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'</span><br>
				>>> fp = <span style="color:Green;">open</span>(<span style="color:Blue;">'foo.txt'</span>, <span style="color:Blue;">'bw+'</span>)<br>
				>>> fp.write(text)<br>
				# 51<br>
				>>> fp.seek(20, 0)<br>
				# 20<br>
				>>> fp.read(10)<br>
				# b's is 2nd l'<br>
				>>> fp.seek(10, 1)<br>
				# 40<br>
				>>> fp.read(10)<br>
				# b's 3rd line'<br>
				>>> fp.seek(-11, 2)<br>
				# 40<br>
				>>> fp.read(10)<br>
				# b's 3rd line'<br>
				>>> fp.close()
			</p>
			<p>Рассмотрим пример и чтения и дозаписи файла.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
str2 = <span style="color:Blue;">'Многие думают о Lorem Ipsum.\n'</span>
lines = <span style="color:Blue;">''</span>
<span style="color:#069;"><b>with</b></span> open(<span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'r+'</span>) <span style="color:#069;"><b>as</b></span> my_file:
	my_file.seek(0,0) <span style="color:Green;"># курсор может быть и не в начале, на всякий случай</span>
	lines = my_file.read()
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	print(<span style="color:Blue;">'Прочитанная информация:'</span>, lines)
	my_file.seek(0,2)
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	my_file.write(str2)
	my_file.seek(0,0)
	lines = my_file.read()
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	print(<span style="color:Blue;">'Файл был дозаписан:'</span>, lines)
<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">Позиция: 31
Прочитанная информация: It is a long established fact.

Позиция: 31
Позиция: 73
Файл был дозаписан: It is a long established fact.
Многие думают о Lorem Ipsum.</span></pre>
			</div>
			<p><b>Не забывайте, что  в строках, которые вы записываете в файлы, нужны переносы строк. Иначе у вас все строки будут слитыми вместе!</b><br> Ну или можете вручную после каждой записи строки делать ещё одну запись одного переноса.</p>
			<p><b>Чтение и запись файлов средствами pathlib.</b></p>
			<p>Иногда бывает полезно быстро записать и считать некую техническую информацию о тех или иных объектах на английском языке. Для этого и предназначены методы чтения и записи данных данной библиотеки.</p>
			<p>Метод <b>Path.open()</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</p>
			<p>Метод открывает файл, на который указывает путь path, как это делает встроенная функция <span style="color:Blue;">open()</span>.</p>
			<p>В моём файле <b>strukture.txt</b> с прошлых тестов остался некоторый текст. Часть на английском, часть на русском.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

p = Path(<span style="color:Blue;">'strukture.txt'</span>)
<span style="color:#069;"><b>with</b></span> p.open(encoding=<span style="color:Blue;">'utf-8'</span>) <span style="color:#069;"><b>as</b></span> f:
	<span style="color:#ff1493;">print</span>(f.readline())
				</pre>
			</div>
			<p>Обратите внимание на то, что <b>pathlib</b> может некорректно или вообще не читать русский текст. Однако, файл читать будет!</p>
			<p><b>Path.read_bytes()</b> - возвращает содержимое бинарного файла. Файл при этом открывается и тут же закрывается.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>
				p = Path(<span style="color:Blue;">'test_binary_file'</span>)<br>
				p.write_bytes(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_bytes())
			</p>
			<p>Метод <b>Path.read_text</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.read_text(encoding=None, errors=None)</p>
			<p>Возвращает декодированное содержимое файла в виде строки.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>
				p = Path(<span style="color:Blue;">'test_file'</span>)<br>
				p.write_text(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_text())
			</p>
			<p>Метод <b>Path.write_bytes()</b> открывает файл, записывает байтовые данные и тут же закрывает его.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.write_bytes(data)</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test_binary_file'</span>)<br>
				p.write_bytes(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_bytes())
			</p>
			<p>Метод <b>Path.write_text</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.write_text(data, encoding=None, errors=None, newline=None)</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test_file'</span>)<br>
				p.write_text(<span style="color:Blue;">'Text file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_text())
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_6_2"></a></p>
			<h4>6.2.6.2. Создание файлов и каталогов</h4>
			<p><b>Библиотека OS</b></p>
			<p><b>Создание каталогов</b></p>
			<p>Синтаксис команды <b>os.mkdir</b>:</p>
			<p style="margin-left:20px;">os.mkdir(path, mode=0o777, *, dir_fd=None)</p>
			<ul>
				<li><b>path</b> - имя каталога</li>
				<li><b>mode</b> - режимом доступа к каталогу</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Например:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				a = <span style="color:Blue;">'test'</span><br>
				os.mkdir(a, 0o755)<br>
			</p>
			<p><b>При создании нового каталога с помощью os.mkdir() все родительские каталоги должны уже существовать.</b></p>
			<p>создать пустой каталог (папку)</p>
			<div class="codeses">
				<pre>os.mkdir(<span style="color:Blue;">"folder"</span>)<span style="color:Green;">
# повторный запуск mkdir с тем же именем вызывает FileExistsError,
# вместо этого запустите:</span>
<span style="color:#069;"><b>if</b></span> <span style="color:#ff9933;">not</span> os.path.isdir(<span style="color:Blue;">"folder"</span>):
	os.mkdir(<span style="color:Blue;">"folder"</span>)</pre>
			</div>
			<p>Функция <i>os.path.isdir()</i> вернет <i>True</i>, если переданное имя ссылается на существующий каталог.</p>
			<p>Изменение текущего каталога на 'folder'.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				os.chdir(<span style="color:Blue;">"folder"</span>)<br>
				<span style="color:Green;"># вывод текущей папки</span><br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">"Текущая директория изменилась на folder:"</span>, os.getcwd())<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				Текущая директория изменилась на folder: /home/mikl/003/Primer/folder</span>
			</p>		
			<p>Предположим, вы хотите создать не только одну папку, но и несколько вложенных.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> os
<span style="color:Green;"># вернуться в предыдущую директорию</span>
os.chdir(<span style="color:Blue;">".."</span>)<br>
<span style="color:Green;"># сделать несколько вложенных папок</span>
os.makedirs(<span style="color:Blue;">"nested1/nested2/nested3"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<b>mikl ~/003/Primer $</b> ls -lha | grep -Ei nested1
<span style="color:Blue;">drwxr-xr-x 3 mikl users 4,0K июл 24 15:19 nested1</span>
<b>mikl ~/003/Primer $</b> tree ./nested1
<span style="color:Blue;">./nested1
└── nested2
    └── nested3

2 directories, 0 files</span>
				</pre>
			</div>
			<p><b>Библиотека pathlib</b></p>
			<p>Синтаксис команды <b>Path.mkdir</b>:</p>
			<p style="margin-left:20px;">Path.mkdir(mode=0o777, parents=False, exist_ok=False)</p>
			<p>Если указан режим <b>mode</b>, он объединяется со значением <b>umask</b>, для определения режима файла и флагов доступа. Если путь уже существует, вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</p>
			<ul>
				<li><b>parents=True</b> - создание всех отсутствующих подкаталогов, без учета указанного режима <b>mode</b>, имитируя команду <i>POSIX</i> <b>mkdir -p</b>.</li>
				<li><b>parents=False</b> - Отсутствующие каталоги будут вызывать исключение <span style="color:#ff9933;">FileNotFoundError</span>.</li>
				<li><b>exist_ok=False</b> - Если такой каталог уже существует вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</li>
				<li><b>exist_ok=True</b> - исключения <span style="color:#ff9933;">FileExistsError</span> будут игнорироваться, команду <b>mkdir -p</b>, если предложенный путь не является существующим файлом.</li>
			</ul>
			<p>Пример команды <b>Path.mkdir</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'folder1/folder2/folder3'</span>)<br>
				p.mkdir(parents=True)<br>
			</p>
			<p>Синтаксис команды <b>Path.touch</b>:</p>
			<p style="margin-left:20px;">Path.touch(mode=0o666, exist_ok=True)</p>
			<ul>
				<li>Если указан режим <b>mode</b>, он объединяется со значением umask процесса для определения режима файла и флагов доступа.</li>
				<li>Если файл уже существует, функция завершается успешно.</li>
				<li>Если аргумент <b>exist_ok</b> имеет значение <b>True</b>, то его время модификации обновляется до текущего времени, в противном случае вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</li>
			</ul>
			<p>Пример команды <b>Path.touch</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'test.txt'</span>)<br>
				p.touch(mode=0o644)
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_6_3"></a></p>
			<h4>6.2.6.3. Жесткие и символьные ссылки</h4>
			<p>Символьные ссылки <b>os.symlink</b>.</p>
			<p>Синтаксис команды <b>os.symlink</b>:</p>
			<p style="margin-left:20px;">os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)</p>
			<ul>
				<li><b>src</b> - путь в файловой системе на который указывает ссылка</li>
				<li><b>dst</b> - имя ссылки</li>
				<li><b>target_is_directory</b> - в Windows ссылка как каталог</li>
				<li><b>dir_fd</b> - дескрипторов каталогов</li>
			</ul>
			<p>Пример каманды <b>os.symlink</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				src = <span style="color:Blue;">'./strukture.txt'</span><br>
				dst = <span style="color:Blue;">'./test.txt'</span><br>
				os.symlink(src, dst)<br>
				<span style="color:Green;"># Очистим</span><br>
				os.unlink(dst)
			</p>
			<p>Жесткая ссылка <b>os.link</b>.</p>
			<p>Синтаксис команды <b>os.link</b>:</p>
			<p style="margin-left:20px;">os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)</p>
			<ul>
				<li><b>src</b> - путь в файловой системе на который указывает ссылка</li>
				<li><b>dst</b> - имя ссылки</li>
				<li><b>src_dir_fd</b> - дескрипторов каталогов на который указывает ссылка</li>
				<li><b>dst_dir_fd</b> - имя ссылки, дескрипторов каталогов</li>
				<li><b>follow_symlinks</b> - переходить ли по ссылкам</li>
			</ul>
			<p>Пример использования <b>os.link</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				scr = <span style="color:Blue;">'test.txt'</span><br>
				dst = <span style="color:Blue;">'new.txt'</span><br>
				os.link(scr, dst)
			</p>
			<p>Жесткая ссылка <b>pathlib.Path.hardlink_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.hardlink_to(target)</p>
			<ul>
				<li><b>target</b> - путь в файловой системе на который указывает ссылка. При этом путь куда сохранять ссылку вместе с именем ссылки берется из самого <b>Path</b>.</li>
			</ul>
			<p>Пример использования <b>pathlib.Path.hardlink_to</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				<span style="color:Green;"># Путь куда сохранить ссылку + название ссылки</span><br>
				<span style="color:Green;"># Ссылка сохранятеся в текущий каталог</span><br>
				p = Path(<span style="color:Blue;">'mylink'</span>)<br>
				<span style="color:Green;"># То, на что ссылается эта ссылка</span><br>
				p.hardlink_to(<span style="color:Blue;">'./strukture.txt'</span>)
			</p>
			<p>Жесткая ссылка <b>Path.link_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.link_to(target)</p>
			<ul>
				<li><b>target</b> - название и место сохранения ссылки. При этом объект, на который должна ссылаться ссылка берется из самого <b>Path</b>.</li>
			</ul>
			<p>Пример использования команды <b>Path.link_to</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'./strukture.txt'</span>)<br>
				p.link_to(<span style="color:Blue;">'mylink'</span>)
			</p>
			<p>Символьные ссылки <b>Path.symlink_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.symlink_to(target, target_is_directory=False)</p>
			<ul>
				<li><b>target</b> - путь в файловой системе на который указывает ссылка. При этом путь куда сохранять ссылку вместе с именем ссылки берется из самого <b>Path</b>.</li>
			</ul>
			<p><b>В Windows target_is_directory должен быть True (по умолчанию False), если целью ссылки является каталог. В POSIX значение target_is_directory игнорируется.</b></p>
			<p>Пример использования команды:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'./mylink'</span>)<br>
				p.symlink_to(<span style="color:Blue;">'./strukture.txt'</span>)
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_6_4"></a></p>
			<h4>6.2.6.4. Булевы операции</h4>
			<p>Все булевы операции после выполнения возвращает либо <span style="color:Blue;">&laquo;True&raquo;</span>, либо <span style="color:Blue;">&laquo;False&raquo;</span>.</p>
			<p>Булевы операции библиотеки <b>os</b> и <b>os.path</b>:</p>
			<ul>
				<li>os.path.exists(file_path) - проверить существование файла или директории</li>
				<li><b>os.path.isabs(path)</b> - является ли путь абсолютным</li>
				<li><b>os.path.isfile(path)</b> - является ли путь файлом</li>
				<li><b>os.path.isdir(path)</b> - является ли путь директорией</li>
				<li><b>os.path.islink(path)</b> - является ли путь символической ссылкой</li>
				<li><b>os.path.ismount(path)</b> - является ли путь точкой монтирования</li>
			</ul>
			<p>Булевы операции средствами <b>pathlib</b></p>
			<ul>
				<li><b>Path.exists()</b> - проверить существование файла или директории</li>
				<li><b>Path.is_dir()</b> - вернет True, если путь path указывает на каталог, или символическую ссылку.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к директории или символической ссылке, указывающей на директорию.</li>
				<li><b>Path.is_file()</b> - вернет True, если путь path указывает на файл или символическую ссылку, указывающую на обычный файл. Метод вернет False, если путь указывает на файл другого типа.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к файлу или символической ссылке, указывающей на файл.</li>
				<li><b>Path.is_mount()</b> - Метода нет в Windows! Метод Path.is_mount() вернет True, если путь path является точкой монтирования в файловой системе, где смонтирована другая файловая система.<br> В POSIX функция проверяет, находится ли родительский путь path/.. на устройстве, отличном от path или path/.. и path указывают на однy и ту же ноду i-node на одном устройстве - это должно определять точки монтирования для всех вариантов Unix и POSIX.</li>
				<li><b>Path.is_symlink()</b> - вернет True, если путь path указывает на символическую ссылку, иначе вернет False.<br> Значение False также возвращается, если путь path не существует. Метод может вернуть False при отсутствии доступа к символической ссылке.</li>
				<li><b>Path.is_socket()</b> - вернет True, если путь path указывает на сокет Unix или символическую ссылку, указывающую на сокет Unix. Метод вернет False, если путь указывает на файл другого типа.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к сокету Unix или символической ссылке, указывающей на сокет.</li>
				<li><b>Path.is_fifo()</b> - ернет True, если путь path указывает на FIFO или символическую ссылку, указывающую на FIFO. Метод вернет False, если путь указывает на файл другого типа.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к FIFO или символической ссылке, указывающей на FIFO.</li>
				<li><b>Path.is_block_device()</b> - вернет True, если путь path указывает на блочное устройство или символическую ссылку, указывающую на блочное устройство. Метод вернет False, если путь указывает на файл другого типа.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к блочному устройству или символической ссылке, указывающей на блочное устройство.</li>
				<li><b>Path.is_char_device()</b> - вернет True, если путь path указывает на символьное устройство или символическую ссылку, указывающую на символьное устройство. Метод вернет False, если путь указывает на файл другого типа.<br> Значение False также возвращается, если путь не существует или является неработающей символической ссылкой. Метод может вернуть False при отсутствии доступа к символьному устройству или символической ссылке, указывающей на символьное устройство.</li>
			</ul>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_7"></a></p>
			<h3>6.2.7. Переименование файлов и папок</h3>
			<p>Переименование файлов <b>os.rename</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)</p>
			<ul>
				<li><b>src</b> - исходное имя файла или каталога</li>
				<li><b>dst</b> - новое имя файла или каталога</li>
				<li><b>src_dir_fd</b> - исходный дескриптор каталога</li>
				<li><b>dst_dir_fd</b> - новый дескриптор каталога</li>
			</ul>
			<p>В <i>Windows</i>, если <i>dst</i> уже существует, всегда возникает ошибка <span style="color:#ff9933;">FileExistsError</span>.</p>
			<p>Если имя <b>dst</b> уже существует, то операция может завершится с подклассом исключения <span style="color:#ff9933;">OSError</span>.</p>
			<p>В Unix, если <b>src</b> - это файл, а <b>dst</b> - это каталог или наоборот, то поднимаются исключения <span style="color:#ff9933;">IsADirectoryError</span> или <span style="color:#ff9933;">NotADirectoryError</span> соответственно.</p>
			<p>Если оба являются каталогами и <i>dst</i> пуст, то <i>dst</i> будет заменен без уведомления. Если <i>dst</i> является непустым каталогом, возникает <span style="color:#ff9933;">OSError</span>. Если оба являются файлами, то <i>dst</i> будет заменен без уведомления.</p>
			<p>Операция может завершиться с ошибкой на некоторых разновидностях <b>Unix</b>, если <b>src</b> и <b>dst</b> находятся на разных файловых системах.</p>
			<p>Пример использования.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br><br>

				<span style="color:Green;"># Задаём исходный файл и тот, в который хотим переименовать</span><br>
				src, dst = <span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'test.txt'</span><br>
				<span style="color:Green;"># Переименовываем</span><br>
				os.rename(src, dst)<br><br>

				<span style="color:Green;"># Присваиваем исходное имя и будущее переименованное</span><br>
				srcdir, dstdir = <span style="color:Blue;">'src_dir'</span>, <span style="color:Blue;">'dst_dir'</span><br>
				<span style="color:Green;"># Создаем исходный каталог</span><br>
				os.mkdir(srcdir)<br>
				<span style="color:Green;"># Переименовываем</span><br>
				os.rename(srcdir, dstdir)<br>
				<span style="color:Green;"># Удаляем, если не нужен</span><br>
				os.rmdir(dstdir)			
			</p>
			<p>Метод <b>Path.rename</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.rename(target)</p>
			<p>Метод <i>Path.rename()</i> переименует файл или каталог пути <i>path</i> в указанную цель <b>target</b>. Значение <i>target</i> может быть либо строкой, либо другим объектом пути.</p>
			<p>Пример использования. С прошлого примера остался файл <i>test.txt</i>. Переименуем его обратно в <i>strukture.txt</i>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test.txt'</span>)<br>
				p.rename(<span style="color:Blue;">'strukture.txt'</span>)
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_8"></a></p>
			<h3>6.2.8. Перемещение файлов и папок</h3>
			<p>Переименование с перемещение <b>replace</b>.</p>
			<p>Если пути к вашим папкам или файлам которые необходимо переместить находятся на одном уровне - команда работает подобно команде <i>rename</i>. Если между начальным и конечным путем имеются промежуточные директории файл или папка будут помещены именно туда с переименованием в конечное заданное значение. При наличии одинаковых файла с таким же именем, последний будет заменен.</p>
			<p>Переименование с принудительной заменой <b>os.replace</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px;">os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)</p>
			<p>Пример использования:</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>import</b></span> os

src, dst = <span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'folder/test.txt'</span>
<span style="color:#069;"><b>if</b></span> not os.path.exists(<span style="color:Blue;">'folder'</span>):
	<span style="color:Green;"># При отстутствии пути создаём его</span>
	os.mkdir(<span style="color:Blue;">'folder'</span>)
<span style="color:Green;"># Переименовываем и перемещаем</span>
os.replace(src, dst)</pre>
			</div>
			<p>Переименование с принудительной заменой <b>Path.replace</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px;">Path.replace(target)</p>
			<p>Пример использования:</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

src, dst = <span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'folder/test.txt'</span>
<span style="color:#069;"><b>if</b></span> not Path(dst).parent.exists():
	Path(dst).parent.mkdir(parents=True)
p = Path(src)
p.replace(dst)</pre>
			</div>
			<p>Рекурсивно переместить файл или каталог <b>shutil.move</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px;">shutil.move(src, dst, copy_function=copy2)</p>
			<ul>
				<li><b>src</b> - исходное место/путь копируемого файла</li>
				<li><b>dst</b> - место/путь назначения нового файла</li>
				<li><b>copy_function</b> - функция копирования файлов</li>
			</ul>
			<p>Функция возвращает место назначения <b>dst</b>.</p>
			<p>Если место назначения dst находится в текущей файловой системе, тогда используется os.rename(). В противном случае src копируется в dst с помощью функции, переданной в аргумент copy_function, а затем удаляется.</p>
			<p>В случае символических ссылок, новая символическая ссылка, указывающая на цель src будет создана в или как dst и ссылка в src будет удалена.</p>
			<p>Если задана функция copy_function, это должен быть вызываемый объект, который принимает два аргумента src и dst и будет использоваться для копирования src в dest, если функция os.rename() не может быть использована.</p>
			<p>Если источником является каталог, вызывается shutil.copytree(), передавая ему функцию copy_function(). Функция копирования по умолчанию задана как shutil.copy2(). Использование функции shutil.copy() в качестве передаваемой функции copy_function позволяет выполнить перемещение успешно, когда также невозможно скопировать метаданные за счет отсутствия копирования каких-либо метаданных.</p>
			<p>Пример использования</p>
			<div class="codeses">
				<pre><span style="color:#069;"><b>import</b></span> shutil
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

<span style="color:Green;"># Задаём исходную директорию, которую надо переместить и конечную</span>
src, dst = <span style="color:Blue;">'pkg'</span>, <span style="color:Blue;">'folder/pkgs'</span>
<span style="color:#069;"><b>if</b></span> not Path(dst).parent.exists():
	<span style="color:Green;"># При отсутствии родительских директорий конечного пути создаём их</span>
	Path(dst).parent.mkdir(parents=True)
<span style="color:Green;"># Перемещаем с переименованием</span>
shutil.move(src, dst)</pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_9"></a></p>
			<h3>6.2.9. Удаление файлов и папок</h3>
			<p>Удаление символических ссылок <b>os.unlink</b>.</p>
			<p style="margin-left: 20px">os.unlink(path, *, dir_fd = None)</p>
			<ul>
				<li><b>path</b> - путь к ссылке</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Пример использования <b>os.unlink</b>. Создадим ссылку и тут же удалим её.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				scr = <span style="color:Blue;">'test.txt'</span><br>
				dst = <span style="color:Blue;">'new.txt'</span><br>
				<span style="color:Green;"># Создаём ссылку</span><br>
				os.link(scr, dst)<br>
				<span style="color:Green;"># Тут же удаляем эту ссылку</span><br>
				os.unlink(dst)
			</p>
			<p>Удаление файлов или символических ссылок <b>pathlib.Path.unlink</b>.</p>
			<p style="margin-left: 20px">Path.unlink(missing_ok=False) - удаляет файл или символическую ссылку, указанную в пути <i>path</i>. Файл или символическая ссылка должны иметь соответствующее разрешение.</p>
			<ul>
				<li><b>missing_ok</b> - игнорирование ошибок при обнаружении существования пути.</li>
			</ul>
			<p>Если <i>missing_ok</i> = <i>False (по умолчанию)</i> и <u>путь не существует</u>, то вызывается исключение <span style="color:#ff9933;">FileNotFoundError</span>.</p>
			<p>Если <i>missing_ok</i> = <i>True</i>, то исключение <span style="color:#ff9933;">FileNotFoundError</span> будет игнорироваться аналогично команде <b>POSIX rm -f</b>.</p>
			<p>Пример использования <b>Path.unlink</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				<span style="color:Green;"># Путь к ссылке с указанием её имени</span><br>
				p = Path(<span style="color:Blue;">'./mylink'</span>)<br>
				<span style="color:Green;"># Создаём ссылку</span><br>
				p.symlink_to(<span style="color:Blue;">'./strukture.txt'</span>)<br>
				<span style="color:Green;"># И тут же удаляем эту ссылку</span><br>
				p.unlink(missing_ok=True)
			</p>
			<p>Удаление файлов <b>os.remove</b>.</p>
			<p>Синтаксис команды.</p>
			<p style="margin-left: 20px">os.remove(path, *, dir_fd=None)</p>
			<ul>
				<li><b>path</b> - путь к файлу</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Функция remove() модуля os удаляет путь path к файлу. Если путь является каталогом, возникает исключение <span style="color:#ff9933;">IsADirectoryError</span>.</p>
			<p>Пример использования.</p>
			<div class="codeses">
				<pre>
<b>mikl@mikl ~/0/Primer></b> cp strukture.txt strukture-copy.txt
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> os

f = <span style="color:Blue;">'strukture-copy.txt'</span>
<span style="color:#069;"><b>if</b></span> os.path.isfile(f):
	os.remove(f)

<b>mikl@mikl ~/0/Primer></b> python main.py
<b>mikl@mikl ~/0/Primer></b> ls strukture-copy.txt
<span style="color:Blue;">ls: невозможно получить доступ к 'strukture-copy.txt': Нет такого файла или каталога</span></pre>
			</div>
			<p>Работает.</p>
			<p>Удаление каталога <b>os.rmdir</b>.</p>
			<p>Синтаксис команды</p>
			<p style="margin-left: 20px">os.rmdir(path, *, dir_fd=None)</p>
			<ul>
				<li><b>path</b> - путь до каталога</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Если директория <b>path</b> не существует или не является пустым каталогом, соответственно возникает исключение <span style="color:#ff9933;">FileNotFoundError</span> или <span style="color:#ff9933;">OSError</span>.</p>
			<p>Для удаления не пустых директорий, лучше использовать функцию <b>shutil.rmtree()</b>. Но, о ней чуть позже.</p>
			<p>Пример использования.</p>
			<div class="codeses">
				<pre>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> os

path = <span style="color:Blue;">'./pkg2'</span>
os.mkdir(path, 0o777)

<b>mikl@mikl ~/0/Primer></b> python main.py
<b>mikl@mikl ~/0/Primer></b> ls -lha
<span style="color:Blue;">итого 40K
drwxr-xr-x 4 mikl users 4,0K июл 30 12:07 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  107 июл 30 12:07 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
<b>drwxr-xr-x 2 mikl users 4,0K июл 30 12:07 pkg2</b>
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> os

path = <span style="color:Blue;">'./pkg2'</span>
<span style="color:#069;"><b>if</b></span> os.path.isdir(path):
	os.rmdir(path)

<b>mikl@mikl ~/0/Primer></b> python main.py
<b>mikl@mikl ~/0/Primer></b> ls -lha
<span style="color:Blue;">итого 36K
drwxr-xr-x 3 mikl users 4,0K июл 30 12:08 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  125 июл 30 12:08 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span></pre>
			</div>
			<p>Удаление каталога <b>Path.rmdir()</b>.</p>
			<p style="margin-left: 20px;">Метод <b>Path.rmdir()</b> удаляет каталог, указанный в пути <b>path</b>. Каталог должен быть пустым и иметь соответствующие разрешения.</p>
			<p>Пример использования.</p>
			<div class="codeses">
				<pre>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> pathlib

dirs = <span style="color:Blue;">'./pkg2'</span>
p = pathlib.Path(dirs)
p.mkdir(mode=0o755, parents=True, exist_ok=True)

<b>mikl@mikl ~/0/Primer></b> python main.py
<b>mikl@mikl ~/0/Primer></b> ls -lha
<span style="color:Blue;">итого 40K
drwxr-xr-x 4 mikl users 4,0K июл 30 12:14 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  163 июл 30 12:14 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
<b>drwxr-xr-x 2 mikl users 4,0K июл 30 12:14 pkg2</b>
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> pathlib

dirs = <span style="color:Blue;">'./pkg2'</span>
p = pathlib.Path(dirs)
<span style="color:#069;"><b>if</b></span> p.is_dir():
	p.rmdir()

<b>mikl@mikl ~/0/Primer></b> python main.py
<b>mikl@mikl ~/0/Primer></b> ls -lha
<span style="color:Blue;">итого 36K
drwxr-xr-x 3 mikl users 4,0K июл 30 12:17 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  140 июл 30 12:17 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span></pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_10"></a></p>
			<h3>6.2.10. Cписок файлов и директорий в папке</h3>
			<p>Первым будет <b>os.listdir</b>.</p>
			<p>Синтаксис относительно простой.</p>
			<p style="margin-left: 20px;">os.listdir(path=".")</p>
			<ul>
				<li><b>path</b> - путь в виде строки или дескриптор каталога</li>
			</ul>
			<p>Данный метод возвращает список имен файлов в каталоге</p>
			<p>Пример использования.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> os

dirs = <span style="color:Blue;">'.'</span>
output = os.listdir(dirs)
<span style="color:#069;"><b>for</b></span> count, item <span style="color:#069;"><b>in</b></span> <span style="color:Red;">enumerate</span>(output):
	<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"{</span>count+1<span style="color:#ff9933;">} {</span>item<span style="color:#ff9933;">}</span>")
<span style="color:#ff1493;">print</span>(<span style="color:Blue;">''</span>)

dirs = <span style="color:Blue;">'./pkg'</span>
output = os.listdir(dirs)
<span style="color:#069;"><b>for</b></span> count, item <span style="color:#069;"><b>in</b></span> <span style="color:Red;">enumerate</span>(output):
	<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"{</span>count+1<span style="color:#ff9933;">} {</span>item<span style="color:#ff9933;">}</span>")

<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">1 main.py
2 cmd.bat
3 strukture.txt
4 pkg

1 test.py
2 compatible
3 tests</span></pre>
			</div>
			<p>Рассмотрим ещё один метод - <b>os.scandir</b>.</p>
			<p>Функция <b>os.scandir()</b> модуля <b>os</b> возвращает итератор <b>entry_it</b> объектов <b>os.DirEntry</b>, соответствующих записям в каталоге, заданный путем <b>path</b>. Записи приводятся в произвольном порядке, а специальные символы <b>'.'</b> и <b>'..'</b> не включены.</p>
			<p>Использование <i>os.scandir()</i> вместо <i>os.listdir()</i> может значительно повысить производительность кода, который нуждается в информации о типе файла или атрибуте файла, поскольку объекты <i>os.DirEntry</i> предоставляют эту информацию, если операционная система предоставляет ее при сканировании каталога.</p>
			<p>
				Все методы объекта <i>os.DirEntry</i> могут выполнять системный вызов, но для методов <i>os.DirEntry.is_dir()</i> и <i>os.DirEntry.is_file()</i> обычно требуется только системный вызов для символических ссылок. <i>os.DirEntry.stat()</i> всегда требует системного вызова в <i>Unix</i>, в <i>Windows</i> требуется только один системный вызов для символических ссылок.
			</p>
			<p>
				<b>Как только открыли итератор os.scandir() - обязательно его закрывайте - os.scandir.close(), чтобы закрыть итератор и освободить полученные ресурсы.</b>
			</p>
			<p>Для данного оператор можно всопользоваться оператором <b>with</b>, чтобы автоматически его закрыть по окончании работы.</p>
			<p>Синтаксис команды.</p>
			<p style="margin-left: 20px;">os.scandir(path='.')</p>
			<ul>
				<li><b>path</b> - путь к каталогу, может принимать <span style="color:Blue;">str</span> или <span style="color:Blue;">bytes</span></li>
			</ul>
			<p>Попробуем провести операцию аналогичную - <b>os.listdir</b>.</p>
			<dir class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> os

dirs = <span style="color:Blue;">'./'</span>
<span style="color:#069;"><b>with</b></span> os.scandir(dirs) <span style="color:#069;"><b>as</b></span> scan_dir:
	<span style="color:#069;"><b>for</b></span> count, entry <span style="color:#069;"><b>in</b></span> <span style="color:Red;">enumerate</span>(scan_dir):
		<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"{</span>count+1<span style="color:#ff9933;">} {</span>entry.name<span style="color:#ff9933;">}"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">1 main.py
2 cmd.bat
3 strukture.txt
4 pkg</span></pre>
			</dir>
			<p>Повторим результат с помощью <b>Path.iterdir()</b>.</p>
			<p>Метод <b>Path.iterdir()</b> вернет итератор объектов пути содержимого каталога, если путь <b>path</b> указывает на каталог.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> pathlib

dirs = <span style="color:Blue;">'.'</span>
p = pathlib.Path(dirs)
<span style="color:#069;"><b>for</b></span> count, item <span style="color:#069;"><b>in</b></span> <span style="color:Red;">enumerate</span>(p.iterdir()):
	<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"{</span>count+1<span style="color:#ff9933;">} {</span>item.name<span style="color:#ff9933;">}"</span>)

dirs = <span style="color:Blue;">'./pkg'</span>
print(<span style="color:Blue;">''</span>)
p = pathlib.Path(dirs)
<span style="color:#069;"><b>for</b></span> count, item <span style="color:#069;"><b>in</b></span> <span style="color:Red;">enumerate</span>(p.iterdir()):
	<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"{</span>count+1<span style="color:#ff9933;">} {</span>item.name<span style="color:#ff9933;">}"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">1 main.py
2 cmd.bat
3 strukture.txt
4 pkg

1 test.py
2 compatible
3 tests</span></pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_11"></a></p>
			<h3>6.2.11. Рекурсивные операции</h3>
			<p>Такие операции начнём с рекурсивного удаления папки/каталога при помощи <b>shutil.rmtree</b>.</p>
			<p>Синтаксис команды.</p>
			<p style="margin-left: 20px;">shutil.rmtree(path, ignore_errors=False, onerror=None)</p>
			<ul>
				<li><b>path</b> - каталог для удаления</li>
				<li><b>ignore_errors</b> - игнорирование ошибок во время удаления</li>
				<li><b>onerror</b> - обработчик ошибок, возникающих в процессе удаления</li>
			</ul>
			<p>Путь path должен указывать на каталог, но не символическую ссылку на каталог.</p>
			<p>Если <b>ignore_errors=True</b>, то возникшие ошибки в результате неудачного удаления, будут игнорироваться. Если <b>False</b> или пропущено, такие ошибки обрабатываются путем вызова обработчика, указанного в <b>onerror</b> или, если он пропущен, они вызывают исключение.</p>
			<p>Пример удаления директории с правами доступа <i>&laquo;только для чтения&raquo;</i> и использованием <i>pathlib</i>.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> cp -R pkg pkg2
<b>mikl ~/003/Primer $</b> sudo chmod -R 444 ./pkg2
<b>mikl ~/003/Primer $</b> ls -lha
<span style="color:Blue;">итого 40K
drwxr-xr-x 4 mikl users 4,0K июл 30 12:46 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  261 июл 30 12:32 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
<b>dr--r--r-- 4 mikl users 4,0K июл 30 12:46 pkg2</b>
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> pathlib, stat
<span style="color:#069;"><b>import</b></span> shutil

<span style="color:#069;"><b>def</b></span> remove_readonly(func, path, _):
    pathlib.Path(path).cmod(stat.S_IWRITE)
    func(path)

directory = <span style="color:Blue;">'./pkg2'</span>
shutil.rmtree(directory, onerror=remove_readonly)

<b>mikl ~/003/Primer $</b> sudo python main.py
<b>mikl ~/003/Primer $</b> ls -lha
<span style="color:Blue;">итого 36K
drwxr-xr-x 3 mikl users 4,0K июл 30 12:48 .
drwxr-xr-x 3 mikl users  16K июл 25 18:42 ..
-rw-r--r-- 1 mikl users  142 июл 29 18:29 cmd.bat
-rw-r--r-- 1 mikl users  261 июл 30 12:32 main.py
drwxr-xr-x 4 mikl users 4,0K июл 25 23:17 pkg
-rwxr-xr-x 1 mikl users   73 июл 24 00:28 strukture.txt</span></pre>
			</div>
			<p>Функция <b>os.walk</b> - Рекурсивное получение имен файлов в дереве каталогов.</p>
			<p>Синтаксис команды.</p>
			<p style="margin-left: 20px;">os.walk(top, topdown=True, onerror=None, followlinks=False)</p>
			<ul>
				<li><b>top</b> - Верхний каталог для перебора.</li>
				<li><b>topdown</b> - Направление обхода</li>
				<li><b>onerror</b> - функция, которая сообщает об ошибке</li>
				<li><b>followlinks</b> - переходить ли по символическим ссылкам</li>
			</ul>
			<p>Возвращаемые значения: тройной кортеж:</p>
			<ul>
				<li><b>dirpath</b> - путь к каталогу</li>
				<li><b>dirnames</b> - список имен подкаталогов, кроме '.' и '..'</li>
				<li><b>filenames</b> - список имен файлов</li>
			</ul>
			<p><b>Имена в списках не содержат компонентов пути!</b></p>
			<p>
				Чтобы получить полный путь, который начинается с <b>top</b>, необходимо к файлу или каталогу в <b>dirpath</b>, выполнить <b>os.path.join(dirpath, name)</b>.
			</p>
			<p>Пример использования. Раздельно подсчитаем общее количество файлов и общее количество папок которые набрались на данный момент в <b>./pkg</b></p>
			<p>Но сначала проверим а сколько там действительно файлов и папок. И тут есть одно маленькое замечание.</p>
			<p>Вы скорее всего уже по-<b>Googl</b>-лили и нашли несколько примеров с утилитой <b>ls</b>. Это не совсем правильный подход и результаты будут скорее всего ошибочны. Возьмите для примера маленькую вложенную директорию, всмысле с малым числом файлов и папок и посчитайте вручную, а затем предложенным <b>Googl</b>-ом вариантами. Уверен что результаты будут не совпадать.</p>
			<p>Дело в том, что утилита <b>ls</b> смотрит на все файлы без исключений, включая <b>'.'</b> и '..' и многие скрытые файлы и папки. Например у <i>Python</i>-скриптов после выполнения может появлятся директория <b>__pycache__</b> и даже автоматически удаляться.</p>
			<p>Что тогда делать?</p>
			<p>Проблема решается элементарно.</p>
			<p>Воспользуемся конвеером 2 комманд: <b>find</b> и <b>wc</b>.</p> 
			<p>
				<b>Find</b> предназначена для поиска файлов и каталогов на основе специальных условий. Её можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.<br>
				Если грубо - то она пропускает такие вещи как <b>'.'</b> и <b>'..'</b>.<br>
				В ней легко задать критерий пропуска скрытых файлов или скрытых папок.
			</p>
			<p>
				<b>WC</b> - это утитита для подсчета количества строк, слов, символов и байтов.
			</p>
			<p>У <i>find</i> имеется такой параметр как <i>type</i> - тип результатов поиска</p>
			<ul>
				<li><b>f</b> - файлы</li>
				<li><b>d</b>  - директории</li>
			</ul>
			<p>Ещё есть <i>iname</i> - наименование поиска. Однако, мы будем искать все файлы или директории без исключений.</p>
			<p>Команда возвращает путь к полученному объеку.</p>
			<p>У команды <i>wc</i> есть такой параметр как <i>&laquo; l &raquo;</i> - подсчет количества строк.</p>
			<p>Этого будет вполне достаточно.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> <span style="color:Green;"># Подсчитаем количество файлов в этой директории</span><br>
				<b>mikl ~/003/Primer $</b> find ./ -type f | wc -l<br>
				<span style="color:Blue;">23</span><br>
				<b>mikl ~/003/Primer $</b> <span style="color:Green;"># Подсчитаем количество вложенных директорий</span><br>
				<b>mikl ~/003/Primer $</b> find ./ -type d | wc -l<br>
				<span style="color:Blue;">6</span><br>
				<b>mikl ~/003/Primer $</b> <span style="color:Green;"># Включая текущую директорию - действительно +1 директория</span>
			</p>
			<p>А теперь пример <i>Python</i>-скрипта.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> os

dir_count = 0
file_count = 0
on_dir = <span style="color:Blue;">'./'</span>
<span style="color:#069;"><b>for</b></span> root, dirs, files <span style="color:#069;"><b>in</b></span> os.walk(on_dir, topdown=False):
	file_count+=len(files)
	dir_count+=len(dirs)
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"Files count = {</span>file_count<span style="color:#ff9933;">},\nDir count = {</span>dir_count<span style="color:#ff9933;">}"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">Files count = 23,
Dir count = 5</span></pre>
			</div>
			<p><b>Как видите - результаты совпадают.</b></p>
			<p>Либо мы можем тоже самое записать в тернарных операторах.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br><br>

				on_dir = <span style="color:Blue;">'./'</span><br>
				file_count = <span style="color:Red;">sum</span>([len(x) for _, _, x in os.walk(on_dir, topdown=False)])<br>
				dir_count = <span style="color:Red;">sum</span>([len(x) for _, x, _ in os.walk(on_dir, topdown=False)])<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"Files count = {</span>file_count<span style="color:#ff9933;">},\nDir count = {</span>dir_count<span style="color:#ff9933;">}"</span>)
			</p>
			<p><b>А теперь рассмотрим как выглядят рекурсивные операции в pathllib</b>.</p>
			<p>Разница между <b>Path.glob()</b> и <b>Path.rglob()</b> в том, что в первом случае для включения рекурсии необходимо указывать <b>&laquo;**&raquo;</b> 2 звездочки в шаблоне поиска. В то время как в <b>rglob</b> рекурсивный поиск включен по умолчанию. Вообще, рекурсивный поиск по под-каталогам рекомендуется делать именно через <b>rglob</b>, потому как в нём он оптимизирован специально для этой задачи, в то время как через <b>glob</b> такая операция может притормаживать систему.</p>
			<p>Прежде, чем мы рассмотрим <b>Path.glob()</b> и <b>Path.rglob()</b> необходимо пояснить несколько моментов насчет шаблонов поиска, которые можно использовать в этих методах.</p>
			<p><u>Базовые шаблоны для поиска:</u></p>
			<ul>
				<li><b>&laquo; * &raquo;</b> - поиск всех файлов и папок одновременно</li>
				<li><b>&laquo; . &raquo;</b> - поиск только всех каталогов</li>
				<li><b>&laquo; *.* &raquo;</b> - поиск только всех файлов</li>
			</ul>
			<p>Шаблоны поиска могут использовать простые регулярные выражения, как в <b>bash</b>. Однако, не все конструкции могут работать. Применительно только как к наименованиям.</p>
			<p>В папке <b>&laquo;./pkg/&raquo;</b> я создал директорию <b>&laquo;search&raquo;</b> и несколько файлов, а также расположил в одном из под-каталогов <b>.png</b> изображение.</p>
			<p>Примеры работы с данными методами вы можете увидеть в конце этой главы. А сейчас продолжим разговор о шабонах поиска.</p>
			<p>В <b>Path.glob</b> шаблоны поиска могут выглядеть следующим образом.</p>
			<ul>
				<li>Path('pkg/search/').glob('*.py')</li>
				<li>Path('pkg/').rglob('*.png')</li>
				<li>Path('pkg/').rglob('[0-9]*.txt')</li>
				<li>Path('pkg/').rglob('[0-9].txt')</li>
				<li>Path('pkg/').rglob('[0-9]?.txt')</li>
				<li>И многие другие варианты.</li>
			</ul>
			<p>Первый на очереди <b>Path.glob(pattern)</b>.</p>
			<p>Метод <b>Path.glob()</b> возвращает список всех файлов любого типа, соответствующий заданному шаблону <b>pattern</b>, расположенных в каталоге, указанном в пути <b>path</b>.</p>
			<p>Шаблон <b>'**'</b> указывает на рекурсивный обход в глубину каталога, указанного в пути <b>path</b>, и всех его подкаталогов.</p>
			<p>Например найдём все <b>&laquo;.py&raquo;</b>-файлы нешего <b>&laquo;./pkg/tests&raquo;</b> каталога и выведем их на экран. Ну а чтобы не запутаться что где находится, сделаем вывод построчно.</p>
			<p>Для более краткого вывода я вручную удалил несколько скриптов, так что общее количество файлов теперь изменилось.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				paths = list(map(str, sorted(Path(<span style="color:Blue;">'.'</span>).glob(<span style="color:Blue;">'**/*.py'</span>))))<br>
				for x in paths: <span style="color:#ff1493;">print</span>(x)<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">pkg/tests/__init__.py<br>
				pkg/tests/status.py<br>
				pkg/tests/test-abs-path.py<br>
				pkg/tests/test-pathlib-1.py<br>
				pkg/tests/test-pathlib-2.py<br>
				pkg/tests/test.py</span>
			</p>
			<p>Метод <b>Path.rglob(pattern)</b> - работает подобно вызову метода <b>Path.glob()</b> с добавлением конструкции <b>'**/'</b> перед заданным относительным шаблоном <b>pattern</b>, тем самым по умолчанию производит рекурсивный поиск файлов, соответствующего шаблона.</p>
			<p>Т.е. тот же поиск <b>&laquo;.py&raquo;</b> файлов, например в той же директории <b>&laquo;./pkg/tests&raquo;</b> каталога будет выглядеть на пару символов меньше.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				paths = list(map(str, sorted(Path(<span style="color:Blue;">'.'</span>).rglob(<span style="color:Blue;">'*.py'</span>))))<br>
				for x in paths: <span style="color:#ff1493;">print</span>(x)<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">pkg/tests/__init__.py<br>
				pkg/tests/status.py<br>
				pkg/tests/test-abs-path.py<br>
				pkg/tests/test-pathlib-1.py<br>
				pkg/tests/test-pathlib-2.py<br>
				pkg/tests/test.py</span>
			</p>
			<p>А теперь посмотрим как рекурсивно раздельно подсчитать количество файлов и количество папок в заданной директории и сравним с результатом конвеера с <b>find</b> и <b>wc</b>.</p>
			<p>Ниже приведённый пример конструкций тернарных операторов можно значительно упростить. Обычно делают гораздо более простые конструкции или используют <b>list</b> и <b>map</b>.<br> 
			Такие конструкции приведены строго в учебных целях - чтобы показать как ими пользоваться в случае использования внутри списка.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

on_dir = <span style="color:Blue;">'./'</span>
<span style="color:Green;"># Вообще условие положено ставить вместе с else перед циклом, но так тоже будет работать. Однако, else уже нельзя ставить в конце</span>
file_count = sum([1 for x in list(Path(on_dir).rglob(<span style="color:Blue;">'*'</span>)) if x.is_file()])
dir_count = sum([1 for x in list(Path(on_dir).rglob(<span style="color:Blue;">'*'</span>)) if x.is_dir()])
<span style="color:Green;"># Лучше если эти 2 строки будут выглядеть так:</span>
<span style="color:Green;"># file_count = sum([ 1 if x.is_file() else 0 for x in list(Path(on_dir).rglob('*')) ])</span>
<span style="color:Green;"># dir_count = sum([ 1 if x.is_dir() else 0 for x in list(Path(on_dir).rglob('*')) ])</span>
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"Files count = {</span>file_count<span style="color:#ff9933;">},\nDir count = {</span>dir_count<span style="color:#ff9933;">}"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">Files count = 18,
Dir count = 5</span>
<b>mikl ~/003/Primer $</b> find ./ -type f | wc -l
<span style="color:Blue;">18</span>
<b>mikl ~/003/Primer $</b> find ./ -type d | wc -l
<span style="color:Blue;">6</span></pre>
			</div>
			<p>В последней строке количество директорий, включая текущую - поэтому -1. <b>Результаты совпадают.</b></p>
			<p>А вот так можно все эти конструкции тернарных операторов значительно упростить.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				on_dir = <span style="color:Blue;">'./'</span><br>
				file_count = len(list(Path(on_dir).rglob(<span style="color:Blue;">'*.*'</span>)))<br>
				dir_count = len(list(Path(on_dir).rglob(<span style="color:Blue;">'.'</span>)))-1<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"Files count = {</span>file_count<span style="color:#ff9933;">},\nDir count = {</span>dir_count<span style="color:#ff9933;">}"</span>)
			</p>
			<p>
				Результат будет тот же.<br>
				Красиво и коротко. Не правда ли ?<br>
				К сожалению, с <b>os</b> и <b>os.path</b> такой трюк не пройдёт, т.к. там чаще всего возвращаются не списки, а кортежи разной размерности.
			</p>
			<p>А теперь рассмотрим примеры работы с шаблонами поиска <b>Path.glob()</b> и <b>Path.rglob()</b>.</p>
			<p>Структура добавленного <b>search</b> каталога выглядит следующим образом.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> tree ./pkg/search/
<span style="color:Blue;">./pkg/search/
├── 1.txt
├── 22.txt
├── 3a.txt
├── test.py
├── text1.txt
└── text.txt

0 directories, 6 files</span></pre>
			</div>
			<p>Обратите внимание на наименования файлов. Это сделано специально для демонстрации.</p>
			<p>Откроем <b>main.py</b> файл и запишем в него знакомые шаблоны поиска с небольшой модификацией для красивого вывода результата и более быстрой обработки результата поиска.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:Red;">#!/usr/bin/env python3
# -*- coding: utf-8 -*-</span>

<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

paths = list(<span style="color:Red;">map</span>(str, <span style="color:Red;">sorted</span>(Path(<span style="color:Blue;">'pkg/search/'</span>).glob(<span style="color:Blue;">'*.py'</span>))))
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">"Path('pkg/search/').glob('*.py'):"</span>, end=<span style="color:Blue;">' '</span>)
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> paths: <span style="color:#ff1493;">print</span>(x, end=<span style="color:Blue;">' '</span>)

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">"\nPath('pkg/').glob('**/*.png'):"</span>,end=<span style="color:Blue;">' '</span>)

paths = list(<span style="color:Red;">map</span>(str, <span style="color:Red;">sorted</span>(Path(<span style="color:Blue;">'pkg/'</span>).rglob(<span style="color:Blue;">'*.png'</span>))))
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> paths: <span style="color:#ff1493;">print</span>(x, end=<span style="color:Blue;">' '</span>)

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">"\nPath('pkg/').glob('**/[0-9]*.txt'):"</span>, end=<span style="color:Blue;">' '</span>)

paths = list(<span style="color:Red;">map</span>(Path, <span style="color:Red;">sorted</span>(Path(<span style="color:Blue;">'pkg/'</span>).rglob(<span style="color:Blue;">'[0-9]*.txt'</span>))))
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> paths: <span style="color:#ff1493;">print</span>(x.name, end=<span style="color:Blue;">' '</span>)

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">"\nPath('pkg/').rglob('[0-9].txt'):"</span>, end=<span style="color:Blue;">' '</span>)

paths = list(<span style="color:Red;">map</span>(Path, <span style="color:Red;">sorted</span>(Path(<span style="color:Blue;">'pkg/'</span>).rglob(<span style="color:Blue;">'[0-9].txt'</span>))))
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> paths: <span style="color:#ff1493;">print</span>(x.name, end=<span style="color:Blue;">' '</span>)

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">"\nPath('pkg/').rglob('[0-9]?.txt'):"</span>, end=<span style="color:Blue;">' '</span>)

paths = list(<span style="color:Red;">map</span>(Path, <span style="color:Red;">sorted</span>(Path(<span style="color:Blue;">'pkg/'</span>).rglob(<span style="color:Blue;">'[0-9]?.txt'</span>))))
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> paths: <span style="color:#ff1493;">print</span>(x.name, end=<span style="color:Blue;">' '</span>)

<span style="color:#ff1493;">print</span>(<span style="color:Blue;">''</span>)
				</pre>
			</div>
			<p>После запуска изменённого <b>main.py</b> файла мы увидим следующий результат.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">Path('pkg/search/').glob('*.py'): pkg/search/test.py<br>
				Path('pkg/').glob('**/*.png'): pkg/compatible/py-imports-logo.png<br>
				Path('pkg/').glob('**/[0-9]*.txt'): 1.txt 22.txt 3a.txt<br>
				Path('pkg/').rglob('[0-9].txt'): 1.txt<br>
				Path('pkg/').rglob('[0-9]?.txt'): 22.txt 3a.txt</span>
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-16.png" class="fz__minimized" alt="клик для увеличения" title="Path.glob() и Path.rglob()" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr class="hr_main">
			<p><a name="part6_3"></a></p>
			<h2>6.3. Вывод.</h2>
			<p>Исходя из приведенных сравнений библиотек - мы получаем, что <b>pathlib</b> объединяет в себе часто используемые функции двух стандартных модулей <b>os</b> и <b>os.path</b>, а так же стандартную функцию <b>open()</b> для чтения и записи файлов. Этот модуль гораздо компактнее, быстрее и эффективнее, а главное в нём значительно больше различных методов и операций над файлами и папками. Использовать его намного легче, чем модули <b>os</b> и <b>os.path</b>. Последовательное выполнение комманд через точку друг за дружкой намного упрощают взаимодействие с модулем, по сравнению с вложенными вызовами <b>os</b> и <b>os.path</b>.</p>
			<p>Думаю, <b>pathlib</b> стоит взять на вооружение - особенно если вас волнует корректное взаимодействия с путями в разных ОС. И да - библиотека - КРОСПЛАТФОРМЕННА.</p>
			<p>Для большей наглядности причин за использование данной библиотеки скажу вот что.<br> Бибиотека <b>os</b> иногда может карёжить пути в <b>Windows</b>-е.</p>
			<p>Происходит это достаточно просто.</p>
			<p>Вы наверно встречали такое, что записав некий файл с русским наименованием в <i>Windows</i> - загрузившись в <i>Linux</i> вы не могли прочитать его название ? </p>
			<p>Дело в том, что <i>Windows</i> по умолчанию использует <b>ASCII</b>. <i>Linux</i> же напротив - использует по умолчанию <b>UTF-8</b>.</p>
			<p>Поэтому файл в первой кодировке не всегда удаётся корректно прочитать в <i>Linux</i>-е. <b>Однако это далеко не вся проблема!</b></p>
			<p>Скопировав бездумно некое название с интернета и присвоив его вашему файлу - вы наверняка записываете его далеко не в кодировке <b>ASCII</b>, а может даже и не в <b>UTF-8</b>.</p>
			<p>Результат такого взаимодействия - некорректное чтение имени файла или имени директории, причем, как в <b>Windows</b>, так и в <b>Linux</b>.</p>
			<p>В <i>Python</i> же скрипте мы обнаружим несколько неприятных ошибок, которые врядли удасться адекватно исправить.</p>
			<p>Например - при правильном имени файла или папки - исключение <span style="color:#ff9933;">FileNotFoundError</span> - такого файла не существует. </p>
			<p>А иногда всё до боли намного проще.</p>
			<p>Ошибка ну просто смешная - <b>os</b> и <b>os.path</b> не могут прочитать лишний обратный слеш под-директории, в которой находится файл или нужная вам папка. Добавляете этот самый обратный слеш в имя файла или папки, даже 2 обратных слеша, чтобы не экранировать скобки строки - и опять получаете предыдущее исключение.</p>
			<p>Более того - слеш надо поставить правильный - в зависимости от ОС.</p>
			<ul>
				<li><b>/</b> - прямой в Linux</li>
				<li><b>\\</b> - обратный в Windows</li>
			</ul>
			<p>Узнать его можно с помощью - <b>os.sep</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#ff1493;">print</span>(os.sep)<br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">/</span>
			</p>
			<p><b>pathlib</b>-у же напротив - абсолютно до лампочки как вы прописали путь. Она автоматически конвертирует его в правильный формат с правильным разделителем пути.</p>
			<hr class="hr_main">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>			
		</div>
		<div class="content">
			<p><a name="part7"></a></p>
			<h2>7. Задачи с решениями</h2>
			<p>Рассмотрим несколько задач с решениям. Решения будут не сразу - а с объяснениями, чтобы вам была понятна - причина того или иного решения или подхода.</p>
			<p><a name="part7_1"></a></p>
			<h3>7.1. Задача №1.</h3>
			<p><b>Задача для Windows.</b></p>
			<ul>
				<li>
					<b>Получить список доступных дисков в системе.</b><br>
					К сожалению, определить тип диска без дополнительных <b>pip</b> библиотек не удасться. Точнее удасться, но работать такой способ будет либо только в <b>Win 7</b>, либо только в <b>Win 10</b>. Поэтому ограничимся только списком доступных дисков.
				</li>
			</ul>
			<p>
				Чтобы определить доступен ли тот или иной диск, нам необходимо знать его букву. Т.е. в самом начале нам нужны не сами диски, а пока возможные значения букв дисков. Достаточно будет просто написать английский алфавит в прямой последовательности. 
			</p>
			<p>Алфавит всегда будет неизменчивым и сразу в правильном для нас виде. Однако, писать его вручную не совсем удобно, а тем более проделывать далеко не одну такую операции в больших проектах - может вас попросту запутать - и вы наделаете множество ошибок, которые потом будет сложно исправить. Поэтому создадим алфавит немного по другому.</p>
			<p>Есть такая функция <b>chr</b>. Она преобразует число в символ Юникода.</p>
			<p>Прописные символы английского алфавита находятся в диапазоне от <b>65</b> до <b>91</b> включительно.</p>
			<p>Задачу можно решить как с помощью цикла <b>for</b>, так и с помощью <b>map</b> - обработки последовательностей без цикла. В этой функции через запятую необходимо указать именно наименование выполняемой функции, т.е. без круглых скобов <b>()</b>; а также итерируемую последовательность. т.е. последовательность, которую можно перебрать в цикле.</p>
			<p>Выглядит это следующим образом.</p>
			<p class="codes">
				alphabet1 = <span style="color:Blue;">''</span>.join([<span style="color:#ff9933;">chr</span>(x) <span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> range(65,91)])<br>
				alphabet2 = <span style="color:Blue;">''</span>.join(<span style="color:Red;">list</span>(<span style="color:Red;">map</span>(<span style="color:#ff9933;">chr</span>, range(65,91))))<br>
				<span style="color:#ff1493;">print</span>(alphabet1)<br>
				<span style="color:#ff1493;">print</span>(alphabet2)
			</p>
			<p>Результат в обоих случаях будет абсолютно одинаковый.</p>
			<p>Тепер нам понадобится библиотека <b>pathlib</b>. А точнее одна её функция - <b>Path.exists()</b> - проверка существования пути в файловой системе. </p>
			<p>
				Далее мы конечно могли бы воспользоваться функциями <i>map</i> и/или <i>filter</i>, но в этом случае код может неизбежно в разы вырасти и стать крайне громоздким. <b>(Это уже проверено).</b> В этом случае, конечно, код само собой будет без единого цикла, возможно, даже более красивым. Однако, иногда, таких конструкций стоит избегать. 
				<b>Т.е. вложенных друг в друга генераторов!</b><br>
				Это может вас сильно запутать и вы скорее всего ошибётесь: где какие скобки ставить, где делать вызов, а где вставлять присвоение <i>lambda</i> функции и многие другие.<br>
				Чаще всего такие подходы применяют в тех случаях, когда код возможно значительно упростить именно за счет вызова выполнения генераторов функций, а не самих функции. <b>Т.е. именно за счет выполнения одного генератора, а не вложенных друг в друга генераторов.</b><br>
				Это конечно не говорит о том, что такие подходы нельзя использовать - наоборот. Просто использовать их надо осторожно, т.е. с умом. Точнее думать - когда такой подход упростит ваше решение, а когда наоборот - усложнит.
			</p>
			<p>
				<b>
					Здесь соблюдается один единственный главный принцип - чем проще, тем лучше.
				</b><br>
				Поэтому именно в этом лучше не пренебрегать наипростейшими циклами с тернарными операторами.
			</p>
			<p>
				<b>
					Есть ещё один нюанс.
				</b><br><u>
				Генераторы полезны там, где имеется большой объем данных. Ведь в этом случае у вас не возникнет ошибки переполнения памяти.</u>
			</p>
			<p>Ктстати, говоря в одной из глав выше я упоминал, что внутри циклов, при использовании тернарных операторов условие необходимо ставить перед самим циклом. Однако, в этом случае вам придётся прописывать оба исхода условия - и при <b>True</b> и при <b>False</b>. Иначе без <b>else</b> у вас будет ошибка синтаксиса. Но, если поставить условие после цикла - тогда использование <b>else</b> отпадает как таковое. Иначе в последнем случае у вас опять будет ошибка синтаксиса.</p>
			<p>Выглядит это следующим образом.</p>
			<p class="codes">
				drives = [<span style="color:#ff9933;">f'{</span>d<span style="color:#ff9933;">}:'</span> <span style="color:#069;"><b>for</b></span> d <span style="color:#069;"><b>in</b></span> alphabet2 <span style="color:#069;"><b>if</b></span> Path(<span style="color:#ff9933;">f'{</span>d<span style="color:#ff9933;">}:'</span>).exists()]
			</p>
			<p>Итоговое решение будет выглядеть следующим образом.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

def main():	
	alphabet1 = <span style="color:Blue;">''</span>.join([<span style="color:#ff9933;">chr</span>(x) <span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> range(65,91)])
	alphabet2 = <span style="color:Blue;">''</span>.join(<span style="color:Red;">list</span>(<span style="color:Red;">map</span>(<span style="color:#ff9933;">chr</span>, range(65,91))))
	<span style="color:#ff1493;">print</span>(alphabet1)
	<span style="color:#ff1493;">print</span>(alphabet2)
	drives = [<span style="color:#ff9933;">f'{</span>d<span style="color:#ff9933;">}:'</span> <span style="color:#069;"><b>for</b></span> d <span style="color:#069;"><b>in</b></span> alphabet2 <span style="color:#069;"><b>if</b></span> Path(<span style="color:#ff9933;">f'{</span>d<span style="color:#ff9933;">}:'</span>).exists()]
	<span style="color:#ff1493;">print</span>(drives)

if __name__ == <span style="color:Blue;">'__main__'</span>:
	main()
				</pre>
			</div>
			<p>
				Как видите - <b>alphabet1</b> и <b>alphabet2</b> ничем друг от друга не отличаются. Здесь вполне можно применить <b>map</b>.<br>
				А вот что касается <b>drives</b>, то <b>map</b> и <b>filter</b> неизбежно увеличат громоздкость кода и значительно усложнят читабельность и как факт понимание его работы. Поэтому применён только цикл.
			</p>
			<hr class="hr_chapter">
			<p><a href="#part7">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr class="hr_chapter">
			<p><a name="part7_2"></a></p>
			<h3>7.2. Задача №2.</h3>
			<p>Я заранее поместил в каталог &laquo;<b>./pkg</b>&raquo; файл &laquo;<b>cmd.bat</b>&raquo; несколько раз в разные случайные под-папки.</p>
			<ul>
				<li>
					<b>Найти в папке &laquo;<b>./pkg</b>&raquo; все файлы с расширением &laquo;<b>cmd.bat</b>&raquo; и удалить их.</b><br>
					<u>Усложнение: не использовать циклы.</u>.<br>
				</li>
			</ul>
			<p>Если вы думаете, что сможете сделать последовательный вызов, что-то вроде: &laquo;<b>pathlib.Path().rglob('*.bat').unlink()</b>&raquo;, то вы глубоко заблуждаетесь.</p>
			<p>У вас просто выйдет исключение <span style="color:#ff9933;">AttributeError</span>.</p>
			<p>Это исключение говорит о том, что и метод <b>glob</b> и <b>rglob</b> библиотеки <i>pathlib</i> возвращают генератор, а не список найденных путей.</p>
			<p>
				Допустим, вы обернули генератор в список <b>list</b> - например, так: &laquo;<b>p = list(Path('./pkg').rglob('*.bat')).unlink(missing_ok=True)</b>&raquo;.<br> 
				Однако, вам всё равно не удасться применить метод <b>unlink()</b> к полученному списку. У вас опять возникнет тоже самое исключение <span style="color:#ff9933;">AttributeError</span>.
			</p>
			<p>Последнее исключение как раз и говорит вам о том, что оъект типа <b>'list'</b> не не имеет аттрибута <b>unlink()</b>.</p>
			<p>На самом деле задача решается буквально в 2 строки. Однако, для наглядности мы с вами рассмотрим каждый этап по отдельности и в отдельных строках для понимания каждой команды.</p>
			<p>Сначала убедимся, что <b>rglob</b> возвращает именно генератор, а не результат.</p>
			<p>Откроем консоль и запустим python.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python<br>
				>>> from pathlib import Path<br>
				>>> p = Path('./pkg').rglob('*.bat')<br>
				>>> print(p)<br>
				&#8249;generator object Path.rglob at 0x7fbf24835850&#8250;
			</p>
			<p>Теперь обернем переменную &laquo;<b>p</b>&raquo; в список и посмотрим, что у нас получилось на выходе. Продолжаем ввод.</p>
			<p class="codes">
				>>> p = list(p)<br>
				>>> print(p)<br>
				[PosixPath('pkg/cmd.bat'), PosixPath('pkg/compatible/subpackage_b/cmd.bat'), PosixPath('pkg/search/cmd.bat'), PosixPath('pkg/tests/cmd.bat')]
			</p>
			<p>Нашли необходимые файлы. Теперь, чтобы решить задачу необходимо понимать 2 вещи: что такое лямба функции и что такое <b>map</b>.</p>
			<p>Лямбда-функция — это небольшая анонимная функция, которая принимает любое количество аргументов, но имеет только одно выражение. Лямбда-функции возвращают объект, который назначен переменной или используется как часть других функций.</p>
			<p>Т.е. лямбда функция - это буквально короткая однострочная функция - вроде тернарного оператора, т.е. упрощения, но для функций.</p>
			<p>Функция <b>map</b> применяет заданную в неё функцию по её наименованию к каждому элементу итерируемой последовательности, которая задана 2 аргументом.</p>
			<p>Например, применить к списку типа <b>list</b> метод <b>int</b>.</p>
			<p>Допустим у меня есть список значений, но в строковом виде. Необходимо их быстро привести к целочисленному типу <b>int</b>.</p>
			<p class="codes">
				a = [<span style="color:Blue;">'1'</span>, <span style="color:Blue;">'2'</span>, <span style="color:Blue;">'3'</span>, <span style="color:Blue;">'4'</span>, <span style="color:Blue;">'5</span>']<br>
				b = <span style="color:#ff9933;">list</span>(<span style="color:Red;">map</span>(int, a))<br>
				<span style="color:#ff1493;">print</span>(a)<br>
				<span style="color:#ff1493;">print</span>(b)<br>
				x = <span style="color:#ff9933;">list</span>(<span style="color:Red;">map</span>(<span style="color:#ff9933;">type</span>, a))<br>
				y = <span style="color:#ff9933;">list</span>(<span style="color:Red;">map</span>(<span style="color:#ff9933;">type</span>, b))<br>
				<span style="color:#ff1493;">print</span>(x)<br>
				<span style="color:#ff1493;">print</span>(y)
			</p>
			<p>При выполнении скрипта с этим кодом, мы увидим следующий результат.</p>
			<p class="codes">
				['1', '2', '3', '4', '5']<br>
				[1, 2, 3, 4, 5]<br>
				[&#8249;class 'str'&#8250;, &#8249;class 'str'&#8250;, &#8249;class 'str'&#8250;, &#8249;class 'str'&#8250;, &#8249;class 'str'&#8250;]<br>
				[&#8249;class 'int'&#8250;, &#8249;class 'int'&#8250;, &#8249;class 'int'&#8250;, &#8249;class 'int'&#8250;, &#8249;class 'int'&#8250;]
			</p>
			<p>Теперь поговорим о сочетании <b>map</b> и лямбда функций.</p>
			<p>Если вы помните <b>map</b> выполняет заданную функцию. Лямбда же функция по сути сначала возвращает не результат и ссылку на функцию. Таким образом её вполне можно вставлять в качестве первого аргумента.</p>
			<p>Например, просто возвести список значений в квадрат.</p>
			<p>Да, мы могли бы поступить следующим образом.</p>
			<div class="codeses">
				<pre>
a = [1, 2, 3]
b = []
<span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> a:
	b.append(x*x)	
				</pre>
			</div>
			<p>Мы даже вполне могли бы упростить до одного терарного оператора.</p>
			<p class="codes">
				a = [1, 2, 3]<br>
				c = [x*x for x in a]
			</p>
			<p>А могли бы сделать и так.</p>
			<p class="codes">
				a = [1, 2, 3]<br>
				d = list(map(lambda x: x*x, a))
			</p>
			<p>Результат во всех случаях будет абсолютно одинаковый.</p>
			<p>Теперь когда вам понятно как использовать сочетния <b>map</b> и <b>lambda</b> стоит подчеркнуть ещё один нюанс.</p>
			<p>При вызове метода <b>Path.unlink()</b> нам ничего не будет возвращено, т.е. конечный список должен быть пустым. Т.е. можно этот список не присваивать никакой переменной, а просто вызвать и всё.</p>
			<p>Итак, полный код решения.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = list(Path(<span style="color:Blue;">'./pkg'</span>).rglob(<span style="color:Blue;">'*.bat'</span>))<br>
				list(<span style="color:Red;">map</span>(<span style="color:#069;"><b>lambda</b></span> x: x.unlink(<span style="color:#ff9933;">missing_ok</span>=True), p))<br>
				
				<span style="color:Green;"># Не обязательно - проверяем результат повторным поиском</span><br>
				p = list(Path(<span style="color:Blue;">'./pkg'</span>).rglob(<span style="color:Blue;">'*.bat'</span>))<br>
				<span style="color:Green;"># Просто выведем результат повторного поиска на экран, он должен быть пустым</span><br>
				<span style="color:#ff1493;">print</span>(p)<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br><span style="color:Blue;">
				&#8249;generator object Path.rglob at 0x7fbf24835850&#8250;<br>
				[PosixPath('pkg/cmd.bat'), PosixPath('pkg/compatible/subpackage_b/cmd.bat'), PosixPath('pkg/search/cmd.bat'), PosixPath('pkg/tests/cmd.bat')]<br>
				[]</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part7">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr class="hr_chapter">
			<p><a name="part7_3"></a></p>
			<h3>7.3. Задача №3.</h3>
			<p>Первые две задачи были достаточно простыми. Однако, они направлены с учебной целью на наиболее частые действия, которые требуются в разных ОС. Теперь рассмотрим немного более сложную и одновременно простую задачу.</p>
			<p>
				Представьте себе ситуацию, что ваш рабочий сервер сгорел и контролера доменов с <i>Active Directory</i> больше нет. Пусть для примера будет блок питания.
			</p>
			<p>Бухгалтерия не выделяет средства ни на починку, ни на ремонт.</p>
			<p>
				Более того - в вашей организации локальный сервер, даже в качестве файлового, больше не нужен, потому что бухгалтерия перешла на облачные технологии и облачную защиту. А все пользователи сети вашей организации давно начали пользоваться удалёнными базами данных по специальному доступу (приказ сверху). 
			</p>
			<p>Большинство всех современных организаций переходят на облачные технологии. Так что, такая ситуация вполне нормальна для современных реалей жизни.</p>
			<p>А может быть так, что количество денег в вашей оранизации может с трудом хватать на зарплаты сотрудников и бухгалтерия просто не может выделить ни цента даже на починку.</p>
			<p>
				На самом деле причина не так важна. Важны последствия. Ведь теперь у вас масса рабочих ПК с непонятными наборами пользователей. Причём пароли не так важны, ведь их легко можно обойти, что в <i>Windows</i>, что в <i>Linux</i>.<br> 
			</p>
			<p><b>Главное - это теперь это всё надо как-то разрулить.</b></p>
			<p>
				Собрать со всех ПК простую информацию о системах при помощи библиотеки <b>platform</b> не проблема.<br>
				Но ведь её будет не достаточно.
			</p>
			<p>Если имя активного пользователя можно узнать с помощью кросплатформенной команды &laquo;<b>whoami</b>&raquo;, то с остальным надо разбираться как-то по другому.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-19.png" class="fz__minimized" alt="клик для увеличения" title="Linux and wine, python list-users.py" />
			</div>
			<p>И вот тут на арену выходит задача-помошник.</p>
			<ul>
				<li>
					<b>Получить список пользователей ОС: и Windows, и Linux.</b><br>
					В <i>Windows</i> список учеьных записей и активной учетной записи. <u>Не сетевых пользователей, а локальных.</u><br>
					В <i>Linux</i> просто получить список пользователей ОС и пользователя вошедшего в систему.
				</li>
			</ul>
			<p>Задача кажется довольно сложной и вы, наверняка, как и я изначально, будете искать способы определения списка учетных записей обоих систем.</p>
			<p>Да, вы можете это проделать с помощью различных дополнительных библиотек. А в случае когда не сможете - обратитесь за помщью к <b>C++</b>.</p>
			<p>Возможно даже найдёте один из спосбов <b>IDE C++ Builder</b> - <a href="https://github.com/maximalisimus/linux-sh/tree/main/l_sh_work/CPP_Training/GetUsers">вроде вот этого</a>.</p>
			<p><b>Однако, тут есть 2 больших проблемы.</b></p>
			<ol>
				<li>
					<b>Решение не кросплатформенно.</b><br> 
					Найдя решение для одной системы оно не годится для другой.<br> 
					Сегодня вы работаете в <i>Windows</i> - завтра по приказу сверху переходите на отечественное ПО <i>Linux</i>.
				</li>
				<br>
				<li>
					<b>К сожалению, практически все варианты решений любого языка программирования имеют проблемы с кодировкой</b>.<br>
					Проблема не заметна пока вы используете только вывод данных в консоль или командную строку. Однако, как только вы попытаетесь записать полученные данные в файл - неизбежно столкнётесь с <u>иероглифами</u>.<br>
					Ни один из найденых мною способов преобразования <b>wchar_t</b> в <b>string</b> не работает и в файл сохраняется полная ерунда.<br> 
					Правильнее говоря - преобразования из кодировки строки <b>CP1251</b> в <b>UTF-8</b>.
				</li>
			</ol>
			<p>В последнем можете убедиться сами - скачайте всю папку целиком и запустите <b>cmd.bat</b> файл, затем введите: &laquo;<b>getusers.exe</b>&raquo;. При вызове из командной строки - всё будет нормально отображаться. Как только вы попытаетесь перехватить результат выполнения программы в <b>Python</b> (например, с помощью <b>Subprocess</b> или <b>os.popen</b>)  - получите на выходе только иероглифы.</p>
			<p><b>Один НЮАНС!</b></p>
			<p>
				<u>Иероглифы будут только в том случае, если на проверяемом ПК имена пользователей на русском языке.</u><br>
				Если на английском или латиницей - проблем не будет.
			</p>
			<p>Вызовы перехватывают за тем, чтобы их как-то использовать - например, собрать всю информацию и из <b>platform</b> и с помощью вашей консольной <i>Python</i>-программы в один небольшой лог-файл.</p>
			<p>На самом деле решение довольно примитивное - всем известное, однако не все понимают что нижеуказанный подход намного проще библиотечных и системных вызовов разлиных функций и программ, а главное в разы быстрее. Потому что выдаёт на выходе абсолютно такую же информацию.</p>
			<p>Более того - <u>решение кросплатформенно</u> и относится не только к языку <b>Python</b>.</p>
			<p>Но обо всём по порядку.</p>
			<p>Для начала дайте определение <u>каталогу пользователей</u>.</p>
			<p>Ему можно дать много разных определений, но самое главное на мой взгляд <u>каталог пользователей</u> - это место, где находятся все папки домашних деректорий пользователей по их именам в системе.</p>
			<p>
				Т.е. в этой папке находятся только домашние папки пользователей, которые могут войти в систему с теми или иными правами доступа. <br> 
				Закрадывается вопрос - почему бы получить список пользователей отсюда?
			</p>
			<p>Да - возможно, но есть нюансы.</p>
			<p>Тогда возникает второй вопрос - что такое <u>домашний каталог пользователя</u> ?</p>
			<p>
				<u>Домашний каталог</u> — это личный каталог пользователя в ОС, где находятся его данные, настройки и т. д.
			</p>
			<p>
				Т.е. в имени директории содержится имя активного пользователя?<br>
				Да - действительно это так. Причём выглядит абсолютно одинаково - что в <i>Windows</i>, что в <i>Linux</i>.
			</p>
			<p>Теперь вернёмся к нюансам.</p>
			<p>
				В <i>Linux</i> у вас не будет проблем - просканируйте директорию <b>/home</b> - для списка пользователей, а для активного пользователя просто проанализируйте <i>переменную-ссылку</i> на домашний каталог текущего пользователя. Этого будет достаточно. <br>
				В <i>Windows</i> в директории пользователей храняться не только существующие учетные записи, но и так называемые - блокированные уетные записи, Default учетные записи, стандартные встроеные учетные записи администраторов, скрытые учетные пользователей и другие.
			</p>
			<p>
				<b>В последнем случае - это не значит что вы сможете во все эти учетные записи войти.</b><br>
				Получается, что хоть парочки из таких учетных записей именно в <b>Windows</b> необходимо отфильтровывать.
			</p>
			<p>Остаётся только один вопрос: как сделать решение кросплатформенным?</p>
			<p>Сегодня мы с вами решим и эту проблему.</p>
			<p>Первым делом давайте заведём список, в который мы будем вносить все имена пользователей, которых хотим исключить из конечного списка.</p>
			<p class="codes">
				exclude_users = [<span style="color:Blue;">'All Users'</span>, <span style="color:Blue;">'Default'</span>, <span style="color:Blue;">'Default User'</span>, <span style="color:Blue;">'desktop.ini'</span>, <span style="color:Blue;">'Public'</span>, <span style="color:Blue;">'Все пользователи'</span>, <span style="color:Blue;">'Intel'</span>, <span style="color:Blue;">'AMD'</span>]
			</p>
			<p>
				Это базовые пользователи, которые чаще всего просто скрыты и не видны при простом открытии папки: <b>C:\users\</b>, за исключением общей папки.<br>
				Именно в этот список вы и можете вносить любых пользователей или папки, которые вы хотите исключить из поиска.
			</p>
			<p>Далее нам нужен домашний каталог пользователя от которого и будем крутиться.</p>
			<p class="codes">
				p = pathlib.Path.home()
			</p>
			<p>Для вывода активного пользователя в любой ОС в <b>pathlib</b> достаточно запросить имя полученной директории.</p>
			<p class="codes">
				<span style="color:#ff1493;">print</span>(p.parts[-1], p.name)
			</p>
			<p>Здесь мы видим 2 способа:</p>
			<ol>
				<li>
					<b>p.parts[-1]</b> - возвращает кортеж частей путей на основе разделителя путей для данной ОС.<br>
					И в конце берем срез кортежа - только последнюю часть пути.
				</li>
				<li><b>p.name</b> - стандартное базовое имя пути. Наиболее частое и правильное решение.</li>
			</ol>
			<p>Чтобы обратиться к <u>каталогу пользователей</u> необходимо всего лишь обратиться к родительской директории.</p>
			<p class="codes">
				<span style="color:#ff1493;">print</span>(p.parent)
			</p>
			<p>Чтобы получить список пользователей системы и отфильтровать его, сначала необходимо получить список всех пользователей системы.</p>
			<p class="codes">
				all_users = <span style="color:#ff9933;">list</span>(<span style="color:Red;">map</span>(lambda x: x.name, list(p.parent.iterdir())))<br>
				<span style="color:Green;"># all_users = list(map(lambda x: x.name, list(p.parent.glob('*'))))</span>
			</p>
			<p>
				В комментарии я указал второй способ получения списка всех пользователей системы. Здесь необходимо обратить внимание только на строку поиска <b>Path.glob('*')</b>. Поиск должен быть именно всех файлов и папок, но не рекурсивный, иначе вы рискуете получить исключение <span style="color:#ff9933;">IndexError</span>.
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-18.png" class="fz__minimized" alt="клик для увеличения" title="IndexError" />
			</div>
			<p>
				Теперь можно получить список доступных пользователей системы и одновременно исключить <b>exclude_users</b>.
			</p>
			<p class="codes">
				pc_users = [x <span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> all_users <span style="color:#069;"><b>if</b></span> <span style="color:#069;"><b>not</b></span> x <span style="color:#069;"><b>in</b></span> exclude_users]<br>
				<span style="color:#ff1493;">print</span>(pc_users)
			</p>	
			<p>Ну и посмотрим теперь на весь код целиком.</p>
			<div class="codeses">
				<pre><span style="color:Red;">
#!/usr/bin/env python3
# -*- coding: utf-8 -*-</span>

<span style="color:#069;"><b>import</b></span> pathlib

exclude_users = [<span style="color:Blue;">'All Users'</span>, <span style="color:Blue;">'Default'</span>, <span style="color:Blue;">'Default User'</span>, <span style="color:Blue;">'desktop.ini'</span>, <span style="color:Blue;">'Public'</span>, <span style="color:Blue;">'Все пользователи'</span>, <span style="color:Blue;">'Intel'</span>, <span style="color:Blue;">'AMD'</span>]

<span style="color:#069;"><b>def</b></span> main():
	<span style="color:#069;"><b>global</b></span> exclude_users
	p = pathlib.Path.home()
	<span style="color:#ff1493;">print</span>(p.parts[-1], p.name)
	<span style="color:#ff1493;">print</span>(p.parent)
	all_users = <span style="color:#ff9933;">list</span>(<span style="color:red;">map</span>(lambda x: x.name, list(p.parent.iterdir())))
	<span style="color:Green;"># all_users = list(map(<span style="color:#069;"><b>lambda</b></span> x: x.name, list(p.parent.glob(<span style="color:Blue;">'*'</span>))))</span>
	pc_users = [x <span style="color:#069;"><b>for</b></span> x <span style="color:#069;"><b>in</b></span> all_users <span style="color:#069;"><b>if</b></span> not x <span style="color:#069;"><b>in</b></span> exclude_users]
	<span style="color:#ff1493;">print</span>(pc_users)

<span style="color:#069;"><b>if</b></span> <span style="color:#ff9933;">__name__</span> == <span style="color:Blue;">'__main__'</span>:
	main()
				</pre>
			</div>
			<p>А теперь посмотрим как этот код выполняется в <b>Windows 10</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-17.png" class="fz__minimized" alt="клик для увеличения" title="Windows 10, Qemu, python list-users.py" />
			</div>
			<hr class="hr_main">
			<p><a href="#part7">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part8"></a></p>
			<h2>8. Немного <span style="color:Red;">&laquo;unittest&raquo;</span></h2>
			<p>Если мы затронули тему пакетирования <b>package</b>, соответственно нельзя обойти стороной и тестирование своих модулей.</p>
			<p>Представьте, что вы написали какую-либо программу, а теперь хотите проверить, правильно ли она работает. Что вы для этого сделаете? Скорее всего, вы запустите её несколько раз с различными входными данными, и убедитесь в правильности выдаваемого ответа.</p>
			<p>А теперь вы что-то поменяли и снова хотите проверить корректность программы. Запускать ещё несколько раз? А если потом снова что-то поменяется? Нельзя ли как-то автоматизировать это дело?</p>
			<p>Оказывается, можно. В Python встроен модуль unittest, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.</p>
			<p>
				На самом деле о тестах можно говорит очень много, однако, я и сам пока что не так много о них знаю. Поэтому оставлю вам здесь несколько наиболее важных ссылок, на мой взгляд.
			</p>
			<ul>
				<li><a href="https://digitology.tech/docs/python_3/library/unittest.html">Наиболее полное описание возможностей модуля</a></li>
				<li><a href="https://pythonworld.ru/moduli/modul-unittest.html">Базовая <i>&laquo;Python&raquo;</i> документация</a></li>
				<li><a href="http://grep.cs.msu.ru/python3.8_RU/digitology.tech/docs/python_3/library/unittest.html">Русифицированная <i>&laquo;Python&raquo;</i> документация</a></li>
				<li><a href="https://tproger.ru/articles/testiruem-na-python-unittest-i-pytest-instrukcija-dlja-nachinajushhih/">Здесь немного больше базовой информации, чем в <i>&laquo;Python&raquo;</i> документации</a></li>
			</ul>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part9"></a></p>
			<h2>9. О Python в Windows 7, 10 и выше, а также WINE.</h2>
			<p>Для того, чтобы получить доступ к <b>Windows</b> путям библиотеки <b>pathlib</b> я воспользуюсь следующим методом внутри <b>Linux</b>.</p>
			<p><b>Помните, что такой метод позволит лишь попробовать запустить какой либо код, так сказать испытать его в действии без загрузки самой ОС, напрямую в <i>Linux</i>. При этом он будет работать в <i>Windows</i>, но компиляция этого кода при помощи библиотек: <i>nuitka</i>, <i>pyinstaller</i>, <i>Cython</i>, <i>py2exe</i> и других - в <i>wine</i> не даёт гарантии работоспособности таких <i>exe</i> файлов в <b>Windows</b>.</b></p>
			<p><b>Помните, что не всякий код можно будет проверить на работоспособность таким быстрым способом в Linux.</b></p>
			<p>Для того, чтобы получить доступ к <i>Windows</i> путям библиотеки <i>pathlib</i> в <i>Linux</i>, я скачаю портативную версию <i>Python</i> с сайта <a href="https://sourceforge.net/projects/portable-python/files/Portable%20Python%203.8/">sourceforge.net</a>. Версии 3.8.9 будет достаточно. Версию выше для <i>wine</i> скачивать не рекомендую. Возможны проблемы с запуском и использованием.</p>
			<p>На этом ресурсе все <i>exe</i> файлы является <i>SFX</i> архивами, т.е. что в <i>Windows</i>, что в <i>Linux</i> его можно распаковать как просто запустив, так и с помощью консольной утилиты <i>7z</i>.</p>
			<p>Из скачанного <i>SFX</i> архива нам нужен только сам <b>Python</b>. Остальные встроенные утилиты нас не интересуют. Поэтому, из скачанной версии распакуем только сам <i>Python</i>, а затем переместить эту папку по наиболее правильному, т.е. выгодному, пути с точки зрения управления переменными окружения <b>PATH</b>.</p>
			<p>
				<span style="color:Green;">Все указанные ниже операции проделываются только для того, чтобы командная строка <b>CMD</b> или <b>PowerShell</b> могли видеть все <b>EXE</b> файлы внутри распакованной директории. Иначе вы не сможете ни запустить <b>Python</b>, ни управлять его <b>PIP</b>-ом.</span><br>
				Кстати, многие операции ниже можете проделать и вручную. Например, распаковку с помощью <i>7z-менеджера</i>.
			</p>
			<p class="codes">
				<span style="color:Green;"># Скачиваем портативную версию Python. Можете скачать с помощью браузера</span><br>
				<b>mikl ~/003/Primer $</b> wget -O Portable-Python-3.8.9-x64.exe https://sourceforge.net/projects/portable-python/files/Portable%20Python%203.8/Portable%20Python-3.8.9%20x64.exe/download<br>
				<span style="color:Green;"># Создаем необходимые директории</span><br>
				<b>mikl ~/003/Primer $</b> mkdir -p ~/.wine/drive_c/wsl-win-7/<br>
				<span style="color:Green;"># распаковываем из SFX архива только нужную папку с Python-ом</span><br>
				<b>mikl ~/003/Primer $</b> 7z x Portable-Python-3.8.9-x64.exe -r "Portable Python-3.8.9 x64/App/Python/"<br>
				<span style="color:Green;"># Перемещаем папку с Python-ом без вложенных путей в нужную нам папку wsl-win-7 с переименованием</span><br>
				<span style="color:Green;"># Назвать все директории можете как угодно, главное без пробелов</span><br>
				<b>mikl ~/003/Primer $</b> mv "./Portable Python-3.8.9 x64/App/Python/" ~/.wine/drive_c/wsl-win-7/Portable-Python-3.8.9-x64<br>
				<span style="color:Green;"># Удаляем ненужные полу-пустые директории</span><br>
				<b>mikl ~/003/Primer $</b> rm -rf "./Portable Python-3.8.9 x64/"
			</p>
			<p>Обратите внимание на создание пути <b>&laquo;~/.wine/drive_c/wsl-win-7/&raquo;</b>. <br><b>&laquo;~/.wine/drive_c/&raquo;</b>- это как раз и есть диск <b>C:</b> для <i>wine</i>.</p>
			<p><b>В этом полном пути не должно быть никаких пробелов и символов запрещенных в именовании файлов и папок Windows.</b></p>
			<p>Для себя я прописал дополнительную под-директорию по следующей причине. Вдруг мне понадобится вместо скачанной 64-битной версии ещё и 32-битная. И чтобы не загромождать диск <b>C:</b> папками и не разбираться потом что и зачем было скачано - я просто создам отдельную директорию. Если мне вдруг понадобится не только <i>Python</i>, но и например: make, cmake, mingw. Я просто также буду скачивать их и распаковывать по путям без пробелов в эту отдельную директорию.</p>
			<p><b>Например:</b></p>
			<ul>
				<li>~/.wine/drive_c/wsl-win-7/golang/golang-x86</li>
				<li>~/.wine/drive_c/wsl-win-7/golang/golang-x64</li>
				<li>~/.wine/drive_c/wsl-win-7/mingw/mingw-4.8.2-x86</li>
				<li>~/.wine/drive_c/wsl-win-7/mingw/mingw-4.8.2-x64</li>
			</ul>
			<p>При необходимости я просто удалю одну эту директорию и всё!</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> rm -rf ~/.wine/drive_c/wsl-win-7/
			</p>
			<p><b>Сейчас так делать не будем. Это просто пример.</b></p>
			<p>
				Самое интересное здесь в том, что данный подход к использованию портативной версии <i>Python</i> работает не только в <i>wine</i>, но и в <i>ОС Windows</i><br>
				Однако есть и ещё несколько нюансов использования любой ОС и любой версии <i>Python-а</i>.<br>
				В любом случае <b>bat</b>-файл будет служить в качестве запуска командной строки или <i>PowerShell</i> из текущей директории с добавлением путей к <b>pip</b>-у и самому <b>Python</b>-у в переменную <b>PATH</b>. И здесь необходимо обратить внимание на несколько моментов.
			</p>
			<ul>
				<li>Не все версии <i>Python</i>-а будут работать в ОС младше <i>Windows 10</i></li>
				<li>Учитывайте, что командная строка в <i>Windows 10</i> практически изжыла себя и работает не совсем адекватно. Её практически заменил <i>Power Shell</i>.</li>
				<li>В <b>Windows 10</b> и старше не рекомендую скачивать и использовать и установочный и портативный вариант <i>Python</i>-а с официального сайта <b>python.org</b> - у них не работает <b>pip</b> как таковой. Почему не ясно. Лучше использовать с сайта <b>sourceforge.net</b>.</li>
			</ul>
			<p>По крайней мере, мне запустить <i>PIP</i> так и не удалось. Даже с использованием и <a href="https://bootstrap.pypa.io/get-pip.py">bootstrap-get-pip.py</a> и <a href="https://github.com/pypa/get-pip/blob/main/public/get-pip.py">github-get-pip.py</a>.</p>
			<p><b>Например, вот эти не рекомендуется скачивать и использовать.</b></p>
			<ul>
				<li><a href="https://www.python.org/ftp/python/3.10.5/python-3.10.5-embed-amd64.zip">Python 3.10.5 Windows embeddable package (64-bit)</a></li>
				<li><a href="https://www.python.org/ftp/python/3.10.5/python-3.10.5-amd64.exe">Python 3.10.5 Windows installer (64-bit)</a></li>
			</ul>
			<p>
				Лучше заменить вот этими версиями. <span style="color:Green;">Да, сложнее ставить, зато <b>pip</b> точно будет работать</span>.
			</p>
			<p>
				Или вы можете собрать <a href="https://github.com/python/cpython.git">CPython</a> вручную, используя <i>mingw</i> ( <a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/">MinGW Toolchains targetting Win32</a>, <a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/">MinGW Toolchains targetting Win64</a> ), <a href="http://gnuwin32.sourceforge.net/packages/make.htm">make</a> и / или <a href="https://sourceforge.net/projects/cmake.mirror/files/">cmake sourceforge.net</a> ( или <a href="https://cmake.org/download/">cmake oficial</a> ), распаковав или установив их все точно также, как и портативные версии выше по путям без пробелов и спец символов, а также прописав в запускаемом <b>bat</b> файле <b>&laquo;SET PATH=;%PATH%&raquo;</b> все пути к этим <b>EXE</b>-ам на разных строках, как и путь к исходному коду скачанной версии <b>Python</b>.<br>
				В случае сборки <i>CPython</i> вручную - что в <i>Windows</i>, что в <i>Linux</i> проблем с <i>PIP</i>-ом быть не должно. По крайней мере, у меня пока что, ни разу не возникало.
			</p>
			<ul>
				<li><a href="https://sourceforge.net/projects/portable-python/files/">Portable-Python</a></li>
			</ul>
			<p>Для использования в <b>Windows 10</b> всё что нужно, это заменить одну единственную строку в <b>bat-файле</b>.</p>
			<p style="margin-left: 20px"><b>cmd.exe</b> на <b>powershell.exe</b>. Чуть ниже, вы это всё увидете.</p>
			<p></p>
			<p>После этого необходимо создать <b>sh</b> скрипт и расположить его в любом удобном для вас месте, а затем создать ссылку на него в <b>/usr/bin/</b>.</p>
			<p>Создам отдельную директорию для всех скриптов: <b>~/programs/</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> mkdir -p ~/programs/<br>
				<b>mikl ~/003/Primer $</b> touch ~/program/wine-cmd.sh && chmod +x ~/program/wine-cmd.sh<br>
				<b>mikl ~/003/Primer $</b> nano ~/program/wine-cmd.sh<br>
				#!/bin/bash<br><br>

				wine '/home/mikl/.wine/drive_c/windows/system32/cmd.exe'<br><br>
				<b>mikl ~/003/Primer $</b> sudo ln -s /home/mikl/program/wine-cmd.sh /usr/bin/wine-cmd
			</p>
			<p>Осталось только создать <b>bat-файл</b> и готово - можно тестировать. Окончание строк файла удобнее и быстрее поменять на <b>CR/LF</b> с помщью <b>Geany</b> в следующем меню: <i>Документ &#9658; Установить окончание строк &#9658; Заменить окончание строк на CR/LF (Windows)</i>.</p>
			<p>Содержимое файла: <b>cmd.bat</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano cmd.bat<br>
				@echo off<br>
				SET PATH=C:\wsl-win-7\Portable-Python-3.8.9-x64\;%PATH%<br>
				SET PATH=C:\wsl-win-7\Portable-Python-3.8.9-x64\Scripts\;%PATH%<br>
				cmd.exe<br>
			</p>
			<p>
				Команда <i>&laquo;@echo off&raquo;</i> не обязательна. Но с ней у вас не будет постоянно маячить перед глазами каждая выполняемая строка этого <i>BAT</i>-файла.
			</p>
			<p>
				Команда <i>&laquo;SET PATH=&raquo;</i> обязательна. После равно обязательно через точку с запятой <i>&laquo;<b>;</b>&raquo;</i> указываем все необходимые пути. <b>Заканчивать каждую такую строку обязательно <i>&laquo;%PATH%&raquo;</i>.</b><br>
				Иначе вы потеряете доступ к <i>CMD</i> или <i>PowerShell</i>, а последний будет выдавать только ОШИБКИ вместо выполнения любой команды.
			</p>
			<p>Вообще все пути <i>&laquo;SET PATH=&raquo;</i> можно расположить вообще в одной строке. Просто последовательно записать все пути через точку с запятой. Такой подход, как выше, реализован только для красоты и понимания что где находится. Просто вам же будет понятнее где какой путь находится и проще будет его подредактировать при необходимости, чтобы не искать в супер-длинной и не особо понятной строке.</p>
			<p>Запустить всё можно следующей последовательностью комманд:</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> wine-cmd<br>
				<b>mikl ~/003/Primer $</b> cmd.bat<br>
				<span style="color:Green;"># После этого должен появится текст о версии продукта. Если не появился - значит что-то сделали не так или что-нибудь пропустили - читайте заново</span><br>
				<b>Z:\home\mikl\003\Primer></b> python --version<br>
				<span style="color:Blue;">Python 3.8.9</span>
			</p>
			<p>Теперь можно проверять <i>Windows-Python</i> код непосредственно в <b>wine</b>.</p>
			<p>При необходимости - просто создавайте <i>.bat</i> файл с таким же содержимым в нужной вам директории и запускайте ваш <i>Windows-Python</i> код в той же описанной последовательности.</p>
			<p>В <i>Windows</i> похожие <i>.bat</i> файлы используются для доступа либо к портативным версиям каких либо консольных программ, либо для того, чтобы не прописывать доступ к этим программам в переменные окружения самой системы.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-15.png" class="fz__minimized" alt="клик для увеличения" title="Win-10 User PowerShell Python and PIP" />
			</div>
			<p>Вам необходимо также знать, что в <i>Windows 10</i> использование командной строки или <i>PowerShell</i> в режиме администратора несёт за собой несколько неприяных последствий. Рекомендуется запускать только от имени пользователя, т.е. двойным щелчком мыши по <b>bat</b>-файлу и всё.</p>
			<p>При запуске в режиме администратора:</p>
			<ul>
				<li>При запуске вы всегда будете перемещены в <b>C:\Windows\System32\</b> по умолчанию, чтобы бы вы не делали. <b>cd</b> не поможет</li>
				<li>Команды <b>CD D:</b> или <b>cd C:</b> не работают</li>
				<li>Для перемещения используйте, например, <b>cd ../</b> для каталога выше</li>
				<li><b>SET PATH=C:\my-dir\;%PATH%</b> - не работает. <b>SET PATH...</b> вообще не работает</li>
			</ul>
			<p>Ну а в <b>PowerShell</b> соответственно не работают: <b>$env:Path+=</b>...</p>
			<p>Т.е. для режима администратора все пути к вашим <b>EXE</b> программам всё-таки придётся записывать в переменные окружения самой системы.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-11.png" class="fz__minimized" alt="клик для увеличения" title="Win-10 CMD User" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-12.png" class="fz__minimized" alt="клик для увеличения" title="Win-10 PowerShell USer" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-13.png" class="fz__minimized" alt="клик для увеличения" title="Win-10 CMD Admin" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-14.png" class="fz__minimized" alt="клик для увеличения" title="Win-10 CMD PowerShell" />
			</div>
			<p>В <i>&laquo;Windows 7&raquo;</i> изменение переменных окружения делается так.</p>
			<p style="margin-left: 20px">
				<span style="color:Green;">Мой компьютер &#9658; Свойства &#9658; Дополнительные параметры системы &#9658; Переменные среды &#9658; <b>PATH</b> &#9658; Изменить</span>.<br>
				Затем через точку с запятой &laquo;<b>;</b>&raquo; прописываете любой необходимый вам путь.<br>
				Чтобы применить настройки - ОК, ОК, ОК...
			</p>
			<p>
				Однако, более правильным будет немного другой подход.<br>
				В том же окне <i>&laquo;Переменные среды&raquo;</i> в разделе <i>&laquo;Переменные среды пользователя для ...&raquo;</i> Нажмите кнопку <i>&laquo;Создать&raquo;</i>. Затем в поле <i>Имя переменной</i> дайте какое-нибудь имя без пробелов и знаков препинаний только латиницей. А в поле <i>Значение</i> укажите путь к нужному каталогу.<br>
				Нажмите <i>ОК</i>.<br>
				Затем <i>&laquo;Path&raquo;</i> &#9658; Изменить &#9658; и в открывшемся окне прописываете наименование только что созданной переменной.
			</p>
			<p>В <i>&laquo;Windows 10&raquo;</i> это делается немного по другому.</p>
			<p style="margin-left: 20px">
				<span style="color:Green;"><i>WIN + R</i> &#9658; <i>&laquo;control.exe&raquo;</i> &#9658; ОК &#9658; (Просмотр &#9658; Крупные значки. Не обязательно.) Система &#9658; Дополнительные параметры системы &#9658; Переменные среды &#9658; <b>PATH</b> &#9658; Изменить</span><br>
				Затем создайте необходимые вам пути.<br>
				Чтобы применить настройки - ОК, ОК, ОК...
			</p>
			<p>
				Здесь тоже будет более правильным немного другой подход.<br>
				В том же окне <i>&laquo;Переменные среды&raquo;</i> в разделе <i>&laquo;Переменные среды пользователя для ...&raquo;</i> Нажмите кнопку <i>&laquo;Создать&raquo;</i>. Затем в поле <i>Имя переменной</i> дайте какое-нибудь имя без пробелов и знаков препинаний только латиницей. А в поле <i>Значение</i> укажите путь к нужному каталогу.<br>
				Нажмите <i>ОК</i>.<br>
				Затем <i>&laquo;Path&raquo;</i> &#9658; Изменить &#9658; и в открывшемся окне создайте ещё один путь, указывая наименование только что созданной переменной.<br>
				Чтобы применить настройки - ОК, ОК, ОК...
			</p>
			<p><b>А теперь об одном важном момент, о котором нигде не упоминается.</b></p>
			<p>Если вы удалите какую либо программу, т.е. доступа к <i>EXE</i> файлам программы больше не будет - т.е. когда путь к программе будет больше не доступен - и при этом вы забудите удалить переменные окружения, которые добавляли по инструкции выше - то при любом запуске командной строки <i>CMD</i> или <i>PowerShell</i> - будут выдавать вам ошибки запуска - что не могут найти указанный путь и отказываться выполнять какие-либо команды.</p>
			<p><b>При удалении программ, даже портативных - при добавлении переменных окружения, позаботьтесь и об их удалении.</b></p>
			<p><u>Если ваши переменные окружения только внутри <i>BAT</i> файла - ничего нигде удалять не нужно!</u></p>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; 04.08.2022 by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
