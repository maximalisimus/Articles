<html>
<head>
	<meta charset="utf-8">
	<title>Чёрный список ip адресов.</title>
	<link rel="icon" href="../image/Blacklists-image/blacklists-logo.ico">
	<!--
		<link rel="icon" href="image/favicon.png">
		<link rel="shortcut icon" href="js-css/404-2.ico" Type="image/x-icon">
		type="image/png"
		<link rel="shortcut icon" href="favicon.png" type="image/png">
		<link rel="icon" href="image/favicon.svg" type=" image/svg+xml">
	-->
	<link rel="stylesheet" href="../html/main.css" type="text/css">	
	<link rel="stylesheet" href="../html/zoom.css" type="text/css">
	<link rel="stylesheet" href="../html/table.css" type="text/css">
	<link rel="stylesheet" href="../html/frame.css">
	<link rel="stylesheet" href="../html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="../html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="../html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Blacklists.</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="../image/Blacklists-image/firewall-network-security-scaled.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<center>
				<h1>Большое руководство по чёрным спискам ip адресов.</h1>
			</center>
			<p>Для начала давайте с вами определимся с основными понятиями:</p>
			<ul>
				<li>Что такое угроза?</li>
				<li>Что такое признак атаки?</li>
				<li>Как узнать о том, что сервер находится в большой опасности?</li>
				<li>Что вообще такое фаервол, и какие они бывают в <b>Linux</b>-ах.</li>
				<li>И многое другое ...</li>
			</ul>
			<p>После чего посмотрим каким образом блокировать и разблокировать угрозы безопасности.</p>
			<p>Далее определимся с пониятием черных и белых списков и зачем они вообще нужны.</p>
			<p>Посмотрим с вами на реальные примеры и виртуального и реального (<b>VPS</b>) серверов.</p>
			<p>И наконец, на примере виртуального сервера в разы усилим его безопасность.</p>
			<p>Итак, приступим.</p>
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Что можно сделать с украденными личными данными?</a></li>
				<li><a href="#part2">Введение.</a></li>
				<li><a href="#part3">Файловый дескриптор.</a></li>
				<li><a href="#part4">Межсетевые экраны.</a></li>
				<ol>
					<li><a href="#part4.1">История, определения.</a></li>
					<li><a href="#part4.2">Netfilter</a></li>
					<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
					<li><a href="#part4.4">NFTABLES.</a></li>
					<li><a href="#part4.5">UFW / Firewalld.</a></li>
					<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
				</ol>
				<li><a href="#part5">Part-3</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Что можно сделать с украденными личными данными?</h2>
			<p>Однажды человека может разбудить неожиданный звонок с требованием вернуть долг, а в почтовом ящике окажется повестка в суд. Но кредитов он не брал, закон не нарушал.</p>
			<p>Чтобы взять кредит в крупном банке, одних паспортных данных недостаточно: потребуется хотя бы копия документа. А вот оформить микрозаем в интернете можно с помощью сведений с первых страниц паспорта — номера, даты выдачи, кода подразделения и места рождения.</p>
			<p>Обратившись в несколько микрофинансовых организаций, мошенники получат существенную сумму на свои карты — а затем исчезнут, оставив жертву с долгами.</p>
			<p>Пользуясь данными чужого паспорта, мошенники регистрируют фирму-однодневку. Так они безнаказанно творят темные дела: уклоняются от налогов или собирают с обычных людей деньги за предзаказ дорогих товаров.</p>
			<p>Когда обман вскроется, мошенники заберут деньги и останутся вне подозрений — а вот владельцу паспорта придется объясняться с полицией.</p>
			<p>Некоторые интернет-магазины предлагают клиентам покупать товары в рассрочку: чтобы забрать вещь, нужно указать паспортные данные, а оплатить покупку можно позже.</p>
			<p>Это на руку мошенникам: они заказывают товар по чужому документу, а курьеру говорят, что покупку получит другой человек — не владелец паспорта. Предупрежденный курьер спокойно отдает дорогую вещь аферисту, но расплачиваться за нее должен ничего не подозревающий владелец паспорта.</p>
			<p>Если у «заемщика» хорошая кредитная история, рассрочку, скорее всего, одобрят. Правда, техника попадет в руки мошенникам, а расплачиваться придется вам.</p>
			<p>Зная ФИО жертвы и адрес регистрации, мошенники подделывают квитанции на оплату штрафов от государственных органов.</p>
			<p>По номеру паспорта на сайте налоговой службы легко узнать ИНН: этот номер поможет придать письму из налоговой убедительности и сообщить жертве об огромной задолженности.</p>
			<p>Чтобы оплатить «штраф» и избежать суда, аферисты просят как можно скорее воспользоваться вложенной квитанцией.</p>
			<p>Мошенники, которые обманывают людей в интернете, часто просят жертв выслать им деньги на электронный кошелек — поэтому аферистам выгодно использовать чужие данные. Так вся ответственность за мошенничество ляжет на плечи подставного владельца кошелька, а настоящие преступники останутся незамеченными.</p>
			<p>Чтобы изготовить паспорт, которым преступник сможет полноценно пользоваться, недостаточно подделать водяные знаки — паспорт с фальшивыми данными не пройдет ни одну проверку в электронных базах.</p>
			<p>Поэтому мошенники используют информацию из настоящего документа, а фотографию в фальшивый паспорт вклеивают свою. По паспорту с реальными данными, но фотографией афериста можно брать кредиты в мелких организациях, не вызывая подозрений, — а отвечать по долгам придется владельцу настоящего паспорта.</p>
			<p>Выяснить номер телефона по паспортным данным несложно. Многие указывают его на страницах в соцсетях или на страницах-визитках, которые можно найти, просто набрав имя и фамилию жертвы в поисковике.</p>
			<p>Мошенник размещает объявление о продаже дорогой вещи по бросовой цене: утверждает, что надо продать срочно, поэтому и скидка большая. А так как цена привлекательная, то и желающих много, поэтому аферист настаивает на предоплате: чтобы не терять время, если покупатель вдруг передумает. В качестве гарантии липовый продавец высылает скан паспорта — разумеется, чужого, а после получения денег перестает отвечать на сообщения.</p>
			<hr>
			<p><b>Это только цветочки, а бывают и ягодки!</b></p>
			<p><u>Это только для того, чтобы вы относились к безопасности вашего сервера серьёзно! Даже если у вас простенький сайт без каких-либо конфидециальных данных.</u></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h2>2. Введение.</h2>
			<p>Немного напугал, перейдём к теме серверов и их безопасности.</p>
			<p>Защита информации становится необходимостью для предотвращения потенциальных угроз и минимизации рисков.</p>
			<p>Защита информации обеспечивает личную безопасность и приватность, предотвращает утечку личных данных и защищает от возможных мошеннических действий.</p>
			<p>Под термином «угроза» следует понимать любое программное средство, косвенно или напрямую способное нанести ущерб компьютеру, сети, информации или правам пользователя (то есть вредоносные и прочие нежелательные программы). В более широком смысле термин «угроза» может означать любую потенциальную опасность для компьютера или сети (то есть ее уязвимость, которая может быть использована для проведения хакерских атак).</p>
			<p>Сетевая атака – это вторжение в операционную систему удаленного компьютера. Злоумышленники предпринимают сетевые атаки, чтобы захватить управление над операционной системой, привести ее к отказу в обслуживании или получить доступ к защищенной информации.</p>
			<p>Следует понимать, что защита от взлома серверов — это комплекс мер, в том числе подразумевающий постоянный мониторинг работы сервера и работу по совершенствованию защиты. Невозможно защитить сервер от внешнего доступа раз и навсегда, ведь каждый день обнаруживаются новые уязвимости и появляются новые способы взлома сервера.</p>
			<p>Основной признак попыток — «подозрительная активность» в логах. Это могут быть регулярные попытки подключения с разных IP-адресов, запросы к различным портам сервера, запросы на те или иные ресурсы.</p>
			<p>Лог (log) — это текстовый файл, куда автоматически записывается важная информация о работе системы или программы. Чаще всего говорят о логах сервера. Их записывает программное обеспечение, которое управляет внутренней частью сайта или онлайн-системы. Лог-файл — своеобразный журнал событий.</p>
			<p>В логи записываются сведения об ошибках, действиях пользователей и других событиях, которые происходят на сервере или в системе.</p>
			<p>Чтобы обнаружить угрозу, необходимо регулярно анализировать все логи, начиная с системных, и заканчивая логами различных утилит, которые работают на вашем сервере.</p>
			<p>Однако, анализировать логи вручную - не самая лучшая затея, хотя и вполне возможная. Для анализа логов существуют специальнные утилиты автоматического анализа и блокирования несанкционированного доступа. В простейшем случае они анализируют логи на подозрительную активность и при необходимости блокируют все попытки несанкционированного получения доступа на те или иные ресурсы сервера.</p>
			<p><b>Что значит несанкционированного?</b></p>
			<p><b>Несанкционированно</b> - осуществляемый без санкции, официального разрешения. Т.е. в нашем случае при самом простом способе прямого входа на ваш веб-сайт через веб-браузер вы увидите в логах действительные статусы состояний сервера. При любой попытке обойти формы ввода логина и пароля, даже напрямую вручную через браузер, в логи будет выведен совершенно другой статус состояния вашего сайта или всего сервера. При этом там же будут отображены все попытки запросов и все адреса и порты, на которые происходили запросы. В случае же использования любых утилит - не браузеров - эта информация сразу же отобразится в логах.</p>
			<p>Обычно любая утилита или программа (не важно Windows или Linux) во время запроса обязательно вставляет в посылаемый на сервер запрос (пакет) минимальную информацию о себе. В случае же хакерских утилит такой информации не будет.</p>
			<p>Посмотрим на частичный лог одного веб-сайта. IP-ардеса и некоторые другие данные лога я закрасил в целях безопасности.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-1.png" width="800px"/>
			</div>
			<div style="clear:both"></div>
			<p>Мы здесь можем видеть - что некий IP-адрес (пользователь, закрашен в самой левой части перед датой и временем) делает <b>GET</b>-запрос. При этом у адреса есть операционная система, и делает он свой запрос через браузер <b>Google-chrome</b>. Ну и соответственно видим дату и время запроса, а также статус состояния сайта, т.е. ответ веб-сайта.</p>
			<p>Судя по этой скудной информации мы можем сделать вывод о том, что некий пользователь напрямую через веб-браузер, т.е. санкционированно, обращался к некому веб-сайту.</p>
			<p>В последних 2 строках <b>GET</b>-запросы происходили не через браузер и с помощью утилиты <b>Curl</b>. При этом видим также и версию этой утилиты.</p>
			<p>В этих последних строках из-за статуса состояния сайта мы можем сделать вывод о том, что запрос хоть и был санкционированный, но не прямой, т.е. не через веб-браузер, и к этому стоит присмотреться.</p>
			<p>Существуют утилиты не только для автоматического мониторинга работы сервера и его доступности в интернете, но и оповещения по электронной почте или СМС в случае обнаружения проблем.</p>
			<p>Причём располагать утилиты мониторинга доступности сервера в интернете и оповещений непосредственно на самом сервере - не самая лучшая затея, хотя и вполне реализуемая и частенько практикуемая. Практикуемая именно потому что денег на второй сервер только для мониторинга нет. Такие утилиты вполне можно установить на сервер в виртуальной машине, которая будет не доступна из интернета, тем самым защищена. Она же и будет производить мониторинг работы и оповещать в случае проблем. Однако, не все могут оставить работать свой ПК с работающей виртуальной машиной на круглосуточную работу ради одного сервера. Обычно так делают когда серверов много.</p>
			<p>Кстати говоря, любые подобные утилиты мониторинга и оповещений вполне можно создать самостоятельно.</p>
			<p><span style="color:blue;">Сегодня мы с вами рассмотрим одну из утилит для блокировки вторжений на сервер.</span> Рассматривать утилиты оповещений и мониторинга сегодня мы не будем.</p>
			<p>Однако, это не говорит о том, что при использовании утилит блокировок вам не нужно будет использовать утилиты мониторинга или антивирусные средства. Как раз наоборот.</p>
			<p><span style="color:blue;"><u>Просто базовое понимание утилит блокировки даст вам понимание того, как запускать все программы и под-программы мониторинга, блокировок и оповещений одновременно так, чтобы данные получаемые из логов были на тот момент актуальными и одинаковыми для всех утилит. Иначе вы можете столкнуться с тем, что для одной из программ в логах у вас будут одни данные, для другой уже другие. В результате одна из утилит просто не сработает во время. Или вообще пропустит важные данные для обработки результата.</u></span></p>
			<p><span style="color:red;"><b>Чем это чревато? Надеюсь, вы и сами понимаете!</b></span></p>
			<p>Также, этот же момент не говорит о том, что вам всё равно не придётся создавать регулярные резервные копии данных сайта или всего сервера. <u>Потому что взломать можно всё что угодно! Было бы желание.</u> Вот как раз на случай проникновения и/или захвата управления, чтобы иметь возможность быстро восстановить сервер после атаки, как раз и нужны резеревные копии данных.</p>
			<p>Помимо описанного, необходимо регулярно следить за обновлениями программного обеспечения и операционной системы сервера. Обновления обычно устраняют уязвимости, которые могут использоваться для проведения атак.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h2>3. Файловый дескриптор.</h2>
			<p>Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом.</p>
			<p>Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux.</p>
			<p>В Linux библиотека libc открывает для каждого запущенного приложения(процесса) 3 файл дескриптора, с номерами 0,1,2.</p>
			<ul>
				<li>Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения.</li>
				<li>Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print.</li>
				<li>Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.</li>
			</ul>
			<p>Если в вашей программе вы откроете какой-либо файл на чтение или запись, то скорее всего вы получите первый свободный ID и это будет номер 3.</p>
			<p>Файл дескриптор с номером 255 можете смело игнорировать, он был открыт для своих нужд уже самим bash, а не прилинкованной библиотекой.</p>
			<p>Например, откроем консоль с bash и посмотрим PID нашего процесса.</p>
			<div class="codeses">
				<pre><b>[user@localhost Загрузки]$</b> echo $$
11644
<b>[user@localhost Загрузки]$</b> ls -lha /proc/11644/fd/
итого 0
dr-x------ 2 user users  0 июл 22 08:26 .
dr-xr-xr-x 9 user users  0 июл 22 08:26 ..
lrwx------ 1 user users 64 июл 22 08:26 0 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 1 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 2 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 255 -> /dev/pts/1
<b>[user@localhost Загрузки]$</b></pre>
			</div>
			<p>Сейчас все 3 файл дескриптора связаны с устройством псевдотерминала /dev/pts, но мы все равно можем ими манипулировать, например запустим во второй консоли.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> echo "hello world" > /proc/11644/fd/0
			</p>
			<p>И в первой консоли мы увидим.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> hello world
			</p>
			<p>Вы можете легко переопределить эти 3 файл дескриптора в любом процессе, в том числе и в bash, например через трубу(pipe), соединяющую два процесса.</p>
			<p>Продолжение смотрите в статье: <a href="https://habr.com/ru/articles/471038/">&laquo;Файл дескриптор в Linux с примерами&raquo;</a>.</p>
			<p>Нас же интересует немного другой вопрос.</p>
			<p>Приведу небольшой пример.</p>
			<p>У нас есть некий лог-файл, в который постоянно ведётся запись разных данных. Каких данных сейчас не важно. Например, в лог-файл <b>NGINX</b>-а запись будет производиться только при поступления запроса на сервер и только на тот веб-адрес, который имеется в настройках конфигурации.</p>
			<p>Допустим, у нас есть несколько программ в виде коротких скриптов, которые постоянно с разными временными задержками анализируют этот лог-файл.</p>
			<p>Возникает логичный вопрос: А одинаковые ли будут данные у каждого из этих скриптов для анализа?</p>
			<p>Проведём небольшой эксперимент. Для этого создадим 3 разных скрипта. Один будет записывать данные в некий предопределённый нами лог-файл, а 2 других читать этот лог и выводить результат чтения на экран.</p>
			<p>Файл <b>&laquo;./write.sh&raquo;</b>. Здесь мы будет 10 раз записывать время с секундами и наносекундами в лог-файл <b>&laquo;./text.log&raquo;</b>, но с задержкой между записями в 2 секунды. Т.е. итоговое время выполнения, по идее, должно быть 18 секунд, включая вывод на экран.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./write.sh
#!/bin/bash
echo &quot;&quot; &gt; text.log
for x in {1..10}; do
	_date=$(date '+%H:%M:%S:%N')
	_random=$(echo &quot;${_date}&quot; | rev | cut -d ':' -f1 | rev)
	echo "${_date} - ${_random}"
	echo "${_date} - ${_random}" &gt; text.log
	sleep 2
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read.sh&raquo;</b>. Здесь мы будет читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, но вместо простого вывода содержимого на экран будем подсчитать количество строк в этом файле. Читать будем 3 раза с задержкой открытого файла дескриптора на 1 секунду в каждый цикл чтения. Итоговое время выполнения, по идее, должно быть 3 секунды.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 1
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read2.sh&raquo;</b>. Ну а в этом скрипте мы будет читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, также как и в предыдущем примере, но с задержкой файла-дескриптора уже на 2 секунды при каждом цикле чтения. Итоговое время выполнения, по идее, должно быть 6 секунд.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read2.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 2
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Теперь, откроем 3 разных косноли и попытаемся быстро-быстро запустить эти скрипты одновременно. Разумеется они будут работать не одновременно. Однако, из-за временных <b>sleep</b> задержек это будет не важно.</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-2.png" width="1024px"/>
			</div>
			<p>Как видите, и в первой и во второй консоли, из-за того, что скрипты долго держат файловый дескриптор открытым, они продолжают читать старый файл. Таким образом скрипты продолжает использовать старые данные и не успевают получить новые для обработки, в то время как в лог-файл уже была произведена запись и он был обновлён.</p>
			<p>Более того, 2-й скрипт <b>&laquo;./read2.sh&raquo;</b> вообще потерял много данных, а задержка была неоправдано долго и в данном случае именно из-за того, что файловый дескриптор уже был открыт другим процессом, т.е. занятым в этот момент.</p>
			<p>В итоге, из-за такой, казалось бы, простой операции прочитать файл - образовалась маленькая локальная война за ресурсы, в результате которой было потеряно много данных.</p>
			<p>Проблема чтения данных ещё состоит и в том, что практически все утилиты или скрипты анализа лог-файлов могут быть очень разными и сложными, или наоборот простыми. <u>Какие-то из них потребляют мало оперативной памяти, а какие-то напротив - очень много.</u></p>
			<p><u>Уменьшать время работы одной из утилит ради ускорения обработки данных очень и очень плохая затея!</u> Ведь таким образом вы можете чрезмерно нагрузить и процессор и оперативную память. А если у вас VPS или VDS сервер с ограниченным количеством ресурсов - в результате вы можете просто напросто зависнуть. Да-да, в Linux-е и зависнуть. Это не шутка!</p>
			<p><span style="color:purple;"><b>Этот маленький эксперимент должен был сказать вам</span> <span style="color:blue;"><u><i>не о том</i></u></span></b>, что необходимо уменьшать время запуска тех или иных программ или скриптов анализа, <b><span style="color:blue;"><u><i>а о том</i></u></span></b>, <b><span style="color:red;">что анализировать данные лучше какой-то одной единственной утилитой, и уже в ней, внутри, запускать все остальные необходимые вам внешние скрипты и программы обработки результатов, при обнаружении проблем.</span> </span> <span style="color:green;">При условии, что такая функция запуска внешних скриптов или программ имеется внутри утилиты анализа.</b></span></p>
			<p>Обычно, у всех программ и утилит анализа имеются специальные макросы для запуска внешних программ или скриптов для обработки результатов или запуска какого-нибудь действия / противодействия в самой ОС.</p>
			<p>Если же возможности самого анализа как такового ограничены - тогда да, запуск отдельной программы или отдельного скрипта в системе по таймеру - будет хорошим выходом из ситуации.</p>
			<p>Но, тогда вы, скорее всего, будете вынуждены подбирать и калибровать время запуска по таймеру только ради 2 вышеуказанных условий - аткуальность данных и нагрузка на оперативную память.</p>
			<p>Актуальность данных подразумевает несколько важных пунктов.</p>
			<ul>
				<li>Как часто обновляется нужный вам лог-файл, т.е. как часто в него записываются новые данные?</li>
				<li>Как часто необходимо анализировать лог-файл?</li>
			</ul>
			<p>В зависимости от данных ответов настраивается время таймера.</p>
			<p>Нагрузка же на процессор имеет немного более высокий приоритет. Для корректной настройки вам также необходимо будет ответить на пару вопросов.</p>
			<ul>
				<li>Сколько максимально в пике оперативной памяти потребляет ваша утилита или скрипт?</li>
				<li>Как сильно ваша утилита или скрипт нагружают процессор?</li>
			</ul>
			<p>Последние 2 вопроса имеют место быть, в случае, когда утилита имеет внутри себя множество различных сложных вычислений. В таком случае стоит задуматься насчет частоты запуска и соответственно об увеличении времени таймера для её запуска.</p>
			<p>При этом как именно будет запускаться утилита или скрипт не особо играет роли - будь то системный <b>systemd-таймер</b> или процесс запущенный из под сервиса <b>cron</b>, т.е. <b>crontab</b>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>4. Межсетевые экраны.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava { 
					counter-reset: list1; /* Список первого уровня*/ 
				} 
				.glava li:before { /* Список первого уровня */ 
					counter-increment: list1; /* Увеличиваем значение счетчика */ 
					content: "4." counter(list1) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava">
				<li><a href="#part4.1">История, определения.</a></li>
				<li><a href="#part4.2">Netfilter</a></li>
				<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
				<li><a href="#part4.4">NFTABLES.</a></li>
				<li><a href="#part4.5">UFW / Firewalld.</a></li>
				<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
			</ol>
			<hr>
			<p><a name="part4.1"></a></p>
			<h3>4.1. История, определения.</h3>
			<p>Рассмотрим первую линию обороны - межсетевые экраны.</p>
			<p>Брандмауэр, фаервол или межсетевой экран – это система, которая выполняет роль защитной стены между глобальным интернетом и устройством пользователя.</p>
			<p>Брандмауэр фильтрует всю входящую информацию и не пропускает вредоносный контент и вирусы.</p>
			<p>Брандмауэры, как правило, контролируют двунаправленный поток трафика, поэтому представьте себе брандмауэр перед организацией, отделяющий ее от общедоступного Интернета. Он должен иметь возможность блокировать входящий трафик, чтобы попытаться удержать злоумышленников, но он также должен иметь возможность разрешать исходящий трафик, потому что людям нужно просматривать веб-страницы, отправлять электронные письма и иметь связь, которая выходит за пределы сети.</p>
			<p>Наиболее распространённое место для установки межсетевых экранов — граница периметра локальной сети для защиты внутренних хостов от атак извне. Однако атаки могут начинаться и с внутренних узлов — в этом случае, если атакуемый хост расположен в той же сети, трафик не пересечёт границу сетевого периметра, и межсетевой экран не будет задействован. Поэтому в настоящее время межсетевые экраны размещают не только на границе, но и между различными сегментами сети, что обеспечивает дополнительный уровень безопасности.</p>
			<p>Программные межсетевые экраны появились существенно позже и были гораздо моложе, чем антивирусные программы. Например, проект <b>&laquo;Netfilter/iptables&raquo;</b> (один из первых программных межсетевых экранов, встраиваемых в ядро <b>Linux</b> с версии <b>2.4</b>) был основан <b>в 1998 году</b>.</p>
			<p>Фильтрация трафика осуществляется на основе набора предварительно сконфигурированных правил, которые называются ruleset. Удобно представлять межсетевой экран как последовательность фильтров, обрабатывающих информационный поток. Каждый из фильтров предназначен для интерпретации отдельного правила. Последовательность правил в наборе существенно влияет на производительность межсетевого экрана. Например, многие межсетевые экраны последовательно сравнивают трафик с правилами до тех пор, пока не будет найдено соответствие.</p>
			<p>Существует два принципа обработки поступающего трафика. Первый принцип гласит: «Что явно не запрещено, то разрешено». В данном случае, если межсетевой экран получил пакет, не попадающий ни под одно правило, то он передаётся далее. Противоположный принцип — «Что явно не разрешено, то запрещено» — гарантирует гораздо большую защищённость, так как он запрещает весь трафик, который явно не разрешён правилами. Однако этот принцип оборачивается дополнительной нагрузкой на администратора.</p>
			<p>В конечном счёте межсетевые экраны выполняют над поступающим трафиком одну из двух операций: пропустить пакет далее (allow) или отбросить пакет (deny). Некоторые межсетевые экраны имеют ещё одну операцию — reject, при которой пакет отбрасывается, но отправителю сообщается о недоступности сервиса, доступ к которому он пытался получить. В противовес этому, при операции deny отправитель не информируется о недоступности сервиса, что является более безопасным.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.2"></a></p>
			<h3>4.2. Netfilter.</h3>
			<p>Посмотрим на компаненты, которые входят в состав <b>Netfilter</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/Netfilter-components.png" width="800px"/>
			</div>
			<p>Все компаненты обозначенные голубым цветом - это пользовательские утилиты, т.е. програмная часть, с помощью которых осуществляется доступ к нижележащим таблицам фильтрации и преобразования пакетов. У <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в итоге к <b>&laquo;Xtables&raquo;</b>, соответственно у <b>&laquo;iptables-nftables&raquo;</b> и <b>&laquo;nft&raquo;</b> к <b>&laquo;nf_tables&raquo;</b>.</p>
			<p>Долгое время <b>&laquo;Xtables&raquo;</b>, встроенная в ядро, считалась единственным способом управления <b>Netfilter</b>-ом.</p>
			<p><b>iptables</b> — утилита командной строки для настройки встроенного в ядро Linux межсетевого экрана, разработанного в рамках проекта <b>Netfilter</b>.</p>
			<p>Термином iptables также часто называют сам межсетевой экран в ядре. Настройка экрана выполняется либо напрямую с помощью iptables, либо через один из фронтендов, консольных или графических. iptables работает с протоколом IPv4, для IPv6 разработана утилита ip6tables. В основном их синтаксис совпадает, но некоторые специфичные для протоколов опции различаются.</p>
			<p>Тем временем постепенно развивался проект <b>&laquo;nf_tables&raquo;</b>. Проект должен и выступил в качестве замены существующего фреймворка <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в 2021 году.</p>
			<p>Этот проект предоставляет новую систему фильтрации пакетов, пользовательскую утилиту ntf, а также слой совместимости с {ip,ip6}tables. nftables использует существующие хуки, отслеживание соединений, очереди в пространстве пользователя и подсистему логирования netfilter.</p>
			<p>Фреймворк iptables постепенно выходит из употребления; более современная замена — nftables, в котором предусмотрен слой совместимости.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-3.png" width="717px"/>
			</div>
			<p>В <b>Debian 11</b> фреймворк <b>nftables</b> встроен в систему по умолчанию со слоем совместимости для <b>iptables</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-4.png" width="717px"/>
			</div>
			<p><b>IPTABLES</b> умер в 2021 году. Он конечно всё ещё встроен во многие системы, но постепенно будет полностью заменён на более эффективный <b>NFTABLES</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/iptables-rip.png" width="277px"/>
			</div>
			<div style="clear:both"></div>
			<br>
			<hr>
			<p><u>Плохая новость:</u> документация <b>&laquo;NFTABLES&raquo;</b> (&laquo;nft&raquo;: man nft) содержит больше 3 тысяч строк.</p>
			<hr>
			<p>Для облегчения перехода можно конвертировать правила <u><i>iptables</i></u> в <u><i>nftables</i></u> с помощью утилит <u><i>iptables-translate</i></u>, <u><i>iptables-restore-translate</i></u>, <u><i>iptables-nft-restore</i></u> и т.п. Утилиты находятся в пакете <u><i>iptables</i></u>, который необходимо установливать отдельно.</p>
			<p>Грубо говоря, <b>Netfilter</b> по сути является как бы внутренней обороной ОС. Однако, самой ОС нужна ещё и внешняя оборона - инструмент или средство для управления брандмауэром, такие как <b>UFW</b> или <b>Firewalld</b>.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> - является самым простым и довольно популярным инструментарием командной строки для настройки и управления брандмауэром.</p>
			<p><b>Firewalld</b> — программное обеспечение для управления брандмауэрами, поддерживаемое многими дистрибутивами <b>Linux</b>.</p>
			<p>Чтобы понять как работает фильтрация пакетов в межсетевых экранах, для этого надо заглянуть в раздел <a href="#part4.3"><b>&laquo;Таблицы и цепочки IPTABLES&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.3"></a></p>
			<h3>4.3. Таблицы и цепочки IPTables.</h3>
			<p>Чтобы разобрать работу <b>Netfilter/iptables</b> возьмём схему работы из википедии.</p>
			<div class="images">
				<img src="../image/Blacklists-image/netfilter-diagram.png" width="400px"/>
			</div>
			<p>Ну, а для базового понимания схемы разберём с вами основные понятия: <i>таблицы, цепочки, действия над пакетами и механизм определения состояния</i>.</p>
			<p><u>Каждый из пунктов важен для понимания работы любого межсетевого экрана.</u></p>
			<p><b>Цепочки.</b></p>
			<ul>
				<li><b>PREROUTING</b> - для изначальной обработки входящих пакетов.</li>
				<li><b>INPUT</b> - для входящих пакетов, адресованных непосредственно локальному компьютеру.</li>
				<li><b>FORWARD</b> - для проходящих (маршрутизируемых) пакетов.</li>
				<li><b>OUTPUT</b> - для пакетов, создаваемых локальным компьютером, т.е. исходящих.</li>
				<li><b>POSTROUTING</b> - для окончательной обработки исходящих пакетов.</li>
			</ul>
			<p>Цепочки можно создавать самостоятельно, и также их уничтожать.</p>
			<p><b>Почти в каждой цепочке имеется 4 таблицы:</b></p>
			<ul>
				<li><b>raw</b> - пакет проходит данную таблицу до передачи системе определения состояний. Используется редко, например для маркировки пакетов, которые НЕ должны обрабатываться системой определения состояний. Для этого в правиле указывается действие NOTRACK. Содержитcя в цепочках PREROUTING и OUTPUT.</li>
				<li><b>mangle</b> - содержит правила модификации IP‐пакетов. Среди прочего, поддерживает действия TTL, TOS, и MARK (для изменения полей TTL и TOS, и для изменения маркеров пакета). Редко необходима и может быть опасна.</li>
				<li><b>nat</b> - предназначена для подмены адреса отправителя или получателя. Данную таблицу проходят только первый пакет из потока, трансляция адресов или маскировка (подмена адреса отправителя или получателя) применяются ко всем последующим пакетам в потоке автоматически. Поддерживает действия <i>DNAT</i>, <i>SNAT</i>, <i>MASQUERADE</i>, <i>REDIRECT</i>. Содержится в цепочках <i>PREROUTING</i>, <i>OUTPUT</i>, и <i>POSTROUTING</i>.</li>
				<li><b>filter</b> - основная таблица, используется по умолчанию если название таблицы не указано. Используется для фильтрации пакетов. Содержится в цепочках INPUT, FORWARD, и OUTPUT.</li>
			</ul>
			<p><b>Действия над пакетами.</b></p>
			<ul>
				<li><b>ACCEPT</b> - принять пакет.</li>
				<li><b>DROP</b> - отбросить пакет, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>REJECT</b> - отбросить пакет, отправив отправителю ICMP-сообщение, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>RETURN</b> - возвратить пакет в предыдущую цепочку и продолжить ее прохождение начиная со следующего правила.</li>
				<li><b>SNAT</b> - применить трансляцию адреса источника в пакете. Может использоваться только в цепочках <b>POSTROUTING</b> и <b>OUTPUT</b> в таблицах <b>nat</b>.</li>
				<li><b>DNAT</b> - применить трансляцию адреса назначения в пакете. Может использоваться в цепочке <b>PREROUTING</b> в таблице <b>nat</b>.</li>
				<li><b>LOG</b> - протоколировать пакет и обработать остальными правилами.</li>
				<li><b>MASQUERADE</b> - используется вместо <b>SNAT</b> при наличии соединения с динамическим <b>IP</b> (допускается указывать только в цепочке <b>POSTROUTING</b> таблицы <b>nat</b>).</li>
				<li><b>MARK</b> - используется для установки меток на пакеты, передается для обработки дальнейшим правилам.</li>
			</ul>
			<p>Есть и другие действия. Остановимся на базовых.</p>
			<p><b>Механизм определения состояний (conntrack).</b></p>
			<p>В общем, механизм определения состояний (он же state machine, он же connection tracking, он же conntrack) является частью пакетного фильтра и позволяет определить определить к какому соединению/сеансу принадлежит пакет.</p>
			<p><b>Conntrack</b> анализирует состояние всех пакетов, кроме тех, которые помечены как NOTRACK в таблице raw. На основе этого состояния определяется принадлежит пакет новому соединению (состояние NEW), уже установленному соединению (состояние ESTABLISHED), дополнительному к уже существующему (RELATED), либо к "другому" (неопределяемому) соединению (состояние INVALID). Состояние пакета определяется на основе анализа заголовков передаваемого TCP-пакета. Модуль conntrack позволяет реализовать межсетевой экран сеансового уровня (пятого уровня модели OSI). Для управления данным механизмом используется утилита conntrack, а так же параметр утилиты iptables: -m conntrack или -m state. Состояния текущих соединений conntrack хранит в ядре. Их можно просмотреть в файле /proc/net/nf_conntrack (или /proc/net/ip_conntrack).</p>
			<hr>
			<p>Итак, разберём схему работы.</p>
			<p>Пакет (из интернета в сеть, затем) из сети обязательно проходит цепочку <b>PREROUTING</b>, далее попадает в таблицу маршрутизации и в зависимости от принадлежности определяет куда пойдёт дальше. Если пакет не адресован локальной системе, он попадёт в цепочку <b>FORWARD</b>. Если адресован - в цепочку <b>INPUT</b>. После <i>INPUT</i> пакет обрабатывают системные процессы и демоны. После локальной обработки программы могут сформировать ответ и этот ответ в соответствии с правилами маршрутизации направляется в цепочку <b>OUTPUT</b>. Затем снова маршрутизируется и наконец попадает в цепочку <b>POSTROUTING</b>, как и пакет из цепочки <b>FORWARD</b>. И только после всех этих манипуляций с пакетом он наконец вновь отправляется обратно в сеть и уже дальше в интернет, если стоит такая задача.</p>
			<p><b>Почему пакет несколько раз проходит через таблицу маршрутизации?</b></p>
			<p>Каждая цепочка, которую проходит пакет состоит из набора таблиц (table). Таблицы в разных цепочках имеют одинаковое наименование, но тем не менее никак между собой не связаны. Например таблица nat в цепочке PREROUTING никак не связана с таблицей nat в цепочке POSTROUTING. Каждая таблица состоит из упорядоченного  набора (списка) правил. Каждое правило содержит условие, которому должен соответствовать проходящий пакет и действия к пакету, подходящему данному условию.</p>
			<p>Проходя через серию цепочек пакет последовательно проходит каждую таблицу и в каждой таблице последовательно сверяется с каждым правилом, и если пакет соответствует какому-либо критерию, то выполняется заданное действие над пакетом. При этом, в каждой таблице (кроме пользовательских) существует заданная по-умолчанию политика. Данная политика определяет действие над пакетом, в случае, если пакет не соответствует ни одному из правил в таблице. Чаще всего - это действие ACCEPT, чтобы принять пакет и передать в следующую таблицу или DROP - чтобы отбросить пакет. В случае, если пакет не был отброшен, он завершает свое путешествие по ядру системы и отправляется в сетевой интерфейс, которая подходит по правилам маршрутизации.</p>
			<p><u>Таблица <b>nat</b> и <b>mangle</b> может модифицировать получателя или отправителя сетевого пакета. Именно поэтому сетевой пакет несколько раз сверяется с таблицей маршрутизации.</u></p>
			<p>Блокировку и разблокировку ip-адресов, разрешающие и запрещающие правила, а также сохранение состояния при перезагрузке <b>ОС</b> вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part6"><b>&laquo;Безопасность сетевых соединений: 6. Блокировка ip адреса или всей подсети&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.4"></a></p>
			<h3>4.4. NFTABLES.</h3>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные таблицы. Количество таблиц и их имена определяется пользователем. Тем не менее, каждая таблица имеет только одно семейство адресации и применяется к пакетам только этого семейства.</p>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные цепочки. Соответственно, если опрелённые типы или хуки фреймворка <b>netfilter</b> не задействованы ни в одной цепочке, то проходящие через эти цепочки пакеты обрабатываться не будут (в отличие от <b>iptables</b>).</p>
			<p>Есть два типа цепочек. Базовая цепочка является точкой входа для пакетов из сетевого стека; в ней указывается хук. Обычная цепочка может использоваться в качестве цели перехода и используется для лучшей организации правил.</p>
			<p>Все спрашивают почему я так люблю <b>Acrhlinux</b> - как минимум за его прекрасную векипедию. Поэтому более подробную информацию о работе с <b>NFTABLES</b> вы можете найти на его страницах в статье: <a target="_blank" href="https://wiki.archlinux.org/title/Nftables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: nftables (Русский)&raquo;</b></a>, а если вам будет мало этой информации и у вас по прежнему останутся пару вопросов - добро пожаловать в статью на losst.pro: <a target="_blank" href="https://losst.pro/kak-polzovatsya-nftables"><b>&laquo;losst.pro: Как пользоваться nftables&raquo;</b></a>.</p>
			<p>В этих статья подробно с разъяснено как работать с <b>NFTABLES</b>. Словом, мне дополнить нечем. Читайте внимательно, тогда ничего не пропустите и вам всё будет понятно.</p>
			<p>Разьве что <u>раздел установки для разных дистрибутивов <b>Linux</b> будет у всех разный. Во всём остальном - и настройки и работа с фреймворком будет абсолютно одинаковой.</u></p>
			<p><b>Но самое главное в том, что знание схемы движения пакетов в системе IP(6)TABLES даёт вам базовое понимание того, какие таблицы и цепочки с предопределёнными типами и хуками для работы вашего сервера нужно будет создавать, а также какие правила и приоритеты устанавливать для этих цепочек. Понимание работы IP(6)TABLES значительно ускоряет процес настройки.</b></p>
			<p>Также уделите внимание <b>Firewalld</b>, ибо с ним, вам в разы меньше придётся создавать различных таблиц, цепочек и правил поведения вашего сервера, включая <b>nat</b>-преобразование адресов, в разы будет усилена защита, но также может и в разы усложниться жизнь при работе с различными сервисами в т.ч. базами данных.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.5"></a></p>
			<h3>4.5. UFW / Firewalld.</h3>
			<p>Cерверы постоянно подвергаются различным атакам или сканируются в поиске уязвимостей. Как только эти уязвимости находятся, мы рискуем стать частью ботнета, раскрыть конфиденциальные данные или потерять деньги из-за сбоев в работе веб-приложений. Одной из первых мер по снижению рисков безопасности является грамотная настройка правил межсетевого экрана.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> — удобный интерфейс для управления политиками безопасности межсетевого экрана. Он представляет собой интерфейс iptables, предназначенный для упрощения процесса настройки брандмауэра. Хотя iptables — надежный и гибкий инструмент, начинающим бывает сложно научиться использовать его для правильной настройки брандмауэра.</p>
			<p>Подробно об установке и настройке <b>UFW</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part4.1"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.1. Фаервол UFW&raquo;</b></a>.</p>
			<p>По сути <b>UFW</b> и <b>Firewalld</b> это фасад сервера, а <b>{IP,IP6,ARP,EB}Tables / NFTables</b> - это интерьер.</p>
			<p><b>Firewalld</b> - более продвинутая утилита управления <b>Linux</b> брандмауэром <b>Netfilter</b>. Несмотря на собственный синтаксис, имеет такой же принцип работы, как и <b>Iptables</b>.</p>
			<p>В отличие от <b>IPTABLES</b> имеет более продвинутую безопасность, настройки, стабильную работу, а также сохранение правил фильтрации и маршрутизации без лишних скриптов и сервисов, и многое другое.</p>
			<p>Подробно об установке и настройке <b>Firewalld</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part4.2"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.2. Фаервол Firewalld&raquo;</b></a>.</p>
			<p><b>Удивительно, но Docker не работает из коробки с “Universal Firewall” Linux, или UFW.</b></p>
			<p>Проблема в том, что <b>UFW</b> и <b>Docker</b> пытаются изменить одни и те же базовые правила брандмауэра, и этот конфликт требует дополнительной настройки, если вы хотите запустить <b>UFW</b> и <b>Docker</b> вместе.</p>
			<p>Если вы настроите базовый брандмауэр <b>UFW</b> на запрет по умолчанию и разрешение <i>HTTP</i> и <i>SSH</i>, это будет выглядеть безопасным, но не будет блокировать запуск контейнеров <b>Docker</b>, привязанных к другим портам.</p>
			<p>Эту проблему может быть трудно обнаружить, поскольку <b>UFW</b> и <b>Docker</b> – это отдельные системы.</p>
			<p>Тем не менее, <b>UFW</b> покажет правило брандмауэра как правильно внесенное в белый список, и оно, конечно, будет видно вам с вашего места, внесенного в белый список.</p>
			<p>Но если оно запущено через <b>Docker</b>, то по умолчанию оно будет видно на порту 8000 из любого места.</p>
			<p>Это может стать серьезной проблемой, если вы не решите ее.</p>
			<p>Для совмещения <b>Docker</b>-а и фаервола <b>UFW</b> воспользуйтесь статьёй: <a href="https://itsecforu.ru/2022/07/06/%F0%9F%90%B3-%D0%BA%D0%B0%D0%BA-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-docker-%D1%81-ufw-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE/"><b>&laquo;Как использовать Docker с UFW параллельно&raquo;</b></a>.</p>
			<p>Однако, не спешите переходить по ссылке. В данной статье используются решения, основанные на <b>IPTABLES</b>, фреймворке, который постепенно выходит из употребления. В итоге его заменит другое фреймворк - <b>NFTABLES</b>.</p>
			<p><u>Не факт, что у вас получится, но если получится - вы счастливчик.</u> Но, не спешите радоваться. Ибо ваша настройка продержится максимум лет 5...10, пока последний фреймворк полностью не заместит всеми любимый <b>IPTABLES</b>.</p>
			<p>В свою очередь <b>Firewalld</b> требует тщательной настройки и понимания как всё устроено! А самое главное - он легко совмещается с <b>Docker</b>-ами.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.6"></a></p>
			<h3>4.6. Примеры использования UFW / Firewalld.</h3>
			<p>Вот тут начинается самое интересное!</p>
			<p>Рассмотрим с вами несколько примеров на основе моего <b>Archlinux</b> на ноутбуке и виртуальной машине на <b>Debian 11</b> со следующими характеристиками:</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-5.png" width="1024px"/>
			</div>
			<p>Самое главное здесь то, что <u>сеть</u> установлена <u>в режиме сетевого моста</u>. Таким образом, если в <b>ОС</b> нет никаких фаерволов, кроме межсетевого экрана, то все внутренние сервисы должны быть доступны в локальной сети по <b>IP</b>-адресу, буквально напрямую.</p>
			<p>Последовательно произведём все, почте без исключения, настройки по порядку, согласно статье: <a href="https://maximalisimus.github.io/Articles/webpage/Configuratons_Linux_Servers.html#oglavlenie"><b>&laquo;Базовые настройки серверов Linux&raquo;</b></a>, но установим и настроим, пока что, фаервол <b>UFW</b>.</p>
			<p>В <b>Docker</b> установим 2 сервиса: <b>Whoogle</b> и <b>Portainer</b> - как наиболее простые для проведений тестов. К первому проще всего прикрутить <b>NGINX</b> и <b>Fail2ban</b>, а с помощью второго будет легче следить за всеми контейнерами.</p>
			<p>Запуск <b>Portainer</b>-а:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir -p portainer-data && cd portainer-data
<b>$</b> nano docker-compose.yml
version: &quot;3&quot;

volumes:
  portainer_data:

services:

  portainer:
    image: portainer/portainer-ce
    container_name: portainer
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    ports:
      - 9000:9000
      - 8000:8000
    restart: always

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<p>Запуск <b>Whoogle</b>:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir whoogle && cd whoogle
<b>$</b> nano docker-compose.yml
---
version: '2'
services:
	whoogle:
		image: benbusby/whoogle-search:latest
		container_name: whoogle
		ports:
			- 5000:5000
		restart: unless-stopped

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<br>
			<div class="images">
				<img src="../image/Blacklists-image/bls-6.png" width="1024px"/>
			</div>
			<p>Без вышеупомянутого совмещения <b>Docker</b>-а и <b>UFW</b> все внутренние сервисы <b>Docker</b>-а будут доступны за пределами вашего сервера.</p>
			<p>Проверить последнее утверждение не составит никакого труда. Можно это сделать с помощью браузера, а можно воспользоваться утилитой <b>Curl</b>, которая вернёт нам статусное состояние нашего <b>NGINX</b>.</p>
			<p>Т.е. если мы увидим в консоли ответ в виде числа <u><b>200</b></u> - значит и в браузере мы увидим сайт или сервис виртуальной машины, расположенный по запрашиваемому веб-адресу.</p>
			<p>При числах - вроде 1xx или 3xx - скорее всего мы сами запрашиваем неправильно, например веб-адрес.</p>
			<p>При числах - 4xx и 5xx - это ошибки в запросе и ошибки сервера.</p>
			<p>А вот если у нас будет число <u><b>000</b></u> - это будет значит сразу 3 вещи:</p>
			<ul>
				<li>Сервис не доступен за фаерволом.</li>
				<li>Настройка фаервола выполнена верно.</li>
				<li>и <b>Docker</b> с фаерволом вполне неплохо ужились на одном сервере.</li>
			</ul>
			<p>Команда <b>curl</b> выглядит следующим образом:</p>
			<p class="codes">
				curl -s -o /dev/null -w "%{http_code}\n" веб-адрес
			</p>
			<p>Например.</p>
			<p class="codes">
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120/<br>
				<span style="color:blue;"># и</span></br>
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120:9000/</br>
				<span style="color:blue;"># т.к. запущен сервис и whoogle и portainer</span>
			</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-7.png" width="1024px"/>
			</div>
			<p>Без указанного совмещения всё печально. Все сервисы, какие бы у вас не были запущены будут доступны за пределами сервера - и базы данных (MySQL / MariaDB) и сервисы доступа к последним (PHPMyAdmin) и многое другое, что вы не хотели бы выпускать в открытый доступ в интернет.</p>
			<p>Однако, есть выход - <b>Firewalld</b>.</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part5"></a></p>
			<h2>part-5</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			«»
			&laquo;&raquo;
			<b></b>
			<p><b>&laquo;&raquo;</b></p>
			<p class="codes">
				$ Codes</br>
				<span style="color:blue;"># Comment <b>at</b>, the number <b>of</b></span></br>
				<span style="color:blue;"># </span></br>
			</p>
			<div class="codeses">
				<pre>
def myfunc:
	pass
				</pre>
			</div>
			<div class="codeses">
				<pre>
<span style="color:blue;">#!/bin/bash</span>
...
script
...
<span style="color:blue;"># echo "result"</span>
				</pre>
			</div>
			<ul>
				<li><span style="color:Blue;">Blue</span></li>
				<li>Black</li>
				<li><span style="color:Red;">Reed</span></li>
				<li><span style="color:Yellow;">Yellow</span></li>
				<li><span style="color:Green;">Green</span></li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h1>Part-2 H1</h1>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<div class="images">
				<img src="../image/Blacklists-image/image.png" width="800px"/>
			</div>
			<div id="page" class="clearfix">
				<img src="../image/Blacklists-image/image.jpg" class="fz__minimized" alt="клик для увеличения" title="Title" />
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h1>Part-3 H1</h1>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
						
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
