<html>
<head>
	<meta charset="utf-8">
	<title>Чёрный список Чёрной Бороды.</title>
	<link rel="icon" href="../image/Blacklists-image/blacklists-logo.ico">
	<!--
		<link rel="icon" href="image/favicon.png">
		<link rel="shortcut icon" href="js-css/404-2.ico" Type="image/x-icon">
		type="image/png"
		<link rel="shortcut icon" href="favicon.png" type="image/png">
		<link rel="icon" href="image/favicon.svg" type=" image/svg+xml">
	-->
	<link rel="stylesheet" href="../html/main.css" type="text/css">	
	<link rel="stylesheet" href="../html/zoom.css" type="text/css">
	<link rel="stylesheet" href="../html/table.css" type="text/css">
	<link rel="stylesheet" href="../html/frame.css">
	<link rel="stylesheet" href="../html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="../html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="../html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Чёрный список Чёрной Бороды.</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="../image/Blacklists-image/firewall-network-security-scaled.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<center>
				<h1>Большое руководство по чёрным спискам IP-адресов.</h1>
			</center>
			<p>Для начала давайте с вами определимся с основными понятиями:</p>
			<ul>
				<li>Что такое угроза?</li>
				<li>Что такое признак атаки?</li>
				<li>Как узнать о том, что сервер находится в большой опасности?</li>
				<li>Что вообще такое фаервол, и какие они бывают в <b>Linux</b>-ах.</li>
				<li>И многое другое ...</li>
			</ul>
			<p>После чего посмотрим каким образом блокировать и разблокировать угрозы безопасности.</p>
			<p>Далее определимся с пониятием черных и белых списков и зачем они вообще нужны.</p>
			<p>Посмотрим с вами на реальные примеры и виртуального и реального (<b>VPS</b>) серверов.</p>
			<p>И наконец, на примере виртуального сервера в разы усилим его безопасность.</p>
			<p>Итак, приступим.</p>
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Что можно сделать с украденными личными данными?</a></li>
				<li><a href="#part2">Введение.</a></li>
				<li><a href="#part3">Одновременный доступ к файлам журналов.</a></li>
				<li><a href="#part4">Межсетевые экраны.</a></li>
				<ol>
					<li><a href="#part4.1">История, определения.</a></li>
					<li><a href="#part4.2">Netfilter.</a></li>
					<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
					<li><a href="#part4.4">NFTABLES.</a></li>
					<li><a href="#part4.5">UFW / Firewalld.</a></li>
					<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
				</ol>
				<li><a href="#part5">Fail2ban.</a></li>
				<ol>
					<li><a href="#part5.1">Оперативная память.</a></li>
				</ol>
				<li><a href="#part6">NGINX / Nginx Proxy Manager.</a></li>
				<li><a href="#part7">Черный и белый списки.</a></li>
				<ol>
					<li><a href="#part7.1">Черный и белый список. Введение.</a></li>
					<li><a href="#part7.2">Скрипты.</a></li>
					<li><a href="#part7.3">Версии скриптов.</a></li>
					<li><a href="#part7.4">Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</a></li>
					<li><a href="#part7.5">Работа с логами, командами и выводом информации.</a></li>
					<li><a href="#part7.6">Работа с черным и белым списками.</a></li>
					<li><a href="#part7.7">IP(6)TABLES / NFTABLES.</a></li>
					<li><a href="#part7.8">Работа с таблицами и цепочками.</a></li>
					<li><a href="#part7.9">Сервисные команды скрипта.</a></li>
					<li><a href="#part7.10">Systemd.</a></li>
				</ol>
				<li><a href="#part8">Использование скриптов в Fail2ban.</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Что можно сделать с украденными личными данными?</h2>
			<p>Однажды человека может разбудить неожиданный звонок с требованием вернуть долг, а в почтовом ящике окажется повестка в суд. Но кредитов он не брал, закон не нарушал.</p>
			<p>Чтобы взять кредит в крупном банке, одних паспортных данных недостаточно: потребуется хотя бы копия документа. А вот оформить микрозаем в интернете можно с помощью сведений с первых страниц паспорта — номера, даты выдачи, кода подразделения и места рождения.</p>
			<p>Обратившись в несколько микрофинансовых организаций, мошенники получат существенную сумму на свои карты — а затем исчезнут, оставив жертву с долгами.</p>
			<p>Пользуясь данными чужого паспорта, мошенники регистрируют фирму-однодневку. Так они безнаказанно творят темные дела: уклоняются от налогов или собирают с обычных людей деньги за предзаказ дорогих товаров.</p>
			<p>Когда обман вскроется, мошенники заберут деньги и останутся вне подозрений — а вот владельцу паспорта придется объясняться с полицией.</p>
			<p>Некоторые интернет-магазины предлагают клиентам покупать товары в рассрочку: чтобы забрать вещь, нужно указать паспортные данные, а оплатить покупку можно позже.</p>
			<p>Это на руку мошенникам: они заказывают товар по чужому документу, а курьеру говорят, что покупку получит другой человек — не владелец паспорта. Предупрежденный курьер спокойно отдает дорогую вещь аферисту, но расплачиваться за нее должен ничего не подозревающий владелец паспорта.</p>
			<p>Если у «заемщика» хорошая кредитная история, рассрочку, скорее всего, одобрят. Правда, техника попадет в руки мошенникам, а расплачиваться придется вам.</p>
			<p>Зная ФИО жертвы и адрес регистрации, мошенники подделывают квитанции на оплату штрафов от государственных органов.</p>
			<p>По номеру паспорта на сайте налоговой службы легко узнать ИНН: этот номер поможет придать письму из налоговой убедительности и сообщить жертве об огромной задолженности.</p>
			<p>Чтобы оплатить «штраф» и избежать суда, аферисты просят как можно скорее воспользоваться вложенной квитанцией.</p>
			<p>Мошенники, которые обманывают людей в интернете, часто просят жертв выслать им деньги на электронный кошелек — поэтому аферистам выгодно использовать чужие данные. Так вся ответственность за мошенничество ляжет на плечи подставного владельца кошелька, а настоящие преступники останутся незамеченными.</p>
			<p>Чтобы изготовить паспорт, которым преступник сможет полноценно пользоваться, недостаточно подделать водяные знаки — паспорт с фальшивыми данными не пройдет ни одну проверку в электронных базах.</p>
			<p>Поэтому мошенники используют информацию из настоящего документа, а фотографию в фальшивый паспорт вклеивают свою. По паспорту с реальными данными, но фотографией афериста можно брать кредиты в мелких организациях, не вызывая подозрений, — а отвечать по долгам придется владельцу настоящего паспорта.</p>
			<p>Выяснить номер телефона по паспортным данным несложно. Многие указывают его на страницах в соцсетях или на страницах-визитках, которые можно найти, просто набрав имя и фамилию жертвы в поисковике.</p>
			<p>Мошенник размещает объявление о продаже дорогой вещи по бросовой цене: утверждает, что надо продать срочно, поэтому и скидка большая. А так как цена привлекательная, то и желающих много, поэтому аферист настаивает на предоплате: чтобы не терять время, если покупатель вдруг передумает. В качестве гарантии липовый продавец высылает скан паспорта — разумеется, чужого, а после получения денег перестает отвечать на сообщения.</p>
			<hr>
			<p><b>Это только цветочки, а бывают и ягодки!</b></p>
			<p><u>Это только для того, чтобы вы относились к безопасности вашего сервера серьёзно! Даже если у вас простенький сайт без каких-либо конфидециальных данных.</u></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h2>2. Введение.</h2>
			<p>Немного напугал, перейдём к теме серверов и их безопасности.</p>
			<p>Защита информации становится необходимостью для предотвращения потенциальных угроз и минимизации рисков.</p>
			<p>Защита информации обеспечивает личную безопасность и приватность, предотвращает утечку личных данных и защищает от возможных мошеннических действий.</p>
			<p>Под термином «угроза» следует понимать любое программное средство, косвенно или напрямую способное нанести ущерб компьютеру, сети, информации или правам пользователя (то есть вредоносные и прочие нежелательные программы). В более широком смысле термин «угроза» может означать любую потенциальную опасность для компьютера или сети (то есть ее уязвимость, которая может быть использована для проведения хакерских атак).</p>
			<p>Сетевая атака – это вторжение в операционную систему удаленного компьютера. Злоумышленники предпринимают сетевые атаки, чтобы захватить управление над операционной системой, привести ее к отказу в обслуживании или получить доступ к защищенной информации.</p>
			<p>Следует понимать, что защита от взлома серверов — это комплекс мер, в том числе подразумевающий постоянный мониторинг работы сервера и работу по совершенствованию защиты. Невозможно защитить сервер от внешнего доступа раз и навсегда, ведь каждый день обнаруживаются новые уязвимости и появляются новые способы взлома сервера.</p>
			<p>Основной признак попыток — «подозрительная активность» в логах. Это могут быть регулярные попытки подключения с разных IP-адресов, запросы к различным портам сервера, запросы на те или иные ресурсы.</p>
			<p>Лог (log) — это текстовый файл, куда автоматически записывается важная информация о работе системы или программы. Чаще всего говорят о логах сервера. Их записывает программное обеспечение, которое управляет внутренней частью сайта или онлайн-системы. Лог-файл — своеобразный журнал событий.</p>
			<p>В логи записываются сведения об ошибках, действиях пользователей и других событиях, которые происходят на сервере или в системе.</p>
			<p>Чтобы обнаружить угрозу, необходимо регулярно анализировать все логи, начиная с системных, и заканчивая логами различных утилит, которые работают на вашем сервере.</p>
			<p>Однако, анализировать логи вручную - не самая лучшая затея, хотя и вполне возможная. Для анализа логов существуют специальнные утилиты автоматического анализа и блокирования несанкционированного доступа. В простейшем случае они анализируют логи на подозрительную активность и при необходимости блокируют все попытки несанкционированного получения доступа на те или иные ресурсы сервера.</p>
			<p><b>Что значит несанкционированного?</b></p>
			<p><b>Несанкционированно</b> - осуществляемый без санкции, официального разрешения. Т.е. в нашем случае при самом простом способе прямого входа на ваш веб-сайт через веб-браузер вы увидите в логах действительные статусы состояний сервера. При любой попытке обойти формы ввода логина и пароля, даже напрямую вручную через браузер, в логи будет выведен совершенно другой статус состояния вашего сайта или всего сервера. При этом там же будут отображены все попытки запросов и все адреса и порты, на которые происходили запросы. В случае же использования любых утилит - не браузеров - эта информация сразу же отобразится в логах.</p>
			<p>Обычно любая утилита или программа (не важно Windows или Linux) во время запроса обязательно вставляет в посылаемый на сервер запрос (пакет) минимальную информацию о себе. В случае же хакерских утилит такой информации не будет.</p>
			<p>Посмотрим на частичный лог одного веб-сайта. IP-ардеса и некоторые другие данные лога я закрасил в целях безопасности.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-1.png" width="800px"/>
			</div>
			<div style="clear:both"></div>
			<p>Мы здесь можем видеть - что некий IP-адрес (пользователь, закрашен в самой левой части перед датой и временем) делает <b>GET</b>-запрос. При этом у адреса есть операционная система, и делает он свой запрос через браузер <b>Google-chrome</b>. Ну и соответственно видим дату и время запроса, а также статус состояния сайта, т.е. ответ веб-сайта.</p>
			<p>Судя по этой скудной информации мы можем сделать вывод о том, что некий пользователь напрямую через веб-браузер, т.е. санкционированно, обращался к некому веб-сайту.</p>
			<p>В последних 2 строках <b>GET</b>-запросы происходили не через браузер и с помощью утилиты <b>Curl</b>. При этом видим также и версию этой утилиты.</p>
			<p>В этих последних строках из-за статуса состояния сайта мы можем сделать вывод о том, что запрос хоть и был санкционированный, но не прямой, т.е. не через веб-браузер, и к этому стоит присмотреться.</p>
			<p>Существуют утилиты не только для автоматического мониторинга работы сервера и его доступности в интернете, но и оповещения по электронной почте или СМС в случае обнаружения проблем.</p>
			<p>Причём располагать утилиты мониторинга доступности сервера в интернете и оповещений непосредственно на самом сервере - не самая лучшая затея, хотя и вполне реализуемая и частенько практикуемая. Практикуемая именно потому что денег на второй сервер только для мониторинга нет. Такие утилиты вполне можно установить на сервер в виртуальной машине, которая будет не доступна из интернета, тем самым защищена. Она же и будет производить мониторинг работы и оповещать в случае проблем. Однако, не все могут оставить работать свой ПК с работающей виртуальной машиной на круглосуточную работу ради одного сервера. Обычно так делают когда серверов много.</p>
			<p>Кстати говоря, любые подобные утилиты мониторинга и оповещений вполне можно создать самостоятельно.</p>
			<p><span style="color:blue;">Сегодня мы с вами рассмотрим одну из утилит для блокировки вторжений на сервер.</span> Рассматривать утилиты оповещений и мониторинга сегодня мы не будем.</p>
			<p>Однако, это не говорит о том, что при использовании утилит блокировок вам не нужно будет использовать утилиты мониторинга или антивирусные средства. Как раз наоборот.</p>
			<p><span style="color:blue;"><u>Просто базовое понимание утилит блокировки даст вам понимание того, как запускать все программы и под-программы мониторинга, блокировок и оповещений одновременно так, чтобы данные получаемые из логов были на тот момент актуальными и одинаковыми для всех утилит. Иначе вы можете столкнуться с тем, что для одной из программ в логах у вас будут одни данные, для другой уже другие. В результате одна из утилит просто не сработает во время. Или вообще пропустит важные данные для обработки результата.</u></span></p>
			<p><span style="color:red;"><b>Чем это чревато? Надеюсь, вы и сами понимаете!</b></span></p>
			<p>Также, этот же момент не говорит о том, что вам всё равно не придётся создавать регулярные резервные копии данных сайта или всего сервера. <u>Потому что взломать можно всё что угодно! Было бы желание.</u> Вот как раз на случай проникновения и/или захвата управления, чтобы иметь возможность быстро восстановить сервер после атаки, как раз и нужны резеревные копии данных.</p>
			<p>Помимо описанного, необходимо регулярно следить за обновлениями программного обеспечения и операционной системы сервера. Обновления обычно устраняют уязвимости, которые могут использоваться для проведения атак.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h2>3. Одновременный доступ к файлам журналов.</h2>
			<p>При чтении или записи любого файла создаётся так называемый файловый дескриптор.</p>
			<p>Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом.</p>
			<p>Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux.</p>
			<p>В Linux библиотека libc открывает для каждого запущенного приложения(процесса) 3 файл дескриптора, с номерами 0,1,2.</p>
			<ul>
				<li>Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения.</li>
				<li>Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print.</li>
				<li>Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.</li>
			</ul>
			<p>Если в вашей программе вы откроете какой-либо файл на чтение или запись, то скорее всего вы получите первый свободный ID и это будет номер 3.</p>
			<p>Файл дескриптор с номером 255 можете смело игнорировать, он был открыт для своих нужд уже самим bash, а не прилинкованной библиотекой.</p>
			<p>Например, откроем консоль с bash и посмотрим PID нашего процесса.</p>
			<div class="codeses">
				<pre><b>[user@localhost Загрузки]$</b> echo $$
11644
<b>[user@localhost Загрузки]$</b> ls -lha /proc/11644/fd/
итого 0
dr-x------ 2 user users  0 июл 22 08:26 .
dr-xr-xr-x 9 user users  0 июл 22 08:26 ..
lrwx------ 1 user users 64 июл 22 08:26 0 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 1 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 2 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 255 -> /dev/pts/1
<b>[user@localhost Загрузки]$</b></pre>
			</div>
			<p>Сейчас все 3 файл дескриптора связаны с устройством псевдотерминала /dev/pts, но мы все равно можем ими манипулировать, например запустим во второй консоли.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> echo "hello world" > /proc/11644/fd/0
			</p>
			<p>И в первой консоли мы увидим.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> hello world
			</p>
			<p>Вы можете легко переопределить эти 3 файл дескриптора в любом процессе, в том числе и в bash, например через трубу(pipe), соединяющую два процесса.</p>
			<p>Продолжение смотрите в статье: <a target="_blank" href="https://habr.com/ru/articles/471038/">&laquo;Файл дескриптор в Linux с примерами&raquo;</a>.</p>
			<p>Допустим нас есть некий лог-файл, в который постоянно ведётся запись разных данных. Например, в лог-файл <b>NGINX</b>-а запись будет производиться только при поступления запроса на сервер и только на тот веб-адрес, который имеется в настройках конфигурации.</p>
			<p>К примеру, у нас есть несколько программ в виде коротких скриптов, которые постоянно с разными временными задержками анализируют этот лог-файл.</p>
			<p>Возникает логичный вопрос: А одинаковые ли будут данные у каждого из этих скриптов для анализа?</p>
			<p>Проведём небольшой эксперимент. Для этого создадим 3 разных скрипта. Один будет записывать данные в некий предопределённый нами лог-файл, а 2 других читать этот лог и выводить результат чтения на экран.</p>
			<p>Файл <b>&laquo;./write.sh&raquo;</b>. Здесь мы будет 10 раз записывать время с секундами и наносекундами в лог-файл <b>&laquo;./text.log&raquo;</b>, но с задержкой между записями в 2 секунды. Т.е. итоговое время выполнения, по идее, должно быть 18 секунд, включая вывод на экран.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./write.sh
#!/bin/bash
echo &quot;&quot; &gt; text.log
for x in {1..10}; do
	_date=$(date '+%H:%M:%S:%N')
	_random=$(echo &quot;${_date}&quot; | rev | cut -d ':' -f1 | rev)
	echo "${_date} - ${_random}"
	echo "${_date} - ${_random}" &gt; text.log
	sleep 2
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read.sh&raquo;</b>. Здесь мы будет читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, но вместо простого вывода содержимого на экран будем подсчитать количество строк в этом файле, что будет несколько нагляднее. Читать будем 3 раза с задержкой открытого файла дескриптора на 1 секунду в каждый цикл чтения. Итоговое время выполнения, по идее, должно быть 3 секунды.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 1
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read2.sh&raquo;</b>. Ну а в этом скрипте мы также будем читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, но с задержкой файла-дескриптора уже на 2 секунды при каждом цикле чтения. Итоговое время выполнения, по идее, должно быть 6 секунд.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read2.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 2
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Теперь, откроем 3 разных косноли и попытаемся быстро-быстро запустить эти скрипты одновременно. Разумеется они будут работать не одновременно. Однако, из-за временных <b>sleep</b> задержек это будет не важно.</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-2.png" width="1024px"/>
			</div>
			<p>Как видите, и в первой и во второй консоли, из-за того, что скрипты долго держат файловый дескриптор открытым, они продолжают читать старый файл. Таким образом скрипты продолжает использовать старые данные и не успевают получить новые для обработки, в то время как в лог-файл уже была произведена запись и он был обновлён.</p>
			<p>Более того, 2-й скрипт <b>&laquo;./read2.sh&raquo;</b> вообще потерял много данных, а задержка была неоправдано долго и в данном случае именно из-за того, что файловый дескриптор уже был открыт другим процессом, т.е. занятым в этот момент.</p>
			<p>В простонародье говорят, что файл-журнала успел отротироваться, в то время как один из скриптов продолжает читать старый файл, уже после его ротации. При этом, открытый файловый дескриптор на чтение не позволяет другому скрипту прочитать тот же самый файл, и второму скрипту приходится ждать закрытия файлового дескриптора.</p>
			<p>Под таким понятием как &laquo;ротация&raquo; подразумевается переодическая и в тоже время последовательная и целенаправленная смена чего-то или же кого-то.</p>
			<p>В итоге, из-за такой, казалось бы, простой операции как <b>&laquo;Чтение файла&raquo;</b> - образовалась маленькая локальная война за ресурсы, в результате которой было потеряно много данных.</p>
			<p>Проблема чтения данных ещё состоит и в том, что практически все утилиты или скрипты анализа лог-файлов могут быть очень разными и сложными, или наоборот простыми. <u>Какие-то из них потребляют мало оперативной памяти, а какие-то напротив - очень много.</u></p>
			<p><u>Уменьшать время работы одной из утилит ради ускорения обработки данных очень и очень плохая затея!</u> Ведь таким образом вы можете чрезмерно нагрузить и процессор и оперативную память. А если у вас VPS или VDS сервер с ограниченным количеством ресурсов - в результате вы можете просто напросто зависнуть. Да-да, в Linux-е и зависнуть. Это не шутка!</p>
			<p><span style="color:purple;"><b>Этот маленький эксперимент должен был сказать вам</span> <span style="color:blue;"><u><i>не о том</i></u></span></b>, что необходимо уменьшать время запуска тех или иных программ или скриптов анализа, <b><span style="color:blue;"><u><i>а о том</i></u></span></b>, <b><span style="color:red;">что анализировать данные лучше какой-то одной единственной утилитой, и уже в ней, внутри, запускать все остальные необходимые вам внешние скрипты и программы обработки результатов, при обнаружении проблем.</span> </span> <span style="color:green;">При условии, что такая функция запуска внешних скриптов или программ имеется внутри утилиты анализа.</b></span></p>
			<p>Обычно, у всех программ и утилит анализа имеются специальные макросы для запуска внешних программ или скриптов для обработки результатов или запуска какого-нибудь действия / противодействия в самой ОС.</p>
			<p>Если же возможности самого анализа как такового ограничены - тогда да, запуск отдельной программы или отдельного скрипта в системе по таймеру - будет хорошим выходом из ситуации.</p>
			<p>Но, тогда вы, скорее всего, будете вынуждены подбирать и калибровать время запуска по таймеру только ради 2 вышеуказанных условий - аткуальность данных и нагрузка на оперативную память.</p>
			<p>Актуальность данных подразумевает несколько важных пунктов.</p>
			<ul>
				<li>Как часто обновляется нужный вам лог-файл, т.е. как часто в него записываются новые данные?</li>
				<li>Как часто необходимо анализировать лог-файл?</li>
			</ul>
			<p>В зависимости от данных ответов настраивается время таймера.</p>
			<p>Нагрузка же на процессор имеет немного более высокий приоритет. Для корректной настройки вам также необходимо будет ответить на пару вопросов.</p>
			<ul>
				<li>Сколько максимально в пике оперативной памяти потребляет ваша утилита или скрипт?</li>
				<li>Как сильно ваша утилита или скрипт нагружают процессор?</li>
			</ul>
			<p>Последние 2 вопроса имеют место быть, в случае, когда утилита имеет внутри себя множество различных сложных вычислений. В таком случае стоит задуматься насчет частоты запуска и соответственно об увеличении времени таймера для её запуска.</p>
			<p>При этом как именно будет запускаться утилита или скрипт не особо играет роли - будь то системный <b>systemd-таймер</b> или процесс запущенный из под сервиса <b>cron</b>, т.е. <b>crontab</b>.</p>				
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>4. Межсетевые экраны.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava4 { 
					counter-reset: list1; /* Список первого уровня*/ 
				} 
				.glava4 li:before { /* Список первого уровня */ 
					counter-increment: list1; /* Увеличиваем значение счетчика */ 
					content: "4." counter(list1) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava4">
				<li><a href="#part4.1">История, определения.</a></li>
				<li><a href="#part4.2">Netfilter</a></li>
				<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
				<li><a href="#part4.4">NFTABLES.</a></li>
				<li><a href="#part4.5">UFW / Firewalld.</a></li>
				<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
			</ol>
			<hr>
			<p><a name="part4.1"></a></p>
			<h3>4.1. История, определения.</h3>
			<p>Рассмотрим первую линию обороны - межсетевые экраны.</p>
			<p>Брандмауэр, фаервол или межсетевой экран – это система, которая выполняет роль защитной стены между глобальным интернетом и устройством пользователя.</p>
			<p>Брандмауэр фильтрует всю входящую информацию и не пропускает вредоносный контент и вирусы.</p>
			<p>Брандмауэры, как правило, контролируют двунаправленный поток трафика, поэтому представьте себе брандмауэр перед организацией, отделяющий ее от общедоступного Интернета. Он должен иметь возможность блокировать входящий трафик, чтобы попытаться удержать злоумышленников, но он также должен иметь возможность разрешать исходящий трафик, потому что людям нужно просматривать веб-страницы, отправлять электронные письма и иметь связь, которая выходит за пределы сети.</p>
			<p>Наиболее распространённое место для установки межсетевых экранов — граница периметра локальной сети для защиты внутренних хостов от атак извне. Однако атаки могут начинаться и с внутренних узлов — в этом случае, если атакуемый хост расположен в той же сети, трафик не пересечёт границу сетевого периметра, и межсетевой экран не будет задействован. Поэтому в настоящее время межсетевые экраны размещают не только на границе, но и между различными сегментами сети, что обеспечивает дополнительный уровень безопасности.</p>
			<p>Программные межсетевые экраны появились существенно позже и были гораздо моложе, чем антивирусные программы. Например, проект <b>&laquo;Netfilter/iptables&raquo;</b> (один из первых программных межсетевых экранов, встраиваемых в ядро <b>Linux</b> с версии <b>2.4</b>) был основан <b>в 1998 году</b>.</p>
			<p>Фильтрация трафика осуществляется на основе набора предварительно сконфигурированных правил, которые называются ruleset. Удобно представлять межсетевой экран как последовательность фильтров, обрабатывающих информационный поток. Каждый из фильтров предназначен для интерпретации отдельного правила. Последовательность правил в наборе существенно влияет на производительность межсетевого экрана. Например, многие межсетевые экраны последовательно сравнивают трафик с правилами до тех пор, пока не будет найдено соответствие.</p>
			<p>Существует два принципа обработки поступающего трафика. Первый принцип гласит: «Что явно не запрещено, то разрешено». В данном случае, если межсетевой экран получил пакет, не попадающий ни под одно правило, то он передаётся далее. Противоположный принцип — «Что явно не разрешено, то запрещено» — гарантирует гораздо большую защищённость, так как он запрещает весь трафик, который явно не разрешён правилами. Однако этот принцип оборачивается дополнительной нагрузкой на администратора.</p>
			<p>В конечном счёте межсетевые экраны выполняют над поступающим трафиком одну из двух операций: пропустить пакет далее (allow) или отбросить пакет (deny). Некоторые межсетевые экраны имеют ещё одну операцию — reject, при которой пакет отбрасывается, но отправителю сообщается о недоступности сервиса, доступ к которому он пытался получить. В противовес этому, при операции deny отправитель не информируется о недоступности сервиса, что является более безопасным.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.2"></a></p>
			<h3>4.2. Netfilter.</h3>
			<p>Посмотрим на компаненты, которые входят в состав <b>Netfilter</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/Netfilter-components.png" width="800px"/>
			</div>
			<p>Все компаненты обозначенные голубым цветом - это пользовательские утилиты, т.е. програмная часть, с помощью которых осуществляется доступ к нижележащим таблицам фильтрации и преобразования пакетов. У <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в итоге к <b>&laquo;Xtables&raquo;</b>, соответственно у <b>&laquo;iptables-nftables&raquo;</b> и <b>&laquo;nft&raquo;</b> к <b>&laquo;nf_tables&raquo;</b>.</p>
			<p>Долгое время <b>&laquo;Xtables&raquo;</b>, встроенная в ядро, считалась единственным способом управления <b>Netfilter</b>-ом.</p>
			<p><b>iptables</b> — утилита командной строки для настройки встроенного в ядро Linux межсетевого экрана, разработанного в рамках проекта <b>Netfilter</b>.</p>
			<p>Термином iptables также часто называют сам межсетевой экран в ядре. Настройка экрана выполняется либо напрямую с помощью iptables, либо через один из фронтендов, консольных или графических. iptables работает с протоколом IPv4, для IPv6 разработана утилита ip6tables. В основном их синтаксис совпадает, но некоторые специфичные для протоколов опции различаются.</p>
			<p>Тем временем постепенно развивался проект <b>&laquo;nf_tables&raquo;</b>. Проект должен и выступил в качестве замены существующего фреймворка <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в 2021 году.</p>
			<p>Этот проект предоставляет новую систему фильтрации пакетов, пользовательскую утилиту ntf, а также слой совместимости с {ip,ip6}tables. nftables использует существующие хуки, отслеживание соединений, очереди в пространстве пользователя и подсистему логирования netfilter.</p>
			<p>Фреймворк iptables постепенно выходит из употребления; более современная замена — nftables, в котором предусмотрен слой совместимости.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-3.png" width="717px"/>
			</div>
			<p>В <b>Debian 11</b> фреймворк <b>nftables</b> встроен в систему по умолчанию со слоем совместимости для <b>iptables</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-4.png" width="717px"/>
			</div>
			<p><b>IPTABLES</b> умер в 2021 году. Он конечно всё ещё встроен во многие системы, но постепенно будет полностью заменён на более эффективный <b>NFTABLES</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/iptables-rip.png" width="277px"/>
			</div>
			<div style="clear:both"></div>
			<br>
			<hr>
			<p><u>Плохая новость:</u> документация <b>&laquo;NFTABLES&raquo;</b> (&laquo;nft&raquo;: man nft) содержит больше 3 тысяч строк.</p>
			<hr>
			<p>Для облегчения перехода можно конвертировать правила <u><i>iptables</i></u> в <u><i>nftables</i></u> с помощью утилит <u><i>iptables-translate</i></u>, <u><i>iptables-restore-translate</i></u>, <u><i>iptables-nft-restore</i></u> и т.п. Утилиты находятся в пакете <u><i>iptables</i></u>, который необходимо установливать отдельно.</p>
			<p>Грубо говоря, <b>Netfilter</b> по сути является как бы внутренней обороной ОС. Однако, самой ОС нужна ещё и внешняя оборона - инструмент или средство для управления брандмауэром, такие как <b>UFW</b> или <b>Firewalld</b>.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> - является самым простым и довольно популярным инструментарием командной строки для настройки и управления брандмауэром.</p>
			<p><b>Firewalld</b> — программное обеспечение для управления брандмауэрами, поддерживаемое многими дистрибутивами <b>Linux</b>.</p>
			<p>Чтобы понять как работает фильтрация пакетов в межсетевых экранах, для этого надо заглянуть в раздел <a href="#part4.3"><b>&laquo;Таблицы и цепочки IPTABLES&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.3"></a></p>
			<h3>4.3. Таблицы и цепочки IPTables.</h3>
			<p>Чтобы разобрать работу <b>Netfilter/iptables</b> возьмём схему работы из википедии.</p>
			<div class="images">
				<img src="../image/Blacklists-image/netfilter-diagram.png" width="400px"/>
			</div>
			<p>Ну, а для базового понимания схемы разберём с вами основные понятия: <i>таблицы, цепочки, действия над пакетами и механизм определения состояния</i>.</p>
			<p><u>Каждый из пунктов важен для понимания работы любого межсетевого экрана.</u></p>
			<p><b>Цепочки.</b></p>
			<ul>
				<li><b>PREROUTING</b> - для изначальной обработки входящих пакетов.</li>
				<li><b>INPUT</b> - для входящих пакетов, адресованных непосредственно локальному компьютеру.</li>
				<li><b>FORWARD</b> - для проходящих (маршрутизируемых) пакетов.</li>
				<li><b>OUTPUT</b> - для пакетов, создаваемых локальным компьютером, т.е. исходящих.</li>
				<li><b>POSTROUTING</b> - для окончательной обработки исходящих пакетов.</li>
			</ul>
			<p>Цепочки можно создавать самостоятельно, и также их уничтожать.</p>
			<p><b>Почти в каждой цепочке имеется 4 таблицы:</b></p>
			<ul>
				<li><b>raw</b> - пакет проходит данную таблицу до передачи системе определения состояний. Используется редко, например для маркировки пакетов, которые НЕ должны обрабатываться системой определения состояний. Для этого в правиле указывается действие NOTRACK. Содержитcя в цепочках PREROUTING и OUTPUT.</li>
				<li><b>mangle</b> - содержит правила модификации IP‐пакетов. Среди прочего, поддерживает действия TTL, TOS, и MARK (для изменения полей TTL и TOS, и для изменения маркеров пакета). Редко необходима и может быть опасна.</li>
				<li><b>nat</b> - предназначена для подмены адреса отправителя или получателя. Данную таблицу проходят только первый пакет из потока, трансляция адресов или маскировка (подмена адреса отправителя или получателя) применяются ко всем последующим пакетам в потоке автоматически. Поддерживает действия <i>DNAT</i>, <i>SNAT</i>, <i>MASQUERADE</i>, <i>REDIRECT</i>. Содержится в цепочках <i>PREROUTING</i>, <i>OUTPUT</i>, и <i>POSTROUTING</i>.</li>
				<li><b>filter</b> - основная таблица, используется по умолчанию если название таблицы не указано. Используется для фильтрации пакетов. Содержится в цепочках INPUT, FORWARD, и OUTPUT.</li>
			</ul>
			<p><b>Действия над пакетами.</b></p>
			<ul>
				<li><b>ACCEPT</b> - принять пакет.</li>
				<li><b>DROP</b> - отбросить пакет, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>REJECT</b> - отбросить пакет, отправив отправителю ICMP-сообщение, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>RETURN</b> - возвратить пакет в предыдущую цепочку и продолжить ее прохождение начиная со следующего правила.</li>
				<li><b>SNAT</b> - применить трансляцию адреса источника в пакете. Может использоваться только в цепочках <b>POSTROUTING</b> и <b>OUTPUT</b> в таблицах <b>nat</b>.</li>
				<li><b>DNAT</b> - применить трансляцию адреса назначения в пакете. Может использоваться в цепочке <b>PREROUTING</b> в таблице <b>nat</b>.</li>
				<li><b>LOG</b> - протоколировать пакет и обработать остальными правилами.</li>
				<li><b>MASQUERADE</b> - используется вместо <b>SNAT</b> при наличии соединения с динамическим <b>IP</b> (допускается указывать только в цепочке <b>POSTROUTING</b> таблицы <b>nat</b>).</li>
				<li><b>MARK</b> - используется для установки меток на пакеты, передается для обработки дальнейшим правилам.</li>
			</ul>
			<p>Есть и другие действия. Остановимся на базовых.</p>
			<p><b>Механизм определения состояний (conntrack).</b></p>
			<p>В общем, механизм определения состояний (он же state machine, он же connection tracking, он же conntrack) является частью пакетного фильтра и позволяет определить определить к какому соединению/сеансу принадлежит пакет.</p>
			<p><b>Conntrack</b> анализирует состояние всех пакетов, кроме тех, которые помечены как NOTRACK в таблице raw. На основе этого состояния определяется принадлежит пакет новому соединению (состояние NEW), уже установленному соединению (состояние ESTABLISHED), дополнительному к уже существующему (RELATED), либо к "другому" (неопределяемому) соединению (состояние INVALID). Состояние пакета определяется на основе анализа заголовков передаваемого TCP-пакета. Модуль conntrack позволяет реализовать межсетевой экран сеансового уровня (пятого уровня модели OSI). Для управления данным механизмом используется утилита conntrack, а так же параметр утилиты iptables: -m conntrack или -m state. Состояния текущих соединений conntrack хранит в ядре. Их можно просмотреть в файле /proc/net/nf_conntrack (или /proc/net/ip_conntrack).</p>
			<hr>
			<p>Итак, разберём схему работы.</p>
			<p>Пакет (из интернета в сеть, затем) из сети обязательно проходит цепочку <b>PREROUTING</b>, далее попадает в таблицу маршрутизации и в зависимости от принадлежности определяет куда пойдёт дальше. Если пакет не адресован локальной системе, он попадёт в цепочку <b>FORWARD</b>. Если адресован - в цепочку <b>INPUT</b>. После <i>INPUT</i> пакет обрабатывают системные процессы и демоны. После локальной обработки программы могут сформировать ответ и этот ответ в соответствии с правилами маршрутизации направляется в цепочку <b>OUTPUT</b>. Затем снова маршрутизируется и наконец попадает в цепочку <b>POSTROUTING</b>, как и пакет из цепочки <b>FORWARD</b>. И только после всех этих манипуляций с пакетом он наконец вновь отправляется обратно в сеть и уже дальше в интернет, если стоит такая задача.</p>
			<p><b>Почему пакет несколько раз проходит через таблицу маршрутизации?</b></p>
			<p>Каждая цепочка, которую проходит пакет состоит из набора таблиц (table). Таблицы в разных цепочках имеют одинаковое наименование, но тем не менее никак между собой не связаны. Например таблица nat в цепочке PREROUTING никак не связана с таблицей nat в цепочке POSTROUTING. Каждая таблица состоит из упорядоченного  набора (списка) правил. Каждое правило содержит условие, которому должен соответствовать проходящий пакет и действия к пакету, подходящему данному условию.</p>
			<p>Проходя через серию цепочек пакет последовательно проходит каждую таблицу и в каждой таблице последовательно сверяется с каждым правилом, и если пакет соответствует какому-либо критерию, то выполняется заданное действие над пакетом. При этом, в каждой таблице (кроме пользовательских) существует заданная по-умолчанию политика. Данная политика определяет действие над пакетом, в случае, если пакет не соответствует ни одному из правил в таблице. Чаще всего - это действие ACCEPT, чтобы принять пакет и передать в следующую таблицу или DROP - чтобы отбросить пакет. В случае, если пакет не был отброшен, он завершает свое путешествие по ядру системы и отправляется в сетевой интерфейс, которая подходит по правилам маршрутизации.</p>
			<p><u>Таблица <b>nat</b> и <b>mangle</b> может модифицировать получателя или отправителя сетевого пакета. Именно поэтому сетевой пакет несколько раз сверяется с таблицей маршрутизации.</u></p>
			<p>Блокировку и разблокировку ip-адресов, разрешающие и запрещающие правила, а также сохранение состояния при перезагрузке <b>ОС</b> вы можете посмотреть в статье: <a target="_blank" href="../The-security-of-network-connections.html#part6"><b>&laquo;Безопасность сетевых соединений: 6. Блокировка ip адреса или всей подсети&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.4"></a></p>
			<h3>4.4. NFTABLES.</h3>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные таблицы. Количество таблиц и их имена определяется пользователем. Тем не менее, каждая таблица имеет только одно семейство адресации и применяется к пакетам только этого семейства.</p>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные цепочки. Соответственно, если опрелённые типы или хуки фреймворка <b>netfilter</b> не задействованы ни в одной цепочке, то проходящие через эти цепочки пакеты обрабатываться не будут (в отличие от <b>iptables</b>).</p>
			<p>Есть два типа цепочек. Базовая цепочка является точкой входа для пакетов из сетевого стека; в ней указывается хук. Обычная цепочка может использоваться в качестве цели перехода и используется для лучшей организации правил.</p>
			<p>Все спрашивают почему я так люблю <b>Acrhlinux</b> - как минимум за его прекрасную векипедию. Поэтому более подробную информацию о работе с <b>NFTABLES</b> вы можете найти на его страницах в статье: <a target="_blank" href="https://wiki.archlinux.org/title/Nftables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: nftables (Русский)&raquo;</b></a>, а если вам будет мало этой информации и у вас по прежнему останутся пару вопросов - добро пожаловать в статью на losst.pro: <a target="_blank" href="https://losst.pro/kak-polzovatsya-nftables"><b>&laquo;losst.pro: Как пользоваться nftables&raquo;</b></a>.</p>
			<p>В этих статья подробно с разъяснено как работать с <b>NFTABLES</b>. Словом, мне дополнить нечем. Читайте внимательно, тогда ничего не пропустите и вам всё будет понятно.</p>
			<p>Разьве что <u>раздел установки для разных дистрибутивов <b>Linux</b> будет у всех разный. Во всём остальном - и настройки и работа с фреймворком будет абсолютно одинаковой.</u></p>
			<p><b>Но самое главное в том, что знание схемы движения пакетов в системе IP(6)TABLES даёт вам базовое понимание того, какие таблицы и цепочки с предопределёнными типами и хуками для работы вашего сервера нужно будет создавать, а также какие правила и приоритеты устанавливать для этих цепочек. Понимание работы IP(6)TABLES значительно ускоряет процес настройки.</b></p>
			<p>Также уделите внимание <b>Firewalld</b>, ибо с ним, вам в разы меньше придётся создавать различных таблиц, цепочек и правил поведения вашего сервера, включая <b>nat</b>-преобразование адресов, в разы будет усилена защита, но также может и в разы усложниться жизнь при работе с различными сервисами в т.ч. базами данных.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.5"></a></p>
			<h3>4.5. UFW / Firewalld.</h3>
			<p>Cерверы постоянно подвергаются различным атакам или сканируются в поиске уязвимостей. Как только эти уязвимости находятся, мы рискуем стать частью ботнета, раскрыть конфиденциальные данные или потерять деньги из-за сбоев в работе веб-приложений. Одной из первых мер по снижению рисков безопасности является грамотная настройка правил межсетевого экрана.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> — удобный интерфейс для управления политиками безопасности межсетевого экрана. Он представляет собой интерфейс iptables, предназначенный для упрощения процесса настройки брандмауэра. Хотя iptables — надежный и гибкий инструмент, начинающим бывает сложно научиться использовать его для правильной настройки брандмауэра.</p>
			<p>Подробно об установке и настройке <b>UFW</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="../The-security-of-network-connections.html#part4.1"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.1. Фаервол UFW&raquo;</b></a>.</p>
			<p>По сути <b>UFW</b> и <b>Firewalld</b> это фасад сервера, а <b>{IP,IP6,ARP,EB}Tables / NFTables</b> - это интерьер.</p>
			<p><b>Firewalld</b> - более продвинутая утилита управления <b>Linux</b> брандмауэром <b>Netfilter</b>. Несмотря на собственный синтаксис, имеет такой же принцип работы, как и <b>Iptables</b>.</p>
			<p>В отличие от <b>IPTABLES</b> имеет более продвинутую безопасность, настройки, стабильную работу, а также сохранение правил фильтрации и маршрутизации без лишних скриптов и сервисов, и многое другое.</p>
			<p>Подробно об установке и настройке <b>Firewalld</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="../The-security-of-network-connections.html#part4.2"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.2. Фаервол Firewalld&raquo;</b></a>.</p>
			<p><u><b>Удивительно, но Docker не работает из коробки с UFW, т.е. &laquo;Universal Firewall&raquo; Linux.</b></u></p>
			<p>Проблема в том, что <b>UFW</b> и <b>Docker</b> пытаются изменить одни и те же базовые правила брандмауэра. В результате фаервол разрешает трафику идти дальше к <b>Docker</b>-контейнерам.</p>
			<p>Допустим вы настроете базовый брандмауэр <b>UFW</b> на запрет по умолчанию и сделаете разрешение по <i>HTTP</i> и <i>SSH</i> портам. Однако, <b>UFW</b> не будет блокировать доступ к <b>Docker</b>-контейнерам, которые привязаны к другим портам.</p>
			<p>Эту проблему может быть трудно обнаружить, поскольку <b>UFW</b> и <b>Docker</b> – это отдельные системы.</p>
			<p>Тем не менее, <b>UFW</b> покажет, что всё настроено верно и с вашего рабочего места так и будет выглядеть, даже с учетом белого списка доступа. В результате вам будет казаться что всё в порядке. Но это не так!</p>
			<p>Если какое-либо приложение запущено через <b>Docker</b>, например на порту 8000, то по умолчанию это приложение будет видно из любого места за пределами сервера.</p>
			<p>Это может стать серьезной проблемой, если вы не решите ее! Потому что у любого пользователя интернета появляется возможность обращаться к любым сервисам внутри сервера по портам, включая и базы данных, и сервисы контроля баз (например, PHPMyAdmin). При этом пределить доступные порты для подключения абсолютно не сложно.</p>
			<p>Для совмещения <b>Docker</b>-а и <b>UFW</b> воспользуйтесь статьёй: <a target="_blank" href="https://itsecforu.ru/2022/07/06/%F0%9F%90%B3-%D0%BA%D0%B0%D0%BA-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-docker-%D1%81-ufw-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE/"><b>&laquo;Как использовать Docker с UFW параллельно&raquo;</b></a>.</p>
			<p>Однако, не спешите переходить по ссылке. В данной статье используются решения, основанные на <b>IPTABLES</b>, фреймворке, который постепенно выходит из употребления.</p>
			<p>Эти правила специфичны для каждого отдельного сервера и их придётся корректировать, чтобы они работали правильно. А самое забавное в том, что когда вы будете запускать какой-то новый <b>Docker</b>-контейнер - правила снова придётся корректировать. Плюс ко всему их обязательно необходимо восстанавливать при перезапуске ОС.</p>
			<p><u>Не факт, что у вас получится, но если получится - вы счастливчик.</u> Но, опять таки, не спешите радоваться. Потому что ваша настройка, скорее всего, продержится максимум лет 5...10, пока последний фреймворк полностью не заместит всеми любимый <b>IPTABLES</b>.</p>
			<p>Из сложившейся ситуации есть выход - фаервол <b>Firewalld</b>.</p>
			<p>В свою очередь он требует тщательной настройки и понимания как всё устроено! А самое главное - он легко совмещается с <b>Docker</b>-контейнерами.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.6"></a></p>
			<h3>4.6. Примеры использования UFW / Firewalld.</h3>
			<p>Вот тут начинается самое интересное!</p>
			<p>Рассмотрим с вами несколько примеров на основе моего <b>Archlinux</b> на ноутбуке и виртуальной машине на <b>Debian 11</b> со следующими характеристиками:</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-5.png" width="1024px"/>
			</div>
			<p>Самое главное здесь то, что <u>сеть</u> установлена <u>в режиме сетевого моста</u>. Таким образом, если в <b>ОС</b> нет никаких фаерволов, кроме межсетевого экрана, то все внутренние сервисы должны быть доступны в локальной сети по <b>IP</b>-адресу, буквально напрямую.</p>
			<p>Последовательно произведём все, почте без исключения, настройки по порядку, согласно статье: <a target="_blank" href="./Configuratons_Linux_Servers.html#oglavlenie"><b>&laquo;Базовые настройки серверов Linux&raquo;</b></a>, но установим и настроим, пока что, фаервол <b>UFW</b>.</p>
			<p>В <b>Docker</b> установим 2 сервиса: <b>Whoogle</b> и <b>Portainer</b> - как наиболее простые для проведений тестов. К первому проще всего прикрутить <b>NGINX</b> и <b>Fail2ban</b>, а с помощью второго будет легче следить за всеми контейнерами.</p>
			<p>Запуск <b>Portainer</b>-а:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir -p portainer-data && cd portainer-data
<b>$</b> nano docker-compose.yml
version: &quot;3&quot;

volumes:
  portainer_data:

services:

  portainer:
    image: portainer/portainer-ce
    container_name: portainer
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    ports:
      - 9000:9000
      - 8000:8000
    restart: always

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<p>Запуск <b>Whoogle</b>:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir whoogle && cd whoogle
<b>$</b> nano docker-compose.yml
---
version: '2'
services:
	whoogle:
		image: benbusby/whoogle-search:latest
		container_name: whoogle
		ports:
			- 5000:5000
		restart: unless-stopped

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<br>
			<div class="images">
				<img src="../image/Blacklists-image/bls-6.png" width="1024px"/>
			</div>
			<p>Без вышеупомянутого совмещения <b>Docker</b>-а и <b>UFW</b> все внутренние сервисы <b>Docker</b>-а будут доступны за пределами вашего сервера.</p>
			<p>Проверить последнее утверждение не составит никакого труда. Можно это сделать с помощью браузера, а можно воспользоваться утилитой <b>Curl</b>, которая вернёт нам статусное состояние нашего <b>NGINX</b>.</p>
			<p>Т.е. если мы увидим в консоли ответ в виде числа <u><b>200</b></u> - значит и в браузере мы увидим сайт или сервис виртуальной машины, расположенный по запрашиваемому веб-адресу.</p>
			<p>При числах - вроде 1xx или 3xx - скорее всего мы сами запрашиваем неправильно, например веб-адрес.</p>
			<p>При числах - 4xx и 5xx - это ошибки в запросе и ошибки сервера.</p>
			<p>А вот если у нас будет число <u><b>000</b></u> - это будет значит сразу 3 вещи:</p>
			<ul>
				<li>Сервис не доступен за фаерволом.</li>
				<li>Настройка фаервола выполнена верно.</li>
				<li>и <b>Docker</b> с фаерволом вполне неплохо ужились на одном сервере.</li>
			</ul>
			<p>Команда <b>curl</b> выглядит следующим образом:</p>
			<p class="codes">
				curl -s -o /dev/null -w "%{http_code}\n" веб-адрес
			</p>
			<p>Например.</p>
			<p class="codes">
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120/<br>
				<span style="color:blue;"># и</span></br>
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120:9000/</br>
				<span style="color:blue;"># т.к. запущен сервис и whoogle и portainer</span>
			</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-7.png" width="1024px"/>
			</div>
			<p>Без указанного совмещения всё печально. Все сервисы, какие бы у вас не были запущены будут доступны за пределами сервера - и базы данных (например, MySQL / MariaDB) и сервисы доступа к последним (например, PHPMyAdmin) и многое другое, что вы не хотели бы выпускать в открытый доступ в интернет.</p>
			<p>Однако, есть гораздо более продвинутая альтернатива - <b>Firewalld</b>.</p>
			<p>Теперь согласно указанной инструкции настройки серверов, установим и настроим <b>Firewalld</b>, запустим <b>Fail2ban</b>.</p>
			<p>Прямой просмотр <b>Systemd</b> может выглядеть достаточно ёмко, т.е. занимать много экранного места. Вместо этого в <b>systemctl</b> существует такая операция, как <b>&laquo;is-active&raquo;</b>. Дословно - <b>&laquo;Check whether units are active&raquo;</b> переводится как - <b>&laquo;Проверка активности устройства&raquo;</b>.</p>
			<p>Т.е. на выходе у нас будет конкретный ответ - запущен ли тот или иной сервис, сокет или таймер или нет.</p>
			<p>Также с помощью <b>Curl</b> проверяем доступность запущенных <b>docker</b> сервисов. Я же, согласно инструкции, давал доступ только к <b>NGINX</b> портам - 80 и 443. 51820 в данном случае служит примером настроек <b>wireguard</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-8.png" width="1024px"/>
			</div>
			<p><span style="color:green;"><b>ЧУДО СВЕРШИЛОСЬ, причём без танцев с бубном!</b></span> Шутка. Но в каждой шутке...</p>
			<p><u>Внутренние сервисы, к которым вы явно не давали доступа теперь не доступны за пределами самого сервера.</u></p>
			<p><span style="color:blue;">Это не может не радовать.</span></p>
			<p>При этом лишний раз лазить в <b>IP(6)TABLES / NFTABLES</b> не придётся.</p>
			<p>На самом деле дело в том, что в <b>Firewalld</b> имеется несколько сетей по умолчанию - внутренняя, внешняя (публичная) и другие. Это непосредственно связано с принципом работы самого фаервола как такового. Все сети разделяются разными правами доступа, разными политиками обработки пакетов, разными приоритетами и т.д. и т.п. Т.е. для любого сервиса можно настроить своё собственное поведение. Таким образом, для каждого сервиса будут разные базовые правила брендмауера, которые вы сами настроили. В итоге <b>Docker</b> просто перестаёт конфликтовать с фаерволом. Только если явно не указать другие настройки.</p>
			<p>Правда появляется другой недостаток - не возможно запустить или остановить какой-либо <b>Docker-контейнер</b>. Для этого просто остановите сервис фаервола. Этого будет вполне достаточно.</p>
			<p class="codes">
				<b>$</b> sudo systemctl stop firewalld.service
			</p>
			<p>Если вы настраивали фаервол по моей инструкции и создавали таймер запуска, то сначала придётся остановить этот таймер и затем уже сервис. Поработали с контейнерами - что-то остановили, что-то запустили, после этого вновь запустите только один сервис фаервола. Если у вас есть связанный с фаерволом <b>Fail2ban</b>, то и его и таймер, и сервис тоже надо будет остановить, а после всех работ запустить хотя бы сервис. После этого не забудьте проверить новые сети <b>Docker</b>-контейнеров и обязательно добавить их во внутреннюю зону <b>internal</b> фаервола с сохранением параметров при перезагрузке.</p>
			<p class="codes">
				<b>$</b> sudo systemctl stop firewalld.timer<br>
				<b>$</b> sudo systemctl stop firewalld.service<br><br>
				<b>$</b> sudo systemctl start firewalld.timer<br>
				<b>$</b> sudo systemctl start firewalld.service
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part5"></a></p>
			<h2>5. Fail2ban</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava5 { 
					counter-reset: list2; /* Список первого уровня*/ 
				} 
				.glava5 li:before { /* Список первого уровня */ 
					counter-increment: list2; /* Увеличиваем значение счетчика */ 
					content: "5." counter(list2) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava5">
				<li><a href="#part5.1">Оперативная память.</a></li>
			</ol>
			<hr>
			<p><b>Fail2Ban</b> – программа для защиты серверов от атак методом грубой силы. Написанная на языке <b>Python</b>, может работать на <b>POSIX-системах</b> имеющих встроенный менеджер пакетов и брандмауэр. Например, <b>IPTABLES</b> или <b>NFTABLES</b>. Также работает и с <b>Firewalld</b>.</p>
			<p>Описывая <b>Fail2ban</b> в двух словах, можно сказать, что он позволяет на основе анализа логов блокировать тех, кто злоупотребляет доступностью сервера по сети. Например, защитить почтовые ящики от взлома путем перебора паролей или многократного запроса какого-либо ресурса.</p>
			<p><b>Fail2Ban</b> считывает логи (например, /var/log/apache2/error.log) и блокирует IP-адреса, активность которых является подозрительной (например, большое количество попыток войти с неправильно введенным паролем, выполнение опасных или бессмысленных действий и т.д.). В случае обнаружения подобных действий программа обновляет правила брандмауэра для блокировки такого IP-адреса на определенный промежуток времени. Программа может быть настроена и для выполнения любых других действий (например, отправки электронного письма).</p>
			<p>Конфигурация программы по умолчанию содержит фильтры для Apache, Lighttpd, sshd, vsftpd, qmail, Postfix, Courier Mail Server, Asterisk и других популярных серверных приложений. В фильтрах используются регулярные выражения, которые могут быть легко изменены и настроены в случае необходимости.</p>
			<p>Говоря о слабых сторонах <b>Fail2Ban</b>, вы должны знать, что он не очень хорошо работает против распределенных атак методом перебора. Причина в том, что мониторинг лог-файлов происходит примерно раз в секунду. Этого должно быть достаточно в большинстве случаев, однако можно получить больше отказов входа, чем указано в параметре “maxretry”.</p>
			<p>Таким образом мы понимаем, что во первых файловый дескриптор какого-либо лога будет практически постоянно открыт и на чтение и на запись. Поэтому обратиться к файлу того или иного журнала с помощью стороннего скрипта может оказаться проблематично. Да и во вторых эффективность у <b>Fail2ban</b>-а, мне кажется, будет несколько выше, чем у сторонних скриптов и утилит.</p>
			<p>На самом деле, прописать регулярные выражения для собственных фильтров (если таковые понадобятся) не так уж и сложно, как кажется на первый взгляд. А уж тем более создать свои собственные экшены действий при обнаружении нежелательной активности.</p>
			<p><b>Таким образом необходимость в сторонних скриптах и утилитах анализа практически полностью отпадает.</b></p>
			<p>Нужны будут только скрипты или утилиты для работы с самими пойманными ip-адресами для того, чтобы прописать их в экшенах <b>Fail2ban</b>-а. Т.е. что делать с этими адресами вы решаете самостоятельно - блокировать навсегда или сделать что-то другое.</p>
			<p>Или же вы вполне можете прописать в экшенах отправку уведомлений по электронной почте или даже по СМС. Вообщем, на что хватит фантазии ...</p>
			<p>У <b>Fail2Ban</b> довольно низкие системные требования. При конфигурации только с <b>sshd</b> и несколькими различными правилами, <b>Fail2Ban</b> требует около 500 Мб памяти и загружает 1 ядро CPU в среднем менее чем на 0,2%.</p>
			<p>Если вам нужна информация по установке и настройке <b>Fail2ban</b>-а, фильтрам, экшенам и действиям с разлиными примерами - обратитесь к статье: <a target="_blank" href="../The-security-of-network-connections.html#part5.0"><b>&laquo;Безопасность сетевых соединений: 5. Fail2ban.&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part5">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part5.1"></a></p>
			<h3>5.1. Оперативная память.</h3>
			<p>Прежде чем обращаться к параметрам оперативной памяти процессов в <b>Linux</b> системах необходимо разобраться в нескольких понятиях, без которых вы можете не только запутаться в значениях, но и неверно их истолковать. В результате у вас будут ложные сведения не совпадающие с реальностью.</p>
			<p>Физическая память остается после отключения питания. Оперативная память после отключения питания обнуляется.</p>
			<p>К физической памяти можно отнести и жесткие диски (ЖД), в том числе, и твердотельные, встроенные к компьютер и внешние, а так же "флешки", забываемые ныне дискеты и пр.</p>
			<p>Оперативная память - планки оперативной памяти (хранят информацию только при работе компьютера).</p>
			<p>С виртуальной памятью можно легко соприкоснуться в случае, если операционной системе не хватает оперативной. В этом случае нехватка располагается на жестком или твердотельном диске.</p>
			<p>Виртуальная память - это область выделенная Операционной системой на жестком диске!</p>
			<p>Виртуальная память - временное хранилище, используемое компьютером для выполнения программ, превышающих размер доступной оперативной памяти. Например, программы могут использовать до 4 Гбайт виртуальной памяти на жестком диске, в то время как оперативная память компьютера составляет всего 32 Мбайт. Данные программы, для которых нет свободного места в оперативной памяти, сохраняются в файлах подкачки.</p>
			<p>Файл подкачки - Скрытый файл на жестком диске, используемый для хранения частей программ и файлов данных, не помещающихся в оперативной памяти. Файл подкачки и физическая память составляют виртуальную память. По мере необходимости операционная система перемещает данные из файла подкачки в оперативную память (для их использования программами) и обратно (для освобождения места для новых данных).</p>
			<p>Посмотрим сколько реально памяти занимает <b>Fail2ban</b> - физической, виртуальной, оперативной. Для начала посмотрим на физическую и фиртуальную.</p>
			<p class="codes">
				<b>$</b> ps -aux | grep -Ei "fail2ban"</br>
				<b>$</b> pgrep fail2ban</br>
				<b>$</b> free -h</br>
				<b>$</b> echo -e -n "$(ps -aux --sort -rss | sed '2,$d')\n$(ps -aux --sort -rss | grep -Ei 'fail2ban')\n"</br>
				<b>$</b> ps -p 1044 v
			</p>
			<br>
			<div class="images">
				<img src="../image/Blacklists-image/bls-9.png" width="800px"/>
			</div>
			<p>Ещё немного физической и виртуальной памяти, но уже с помощью прямого доступа к информации о процессе.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-10.png" width="800px"/>
			</div>
			<p>А теперь посмотрим на все эти данные вместе и разберёмся что происходит на всех скриншотах работы виртуальной машины.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-11.png" width="800px"/>
			</div>
			<p>Итак, на скриншотах имеются следующие переменные:</p>
			<ul>
				<li><b>USER</b> - Пользователь, от имени которого работает процесс.</li>
				<li><b>PID</b> - Идентификатор процесса.</li>
				<li><b>RSS</b>, <b>VmRSS</b> - Неподкачиваемая физическая память, используемая процессом.</li>
				<li><b>VSZ</b>, <b>VmSize</b>, <b>VmPeak</b> - Виртуальная память, используемая процессом - 2 текущих, т.е. в данный момент и пиковая, т.е. максимальная.</li>
				<li><b>SIZE</b>, <b>%MEM</b> - Оперативная память - в килобайтах и процентах соответственно.</li>
			</ul>
			<p>Как вы можете видеть - те самые 500 с лишним Мб - это виртуальной памяти. Реально же в оперативной всего 70 Мб. Соответственно физической памяти всего 24 Мб.</p>
			<p>А теперь немного данных с реального <b>VPS</b> сервера.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-12.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-13.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-14.png" width="800px"/>
			</div>
			<p><b>Проведём небольшое расследование оперативной и физической памяти. Посмотрим дурят нас или нет.</b></p>
			<p>Сначало необходимо узнать, а сколько у нас вообще имеется оперативной памяти и подкачки?</p>
			<p class="codes">
				<b>$</b> free -h
			</p>
			<p>После этого посмотрим сумму оперативной памяти всех процессов, затем также сумму физической памяти всех процессов. Смотреть на сумму виртуальной памяти бессмыслено - она будет занимать по меньшей мере около 10 Гб, а то и в разы больше.</p>
			<p class="codes">
				<b>$</b> ps -eo size --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'<br>
				<b>$</b> ps -eo rss --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'</br>
				<b>$</b> ps -eo vsz --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'
			</p>
			<p><b>Подведём итоги</b> - общий объём оперативной памяти минус (сумма используемой памяти и кешируемой) должна примерно равняться свободной оперативной памяти.</p>
			<p><u>Если это так - то всё нормально!</u> <b>Если нет - у нас, возможно, утечка памяти и тогда - проблему необходимо решать! +/- 20...30 Мб обычное дело.</b></p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-15.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-16.png" width="800px"/>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part5">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part6"></a></p>
			<h2>6. NGINX / Nginx Proxy Manager.</h2>
			<p><b>Nginx (NGINX, Engine-X, &laquo;Энджин-икс&raquo;)</b> — это веб-сервер, прокси-сервер, обратный прокси-сервер, smtp-сервер и балансировщик нагрузки с открытым кодом.</p>
			<p><b>Nginx</b> обслуживает более миллиона сайтов по всему миру и пользуется заслуженной любовью и почитанием. Однако несмотря на его популярность и большое количество материалов, вопросов по его использованию не убавляется.</p>
			<p><b>Веб-сервер</b> — это программа, которая принимает и обрабатывает запросы от клиентов по протоколам HTTP и HTTPS и возвращает им ответ в виде HTML-страницы.</p>
			<p><b>Прокси-сервер</b> принимает и обрабатывает запросы клиентов, а затем передает их дальше, другим программам.</p>
			<p><b>Обратный прокси-сервер</b> — принимает результат работы других серверов и отдаёт его клиентам. </p>
			<p><b>Smtp-сервер</b> — это сервер почтовой службы.</p>
			<p><b>Балансировщик нагрузки</b> — программа, которая распределяет сетевые запросы между серверами, следуя настройкам балансировки.</p>
			<p><b>NGINX</b> сочетает в себе все перечисленные возможности, хотя изначально он задумывался только как <b>&laquo;web-&raquo;</b> и <b>&laquo;smtp-сервер&raquo;</b>.</p>
			<p>Сегодня в век технологий давно существует система управления обратным прокси  - <b>&laquo;Nginx Proxy Manager&raquo;</b> (NPM), работающая на <b>Docker</b>. NPM основан на сервере <b>Nginx</b> и предоставляет пользователям чистый, эффективный и красивый веб-интерфейс для упрощения управления. Инструмент прост в настройке и не требует, чтобы пользователи знали, как работать с серверами <b>Nginx</b> или сертификатами <b>SSL</b>.</p>
			<p><u><b>NPM</b> по сравнению с <b>NGINX</b> просто песня, если не сказка. Всё бы ничего, но есть и целая тарелка дёгтя в этой бочке мёда. А вот какая - вы сейчас узнаете.</u></p>
			<p><span style="color:blue;">Обратите также внимание, что речь идёт об <b>Nginx Proxy Manager</b> <u>версий 3.8 и ниже</u>. Возможно в новых версиях что-нибудь измениться и недостатки обернут в положительные качества.</span></p>
			<p>Для начала давайте посмотрим на 2 скриншота, в которых запущен <b>docker</b>-контейнер с <b>&laquo;Nginx Proxy Manager&raquo;</b> и парой папок с настройками менеджера. Эти папки примонтированы внутрь контейнера с менеджером. Поначалу этих папок не существовало, поэтому <b>docker-compose</b> автоматически их создал и поместил в них настройки из образа менеджера, который <b>docker</b> скачал с официального реестра образов - <b>Docker Hub</b>.</p>
			<p>Файл <b>&laquo;docker-compose.yml&raquo;</b> <b>Nginx Proxy Manager</b>-а.</p>
			<div class="codeses">
				<pre>version: '3.8'
services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    restart: unless-stopped
    ports:
      - '80:80'
      - '81:81'
      - '443:443'
    volumes:
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt</pre>
			</div>
			<p>После запуска я специально заранее ввел в качестве прокси к определённым локальным ip-адресам пару фейковых доменов с определёнными портами. Попробуем найти созданные конфигурации, а также созданные файлы-логов в папках, которые примонтированы внутрь этого <b>Docker</b>-контейнера: <b>&laquo;./data&raquo;</b> и <b>&laquo;./letsencrypt&raquo;</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-17.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-18.png" width="800px"/>
			</div>
			<p>Подведём итог проведённого небольшого расследования:</p>
			<ul>
				<li>Количество файлов журналов на порядок увеличивается.</li>
				<li>В менеджере поддерживается защита от <b>эксплоитов</b>, <b>DDOS</b> атак и <b>HSTS</b>. Но, к сожалению, вы, скорее всего, не знаете что это за настройки и на что они влияют. При настройке определенных веб-ресурсов (веб-сайтов, веб-сервисов) это важно знать! Искать файлы этих настроек внутри <b>Docker</b>-контейнера <b>Nginx Proxy Manager</b>-а не очень то и хочется, только для того, чтобы разобраться что это за настройки. К тому же я не уверен, что при различных обновлениях менеджера эти настройки не изменятся к худшему или лучшему, будут ли меняться от домена к домену или остануться статичными.</li>
				<li>Читать файлы журналов в папках, которые примонтированы внутрь какого-либо <b>Docker</b>-контейнера не самая лучшая идея. Могут возникнуть различные проблемы с правами доступа. Некоторые из этих проблем бывает сложно обнаружить, хотя, чаще всего, просто исправить. Это всё чревато либо отсутствием данных, либо их неполноценностью. В любом случае обнаружить то, что утилиты не видят данные или не могут ничего прочитать внутри настроенных вами файлов логов бывает сложно.</li>
				<li>В <b>Nginx Proxy Manager</b>-е есть только стандартные настройки безопасности. В <b>NGINX</b> же их море поколено. Если вам вдруг понадобится, чтобы <b>SSL</b> какого-либо домена был на 100%, то с <b>NPM</b> такого точно не будет. При добавлении того или иного домена в <b>NPM</b> на последней вкладке настроек можно добавить любые настройки вручную текстом. Вот только какие это настройки? Да и настраивать придётся каждый введёный прокси отдельно.</li>
				<li>При необходимости создать простейшую файлопомойку в <b>Nginx Proxy Manager</b> у вас ничего не получится. Такая функция в менеджере просто не поддерживается. Вам всё равно придётся создавать отдельный контейнер с <b>NGINX</b> или <b>Apache</b> на неком порту (или запускать их непосредственно в системе), и уже затем проксировать к сервису доступ через <b>Nginx Proxy Manager</b>. Самое забавное в том, что не понятно где лучше прописывать ручные настройки безопасности и <b>SSL</b> - в созданном отдельном контейнере для файлопомойки или в самом <b>Nginx Proxy Manager</b>-е на последней вкладке во время добавления прокси хоста. <u>В каком месте настройки будут работать, а в каком нет?</u></li>
			</ul>
			<p>Ещё одна проблема состоит в том, что с большим количеством файлов журналов может не только возникнуть путаница, но и на порядок возрастёт потребляемая оперативная память в <b>Fail2ban</b>-е. Насчёт нагрузки на процессор я не уверен.</p>
			<p>Прибавьте к описанным проблемам неизвестные параметры для <b>SSL</b> сертификатов, которые хотелось бы контролировать.</p>
			<p>У <b>Nginx Proxy Manager</b>-а есть ещё много других недостатков. Остановимся на описанных.</p>
			<p>Говоря о настройках безопасности, имеются введу следующие:</p>
			<ul>
				<li>NGINX DDoS (req limit).</li>
				<li>NGINX настройка файлов.</li>
				<li>NGINX настройка сжатия GZIP.</li>
				<li>NGINX X-XSS-Protection.</li>
				<li>NGINX X-Frame-Options.</li>
				<li>NGINX X-Permitted-Cross-Domain-Policies.</li>
				<li>NGINX Strict-Transport-Security.</li>
				<li>NGINX X-Content-Type-Options.</li>
				<li>NGINX настройки SSL.</li>
				<li>Nginx Отключение серверных токенов.</li>
				<li>Nginx Задание размеров буферов.</li>
			</ul>
			<p>И многие другие параметры. Это базовые, одни из наиболее важных, на мой взгляд, правил.</p>
			<p>Мне кажется, что такой менеджер подойдёт только новичкам, которые толком ничего не знают об <b>NGINX</b>. Хотя, по мне, так лучше сразу начать его изучать.</p>
			<p>К тому же, если у вас на сервере предполагается иметь некие конфедициальные или личные данные я бы сразу начал настраивать только <b>NGINX</b>.</p>
			<p>Объяснение всех описанных выше настроек безопасности для <b>NGINX</b> можете посмотреть в статье: <a target="_blank" href="../The-security-of-network-connections.html#part5.0"><b>&laquo;Безопасность сетевых соединений: 5. Fail2ban&raquo;</b></a>.</p>
			<p>Пример готовых настроек безопасности можно посмотреть в статье: <a target="_blank" href="./Configuratons_Linux_Servers.html#part16"><b>&laquo;Базовые настройки серверов Linux: 16. Nginx Reverse Proxy.&raquo;</b></a>.</p>
			<p>Если всё таки решите устанавливать <b>NPM</b> в <b>Docker</b>-контейнер вместо <b>NGINX</b>, но вместе с <b>Fail2ban</b>-ом, будьте готовы к множеству трудностей, среди которых оперативная память будет занимат далеко не последнее место.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part7"></a></p>
			<h2>7. Черный и белый списки.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava7 { 
					counter-reset: list3; /* Список первого уровня*/ 
				} 
				.glava7 li:before { /* Список первого уровня */ 
					counter-increment: list3; /* Увеличиваем значение счетчика */ 
					content: "7." counter(list3) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava7">
				<li><a href="#part7.1">Черный и белый список. Введение.</a></li>
				<li><a href="#part7.2">Скрипты.</a></li>
				<li><a href="#part7.3">Версии скриптов.</a></li>
				<li><a href="#part7.4">Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</a></li>
				<li><a href="#part7.5">Работа с логами, командами и выводом информации.</a></li>
				<li><a href="#part7.6">Работа с черным и белым списками.</a></li>
				<li><a href="#part7.7">IP(6)TABLES / NFTABLES.</a></li>
				<li><a href="#part7.8">Работа с таблицами и цепочками.</a></li>
				<li><a href="#part7.9">Сервисные команды скрипта.</a></li>
				<li><a href="#part7.10">Systemd.</a></li>
			</ol>
			<hr>
			<p><a name="part7.1"></a></p>
			<h3>7.1. Черный и белый список. Ведение.</h3>
			<p>Представьте себя на минутку почтальоном, который разносит квитанции на оплату ЖКХ или газа по квартирам вашего района и получаете за это повышенную зарплату, т.к. вручаете эти квитанции в руки, а не суете в почтовые ящики.  Из тысячи квартир в пяти квартирах живут агрессивные алкоголики, которые регулярно нападают на почтальонов. Пару раз вы порядочно получаете по голове и начинаете обходить эти квартиры стороной.</p>
			<p>Этой информацией вы делитесь со своими коллегами почтальонами, а также с другими службами, в чьи задачи входит обход квартир. Например, если специалисты, отвечающие за проверку счетчиков, пойдут по квартирам без вашего черного списка, то наверняка надолго запомнят встречу с этими алкоголиками. А если они воспользуются вашим черным списком, то обойдут стороной все "опасные" квартиры.</p>
			<p>Аналогичная ситуация и с IP-адресами: есть компании, которые отслеживают IP-адреса, осуществляющие DDoS-атаки, мошеннические действия, рассылающие спам, и добавляют эти адреса в свои черные списки (black list). А затем другие компании, в основном почтовые сервисы, интернет-провайдеры, платежные системы, банки, интернет-магазины, покупают проверку IP-адресов своих посетителей по этим базам.</p>
			<p><b>Черный список IP-адресов</b> - это список IP-адресов для блокировки, которые были идентифицированы как отправляющие спам или выполняющие другие нежелательные действия. Когда IP-адрес добавляется в "черный список", компьютеры, связанные с этим IP-адресом, больше не могут получать доступ к определенным вебсайтам.</p>
			<p><b>Белый список IP-адресов</b> — список доверенных IP-адресов, которым вы разрешаете доступ к приложениям вне зависимости от наличия в запросах признаков атак. Белый список имеет наиболее высокий приоритет среди других списков, поэтому при любом режиме фильтрации фаервола, последний не заблокирует запросы с IP-адресов из белого списка.</p>
			<p>Особенно часто страдают пользователи VPN. IP-адреса публичных VPN-сервисов регулярно попадают в черные списки ввиду того, что к услугам VPN-сервисов прибегают и киберпреступники. Если IP-адрес VPN-сервера попал в черный список, то проблемы возникнут у всех пользователей, подключенных к данному серверу VPN.</p>
			<p>Вы, естественно, не сможете никак проверить, не совершал ли кто-то ранее какие-либо преступления с полученного вами IP-адреса, а вот проверить наличие IP-адреса в черных списках может каждый.</p>
			<p>Это касается и персонального VPN или прокси, так как хостинг может предоставить вам сервер c «грязным» IP-адресом. В этом случае вам необходимо будет обратиться к хостинг-провайдеру и попросить замену.</p>
			<p>Помните, что черные списки не статичны и постоянно обновляются. Если вашим IP-адресом пользуется кто-то еще, IP-адрес может оказаться в черном списке в любое время. Сегодня он еще может быть белым и чистым, а завтра оказаться во всех популярных черных списках.</p>
			<p>Компаний, составляющих подобные списки, немало, но самая крупная и авторитетная – <a href="https://check.spamhaus.org/">Spamhaus</a>. Пользователи могут проверять наличие IP-адреса в списках Spamhaus абсолютно.</p>
			<p>Помимо Spamhaus, есть много других черных списков IP-адресов, однако они не получили широкого распространения и влияния. Проверить IP-адрес по другим спискам можно на сайте <a href="https://mxtoolbox.com/blacklists.aspx">MXtoolbox</a>.</p>
			<p>Вернемся к нашим алкоголикам, с которых мы начали разговор. Вы купили одну из квартир алкоголиков по более выгодной стоимости по сравнению с рыночной и въехали в неё. Вскоре вы замечаете, что вам не приходит корреспонденция, и идете на почту узнать, что произошло. Там выясняется, что ваша квартира в черном списке, и вы просите вычеркнуть вас из него. Почтальон говорит: «Хорошо» и вычеркивает – и вы снова получаете почту.</p>
			<p>Подобным образом работают и черные списки IP-адресов. Всегда можно удалить адрес из черного списка по обращению к модератору. Однако это не всегда просто, когда речь, например, идет об IP-адресе VPN или прокси. В это случае легче просто поменять IP-адрес.</p>
			<p>Если речь идет об IP-адресе, предоставленном интернет-провайдером, то, иногда, для его смены достаточно просто перезагрузить WiFI-роутер. Если это не помогло, обратитесь к вашему интернет-провайдеру с просьбой о смене IP-адреса.</p>
			<hr>
			<p>Теперь поговорим о черных и белый списках отдельных серверов. </p>
			<p>В данном случае речь идёт не об общедоступных черных списках IP-адресов известных компаний, которые регулярно обновляются, а о локальном списке, в который сервер собирает ip-адреса самостоятельно. Т.е. используя утилиты анализа логов сервер анализирует нежелательную и вредоносную активность и блокирует эти адреса. </p>
			<p>Можно провести аналогию с вышеупомянутыми алкоголиками. Допустим в одной из квартир до беспамятства, т.е. крепко, выпивают достаточно редко. Ну, т.е. только по большим праздникам. Вы, как почтальон, разносили письма и в один прекрасный день просто попали под горячую руку. Естественно, с этого момента именно эту квартиру, вы будете обходить стороной. Однако, буквально через пару недель, вы на улице, случайно, сталкиваетесь с этим же человеком лицом к лицу. Самое забавное в том, что человек то трезвый и спрашивает – почему вы не приносите ему корреспонденцию. Естественно вы объясняете ему причину, а мужчина тем временем извиняется и просит вновь приносить ему почту. И вы будете вынуждены вновь приходить к этой квартире.</p>
			<p>Таким образом вы, как почтальон, временно обходили нежелательный адрес стороной.</p>
			<p>Также и с ip-адресами в утилитах анализа. Они только временно блокируют вредоносную и нежелательную активность. Это время задается в настройках. Для постоянной блокировки необходимо использовать дополнительные программы и скрипты.</p>
			<p>При использовании дополнительных программ для постоянной блокировки ip-адреса, которые были временно заблокированы с помощью утилит анализа, сразу будут добавляться и в черный список и затем уже блокироваться постоянно, т.е. навсегда.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.2"></a></p>
			<h3>7.2. Скрипты.</h3>
			<p><b>Почему необходимо использовать стороннее ПО для постоянной блокировки?</b></p>
			<p>Дело в том, что если вы не будете проверять наличие ip-адреса в правилах брандмауэра и попытаетесь добавить этот же адрес ещё раз – он будет добавлен ещё раз, т.е. задвоен.</p>
			<p>Когда вам понадобится разблокировать адрес – вы будете разблокировать ip-адрес столько раз, сколько добавляли в правила брандмауэра.</p>
			<p><b>Такое поведение явно не приемлемо!</b></p>
			<p>Вот за этим и нужны сторонние скрипты или программы. Они как раз и проверяют наличие того или иного ip-адреса и в локальной базе черного списка и в правилах брандмауэра, чтобы адрес попадал в оба места только единожды.</p>
			<p>Причём самое интересное в том, что если вы добавили в правила фаервола ip-адрес с максимальной маской протокола, а затем решили добавить всю подсеть – оба адреса попадут и в эти правила и в базу данных черного списка. </p>
			<p>Например, 192.168.0.130/32 и 192.168.0.0/24. Очевидно что первый адрес принадлежит всей подсети второго адреса, но т.к. они разные любые скрипты и утилиты будут считать их разными. Поэтому оба таких адреса будут попадать и в список и в правила блокировки, т.е. в брандмауэр.</p>
			<p>Давайте рассмотрим несколько примеров вышеупомянутого поведения и в <b>IPTABLES</b> и в <b>NFTABLES</b>.</p>
			<p>Попробуем дважды добавить ip-адреса <b>&laquo;10.10.10.10/32&raquo;</b> и <b>&laquo;10.10.10.10/24&raquo;</b> в <b>IPATBLES</b>. И так же попробуем дважды их удалить оттуда.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-19.png" width="800px"/>
			</div>
			<p><b>Самое неприятное в том, что <b>IPTABLES</b> после добавления второго такого же ip-адреса сети начал жёстко лагать и подвисать!</b></p>
			<p>Проделаем тоже самое для <b>NFTABLES</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-20.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-21.png" width="800px"/>
			</div>
			<p><b>Как видите - также удалось!</b></p>
			<p>При этом каких-либо подвисаний <b>NFTABLES</b> замечено не было.</p>
			<hr>
			<p><b>Yandex</b> и <b>Google</b> в ответ на попытку отыскать программу или утилиту для работы с черным списком ip-адресов для <b>Linux</b> предлагают либо способы блокировки через <b>IPTABLES</b>, либо создавать такой скрипт самостоятельно.</p>
			<p>Ну а найденные утилиты или скрипты, мягко говоря, либо не оправдывают ожиданий, либо работают не совсем корректно, либо изготовлены только для <b>XTables</b>. А хотелось бы, чтобы они всё-таки работали с <b>nf_tables</b>.</p>
			<p><span style="color:green;"><b>Спешу вас обрадовать - такой скрипт уже существует и написан он вашим покорным слугой на языке &laquo;Python&raquo;.</b></span></p>
			<p><b>Не волнуйтесь!</b> <u>Скрипт многократно тестировался в течении нескольких недель на реальном VPS-сервере с реальными данными различных атак не только <b>BootNet</b>-сетей. Скрипт до сих пор там работает!</u></p>
			<p>Знакомьтесь со скриптом: <a target="_blank" href="https://github.com/maximalisimus/blacklist-scripts.git"><b>&laquo;py-blacklist.py&raquo;</b></a>. И у него имеется множество различных <a target="_blank" href="https://github.com/maximalisimus/blacklist-scripts/releases"><b>&laquo;Release-версии&raquo;</b></a>, большая часть из которых совместимы между собой.</p>
			<p>Например, во второй версии 1.0.1 немного оптимизирован вывод логов событий, т.е. я сделал их немного более красивыми и менее громоздкими. Да, изначально они были достаточно объемными и полными. Я их немного сократил, улучшил и сделал более приятными для чтения.</p>
			<p>Дело в том, что чем лучше логи программы тем быстрее и легче любому пользователю обнаружить и устранить ошибку или сбой.</p>
			<p>В третьей версии 1.0.2 слегка оптизирован способ получения аргументов командной строки и появилась дата модификации программы, а не только её изначальная дата создания. В остальном программа никак не изменилась.</p>
			<p>В 4-й версии 1.1.0 произведено уже немного более значительное улучшение - вывод информации об ip-адресах, добавленных в <b>nf_tables</b>, стал более точным и кратким.</p>
			<p>В пятой версии 2.0.0 добавлена функциональность отображения не только одних цепочек заданных таблиц <b>nf_tables</b>, но и просмотр самих таблиц.</p>
			<p>Таким образом запустив хоть 1-ю, хоть 5-ю версию - разницы в работе с программой особо не будет, потому что исправления касались по большей части не ошибок, а улучшений. Как только обнаружаться какие-либо ошибки или сбои об этом будет указано в 2 местах: в файле <b>&laquo;CHANGELOG.txt&raquo;</b> и в описании <b>&laquo;Release-версии&raquo;</b>.</p>
			<p><u>В репозитории с утилитой имеется &laquo;README.md&raquo; файл с описанием программы и обзором её ключей и параметров с РУСИФИКАЦИЕЙ всех меню.</u></p>
			<p>Проведём с моим скриптом тот же самый эксперимент - попробуем дважды добавить ip-адреса <b>&laquo;10.10.10.10/32&raquo;</b> и <b>&laquo;10.10.10.10/24&raquo;</b> в <b>IPATBLES</b>. И так же попробуем дважды их удалить оттуда.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-22.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-23.png" width="800px"/>
			</div>
			<p>А теперь также дважды проделаем те же самые операции по добавлению и удалению указанных ip-адресов в <b>nf_tables</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-24.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-25.png" width="800px"/>
			</div>
			<p>Перед работой с <b>nf_tables</b> я сбросил, т.е. обнулил, логи только для того чтобы сократить их вывод для данного примера.</p>
			<p>Посмотрим, что у нас в логах событий.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-26.png" width="800px"/>
			</div>
			<p>По мне так очень даже неплохой вывод журналов событий - понятно и эффективно. В случае обнаружения проблем - мы бы увидели здесь и саму ошибку и команды, которые вызвали проблемы.</p>
			<p><b>Да, я прекрасно понимаю, что это не совсем правильный способ ведения журнала событий. Этому моменту будет уделено отдельное внимание в главе: <a href="#part7.5">7.5. Работа с логами, командами и выводом информации</a>.</b></p>
			<p>В моём <b>Archlinux</b>-е <b>IPTABLES</b> не поддерживает работу с <b>nf_tables</b>, точнее говоря в ОС нет слоя совместимости для работы с последней. Поэтому для работы с <b>&laquo;Netfilter&raquo;</b>-ом мне необходимо отдельно установить утилиту <b>&laquo;nftables&raquo;</b>.</p>
			<p>На этом можно сыграть. Я специально, с помощью ключей и параметров моего скрипта, запущу заведомо неисправную команду системы по добавлению 2 указанных выше ip-адресов через утилиту <b>&laquo;nft&raquo;</b> в <b>nf_tables</b>.</p>
			<p>Посмотрим на журнал событий - как изменился вывод информации об ошибках?</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-27.png" width="800px"/>
			</div>
			<p>Как вы можете видеть - и во время добавления была выведена информация об ошибке, и ошибочной команде, и в журнале событий было отображено всё тоже самое + дата событий.</p>
			<p>Не очень красиво, зато удобно и понятно.</p>
			<p>В любом случае этот скрипт не просто полностью заменяет всю ручную работу с <a target="_blank" href="../The-security-of-network-connections.html#part6"><b>&laquo;Безопасностю сетевых соединений: 6. Блокировкой ip-адреса или всей подсети&raquo;</b></a>, но и имеет массу других встроеных методов по работе с <b>Netfilter</b>-ом как таковым.</p>
			<p>Например, при настройке фаервола <b>Firewalld</b>, если у вас используется <b>Docker</b> или любой другое подобное приложение с контейнерами - обязательно необходимо просматривать списки сетей и вносить новые <b>Docker</b>-сети в настройки фаервола.</p>
			<p>Просматривать их стандартными утилитами - <b>&laquo;ip&raquo;</b> или <b>&laquo;ifconfig&raquo;</b> не очень удобно, т.к. вывод команды просто огромен, а знать другие способы просмотра наизусть просто невозможно.</p>
			<p>По другому только один список доступных сетевых интерфейсов можно посмотреть так:</p>
			<p class="codes">
				<b>$</b> ls /sys/class/net
			</p>
			<p>И тут на сцену выступает мой <b>Python</b>-скрипт. Уже в версии <b>&laquo;2.2.0&raquo;</b> встроен дополнительный ключ просмотра списка доступных сетевых интерфейсов вот этой самой командой + этот момент указан внутри помощи программы.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.3"></a></p>
			<h3>7.3. Версии скриптов.</h3>
			<p>Файл <b>&laquo;CHANGELOG.txt&raquo;</b> - это обязательный стандарт для любой разрабатываемой программы или утилиты. Он представляет из себя простой текстовый файл в который обязательно необходимо записывать изменения, которые были произведены. Причём не обязательно подробно. Здесь конкретно указывается дата изменений, наименование файла, в котором были произведены изменения, версия программы - и далее <b>MarkDown</b> списком описание изменений.</p>
			<p>Причём желательно всё писать на английском языке, чтобы не только рускоязычные пользователи имели представление о чём идёт речь.</p>
			<p>Обязательно придумать и вставить какой-нибудь разделитель между разными датами изменений.</p>
			<p>Например, на момент создания главы этой статьи, в репозитории <b>&laquo;blacklist-scripts&raquo;</b>, в файл <b>&laquo;CHANGELOG.txt&raquo;</b> была внесена следующая информация:</p>
			<div class="codeses">
				<pre>-----
29.07.2023 - 09:20 GMT +3
py-blacklist 2.0.0:
* Added functionality for viewing not only some chains of specified NFTABLES tables, but also the tables themselves completely.
-----
29.07.2023 - 08:10 GMT +3
py-blacklist 1.1.0:
* The output of information about ip-addresses added to "nf_tables" has been replaced with a more accurate one.
-----
27.07.2023 - 08:02 GMT +3
py-blacklist 1.0.2:
* Optimization of ways to get command-line arguments.
* Added the date of creation and date of modification of the program.
-----
26.07.2023 - 08:59 GMT +3
py-blacklist 1.0.1:
* Optimization of event log output.
-----
25.07.2023 - 11:52 GMT +3
py-blacklist 1.0.0:
Basic stable version.
-----</pre>
			</div>
			<p>Что такое версия программы и как она строится?</p>
			<p>Версия представляет собой существенно изменённую программу или пакет программ, в который добавлены принципиально новые функции, используется иная организация программы, данных или применяются новые способы взаимодействия пользователя с программой. Как правило, новые модификации и версии имеют то же самое название, какое имел и исходный продукт.</p>
			<p>Версия состоит из нескольких чисел (как правило, трёх), разделённых точкой: например, 1.5.2.</p>
			<ul>
				<li>Первое из них — таршая версия (major), изменяется при кардинальных изменениях программы,</li>
				<li>второе — младшая версия (minor), изменяется при значительных изменениях функциональности,</li>
				<li>третья — мелкие изменения (maintenance, micro).</li>
			</ul>
			<p>Иногда через тире указывают номер выпуска, т.е. номер исправлений конкретных ошибок или сбоев в работе программы. Например, 1.5.1-1 или 1.5.1-3.</p>
			<p>При увеличении одного из чисел все идущие после него сбрасываются до нуля: 1.0.0, 1.0.1, 1.0.2, 1.1.0, 1.2.0, 1.2.1, 2.0.0 …</p>
			<p>Последний ноль может опускаться: 1.0.0 = 1.0.</p>
			<p>Иногда можно встретить и такую нумерацию:</p>
			<ul>
				<li>0 — альфа</li>
				<li>1 — бета</li>
				<li>2 — выпуск-кандидат</li>
				<li>3 — публичный выпуск</li>
			</ul>
			<p>Если вы вдруг видете, что нумерация в версиях ограничено 3-мя или 4-мя значениями каждой цифры - значит в этом случае можно понимать, что это за версия: альфа, бета тестирование или стабильный выпуск. В остальных случаях последний номер может и не значить ни альфу, ни бету.</p>
			<p>Можно иногда встретить и то, что третье число может означать несколько другую нумерацию стадий разработки:</p>
			<ul>
				<li><b>Альфа версия</b> - стадия тестирования приложения, число 0 или символ a.</li>
				<li><b>Бета версия</b> - стадия публичного тестирования приложения, число 1 или символ b.</li>
				<li><b>RC (Release candidate) релиз-кандидат</b> - стадия-кандидат на то, чтобы стать стабильной версией, число 2 или символы rc.</li>
				<li><b>RTM (Release To Manufacturing) релиз</b> - стабильная версия приложения, число 3 или символы rtm.</li>
				<li><b>GA (General availability)</b> - общедоступный релиз.</li>
			</ul>
			<p>В <b>Linux</b> утилитах встречается похожий тип нумерации версий: <b>&laquo;{major}.{minor}.{maintenance}-{revision}{development stage}&raquo;</b>. Причём, ревизия и стадия разработки не всегда в одном и том же порядке. Например: 2.0.5-23, 1.9.95-1rc, 5.0.r11084.a52b8759ff-1 и другие.</p>
			<p>Например, <b>Windows 7</b> на самом деле имеет нумерацию: <b>&laquo;Windiows NT 6.1.7600&raquo;</b>, а <b>Windows 7 Service Pack 1</b> - <b>&laquo;Windows NT 6.1.7601&raquo;</b>. <b>Windows 10 20H2</b> - <b>&laquo;Windows NT 10.0.19042&raquo;</b>, а <b>Windows 10 21H2</b> - <b>&laquo;Windows NT 10.0.22000&raquo;</b>.</p>
			<p>Тип нумерации версий утверждают перед первым релизом и обязательно декларируют этот тип в документации к программе, если он хоть немного отличается от привычного порядка.</p>
			<p>Порой можно встретить и нумерацию по дате изготовления. Например, версия дистрибутива какого-нибудь <b>Linux</b>-а.</p>
			<p>Если вы разрабатываете утилиту для себя, а не для компаний - намного удобнее, на мой взгляд, применять первоначально описанный способ нумерации: <b>&laquo;major.minor.maintenance-revision&raquo;</b>.</p>
			<p>Вообще-то, в <b>Python</b>, чаще всего, как раз и применяется именно такая нумерация, включая номер исправлений (ревизий) через тире. Если вам очень необходимо - можете также указывать и стадию разработки (альфа, бета, rc, rtm, ga). Обычно стадия опускается, т.е. не указывается. Разьве что в редких слуаях исключений.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.4"></a></p>
			<h3>7.4. Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</h3>
			<p>Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, но вы можете на него сослаться из любого другого места.</p>
			<p>В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux.</p>
			<p>Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка.</p>
			<p>При удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.</p>
			<div class="images">
				<img src="../image/Blacklists-image/soft-link.png" width="241px"/>
			</div>
			<p>Жесткая ссылка (hard link) является своего рода синонимом для существующего файла. Когда вы создаете жесткую ссылку, создается дополнительный указатель на существующий файл, но не копия файла. Жесткие ссылки выглядят в файловой структуре как еще один файл. Если вы создаете жесткую ссылку в том же каталоге, где находится целевой файл, то они должны иметь разные имена. Жесткая ссылка на файл должна находится в той же файловой системе, где и другие жесткие ссылки на этот файл.</p>
			<p>В Linux каждый файл имеет уникальный идентификатор - индексный дескриптор (inode). Это число, которое однозначно идентифицирует файл в файловой системе. Жесткая ссылка и файл, для которой она создавалась имеют одинаковые inode. Поэтому жесткая ссылка имеет те же права доступа, владельца и время последней модификации, что и целевой файл. Различаются только имена файлов. Фактически жесткая ссылка это еще одно имя для файла.</p>
			<p><b>Жесткие ссылки нельзя создавать для директорий! Жесткая ссылка не может указывать на несуществующий файл!</b></p>
			<div class="images">
				<img src="../image/Blacklists-image/hard-link.png" width="251px"/>
			</div>
			<p>Нас же интересуют только символьные ссылки.</p>
			<p><b>&laquo;/usr/bin/&raquo;</b> - Содержит исполняемые файлы различных программ, которые не нужны на первых этапах загрузки системы, например, музыкальные плееры, графические редакторы, браузеры и так далее.</p>
			<p>Обычно для запуска программ и утилит из любого места системы именно в этой папке располагают символьные ссылки. Естественно, они могут ссылаться почти в любое место в системе. Главный критерий - чтобы файлы, на который они ссылаются, были исполняемыми. Т.е. имели флаг исполнения (выполнения).</p>
			<p>Поэтому, удобнее всего, для какого-либо скрипта или программы создать символьную ссылку в этот каталог с неким, удобным для вас, наименованием.</p>
			<p>Например, у меня в каталоге пользователя <b>&laquo;user&raquo;</b> имеется некий скрипт <b>&laquo;script.sh&raquo;</b>, который я хочу запускать по наименованию: <b>&laquo;black&raquo;</b>.</p>
			<p class="codes">
				<b>$</b> sudo ln -s /home/user/script.sh /usr/bin/black<br><br>
				<span style="color:blue;"># и обязательно флаг исполняемости скрипта</span></br>
				<b>$</b> chmod +x ~/script.sh
			</p>
			<p>И теперь можно запускать этот скрипт по имени <b>&laquo;black&raquo;</b> из любого места системы.</p>
			<p>Чтобы создать символьную ссылку в <b>&laquo;/usr/bin/&raquo;</b> на мой скрипт <b>&laquo;py-blacklist.py&raquo;</b>, можно воспользоваться аналогичной командой. Допустим, что скрипт находится в каталоге <b>&laquo;/etc/blaclist-scripts&raquo;</b>. Для примера назовём скрипт: <b>&laquo;blacklist&raquo;</b>.</p>
			<p class="codes">
				<b>$</b> sudo ln -s /etc/blaclist-scripts/py-blacklist.py /usr/bin/blacklist</br></br>
				<span style="color:blue;"># Флаг исполняемости скрипта</span></br>
				<b>$</b> sudo chmod +x /etc/blaclist-scripts/py-blacklist.py
			</p>
			<p>На самом деле, создавать символьную ссылку вручную, описанным выше способом, вообще не обязательно, т.к. в моём скрипте такие команды поддерживаются и выполняются автоматически при указании определённого ключа командной строки. Достаточно сделать сам скрипт исполняемым и запусть его с нужным ключом. Если захотите поменять наименование символьной ссылки здесь тоже содержится специальный параметр.</p>
			<p>Посмотрим на простое создание символьной ссылки через специальный ключ.</p>
			<p class="codes">
				<span style="color:blue;"># Флаг исполняемости скрипта</span></br>
				<b>$</b> sudo chmod +x /etc/blaclist-scripts/py-blacklist.py</br></br>
				<span style="color:blue;"># Создание ссылки</span></br>
				<b>$</b> /etc/blaclist-scripts/py-blacklist.py service -link
			</p>
			<p>В этом же <b>&laquo;service&raquo;</b> меню имеются ещё 2 важных ключа: <b>&laquo;-name&raquo;</b> и <b>&laquo;-unlink&raquo;</b>.</p>
			<p>После введения первого ключа вы можете задать любое другое имя символьной ссылки для расположения её в <b>&laquo;/usr/bin/&raquo;</b> каталоге исполняемых программ.</p>
			<p>А вот второй ключ, при таковой необходимости, удалит эту символьную ссылку из <b>&laquo;/usr/bin/&raquo;</b>.</p>
			<p>Самое важное в том, что где бы скрипт не находился - он создаст правильную ссылку на себя в каталог <b>&laquo;/usr/bin/&raquo;</b>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.5"></a></p>
			<h3>7.5. Работа с логами, командами и выводом информации.</h3>
			<p>Логи - текстовые записи событий какой-либо программы. Чаще всего это обычный текстовый файлик. Их ещё называют журналами событий отдельно взятой утилиты.</p>
			<p>Журнал событий нужен для ведения хронологии — что в какой момент сработало и с какими параметрами.</p>
			<p>По журналу событий может не только разработчик понять что и где не работает, но и обычный пользователь будет полезно знать эту информацию. Такая информация позволяет в разы ускорить разбор ошибок и сбоев и в короткое время устранить их.</p>
			<p>Чем тщательнее логи - тем лучше и для разработчика и для пользователя программы. Однако, стоит понимать, что чем объемнее журнал событий - тем труднее его читать.</p>
			<p>В моём случае в скрипте журнал событий сильно избыточный. Однако, заметьте, что он достаточно подробный, а главно его удобно читать, не смотря на объемность данных.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-27.png" width="800px"/>
			</div>
			<p>В последнем обновлении <a target="_blank" href="https://github.com/maximalisimus/blacklist-scripts/releases">&laquo;скрипта&raquo;</a> я исправил этот недостаток и привёл журнал событий к каноническому виду.</p>
			<p>При этом сократился объем журнала и читать его стало в разы удобнее.</p>
			<p>Давайте посмотрим на пример записей журнала скрипта после обновления. В данном случае приведён пример блокировки и разблокировки ip-адресов неких <b>BootNet</b>-сетей.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-28.png" width="800px"/>
			</div>
			<p>Количество типов событий в любом журнале ограничено - их всего 5. Существуют одноименные <b>&laquo;Уровни логирования&raquo;</b>. Чем выше уровень — тем серьёзнее неприятность, о которой сообщает соответствующая запись. Самый низкий уровень логирования — это <b>debug (10)</b>, а самый высокий — это <b>critical (50)</b>.</p>
			<p>Вот краткие характеристики уровней логирования. Жирным шрифтом обозначены типы событий в самом журнале.</p>
			<ul>
				<li>
					<b>DEBUG</b>
					 - 
					<i>Debug (10)</i>
					 - самый низкий уровень логирования, предназначенный для отладочных сообщений, для вывода диагностической информации о приложении.
				</li>
				<li>
					<b>INFO</b>
					 - 
					<i>Info (20)</i>
					 - этот уровень предназначен для вывода данных о фрагментах кода, работающих так, как ожидается.
				</li>
				<li>
					<b>WARNING</b>
					 - 
					<i>Warning (30)</i>
					 - этот уровень логирования предусматривает вывод предупреждений, он применяется для записи сведений о событиях, на которые программист обычно обращает внимание. Такие события вполне могут привести к проблемам при работе приложения. Если явно не задать уровень логирования — по умолчанию используется именно warning.
				</li>
				<li>
					<b>ERROR</b>
					 - 
					<i>Error (40)</i>
					 - этот уровень логирования предусматривает вывод сведений об ошибках — о том, что часть приложения работает не так как ожидается, о том, что программа не смогла правильно выполниться.
				</li>
				<li>
					<b>CRITICAL</b>
					 - 
					<i>Critical (50)</i>
					 - этот уровень используется для вывода сведений об очень серьёзных ошибках, наличие которых угрожает нормальному функционированию всего приложения. Если не исправить такую ошибку — это может привести к тому, что приложение прекратит работу.
				</li>
			</ul>
			<p>Более подробно о принципе ведения журналов событий в <b>Python</b> вы можете посмотреть в статье: <a href="https://habr.com/ru/companies/wunderfund/articles/683880/"><b>&laquo;Логирование в Python: руководство разработчика&raquo;</b></a>.</p>
			<p>Приведу пример ручного добавления аналогичных <b>Python</b>-у записей в журнал событий для <b>BASH</b>-скриптов.</p>
			<p>Обязательно перед процессом логирования задайте путь к файлу журнала событий. Желательно полный путь, а не относительный. В идеале добавьте дополнительный ключ для того, чтобы пользователи могли изменить местоположения файла-логов для данного скрипта.</p>
			<p>Для данного примера достаточно будет следующей модели добавления событий, которую вы можете усложнять уже по своему усмотрению.</p>
			<div class="codeses" style="background-color:black;color:white;">
				<pre><span style="color:red;">#!/bin/bash</span>

filelog=<span style="color:#ffa500;">"./test_log.log"</span>
<span style="color:blue;">function</span> log() {
	datetime=<span style="color:green;">$(date '+%Y-%m-%d %H:%M:%S,%Z %:::z')</span>
	current_level=<span style="color:#ffa500;">"${1}"</span>
	outfile=<span style="color:green;">$(readlink -e "${2}")</span>
	message=<span style="color:#ffa500;">"${3}"</span>
	echo <span style="color:#ffa500;">"${datetime} ${current_level} \"${message}\""</span> >> <span style="color:blue;">${outfile}</span>
}
<span style="color:red;"># DEBUG INFO WARNING ERROR CRITICAL</span>
log <span style="color:#ffa500;">"DEBUG" "${filelog}" "A DEBUG Message"</span>
log <span style="color:#ffa500;">"INFO" "${filelog}" "An INFO Message"</span>
log <span style="color:#ffa500;">"WARNING" "${filelog}" "A WARNING Message"</span>
log <span style="color:#ffa500;">"ERROR" "${filelog}" "An ERROR Message"</span>
log <span style="color:#ffa500;">"CRITICAL" "${filelog}" "A message of CRITICAL severity"</span></pre>
			</div>
			<p><b>Обратите внимание</b> на переменную <b>&laquo;outfile&raquo;</b>. Она нужна для того, чтобы преобразовать относительный путь в абсолютный. Её всегда вводят в скрипт только после введения относительного пути. Здесь же, чтобы перестраховаться она введена внутри ведения лога. Это сделано скорее для удобства. Например, у вас в скрипте имеется аргумент командной строки для изменения местоположения файла логов. При этом вам не нужно заботиться о том, чтобы указывать полный путь к файлу - можно указать короткий, относительно места запуска скрипта.</p>
			<p>Естественно вы можете по по своему усмотрению поменять порядок присвеоения переменных внутри функции так как будет удобно именно вам. Здесь же приведён только пример.</p>
			<p>В идеале, помимо самих событий, в случае обнаружения ошибок, необходимо выводить в журнал не только ошибки, но и команды, которые не удалось выполнить. Так и разработчик и пользователь будут понимать в каком месте произошёл сбой. Это даёт гораздо большее понимание сути ошибок. Это понимание в разы ускоряет получение средств и способов устранения последних.</p>
			<p>У меня в скрипте, в случае обнаружения ошибок, в журнал отправляются не только сами ошибки, но и не удачно выполненные команды.</p>
			<p>Помимо этого, в моём скрипте я ввел как дополнение ключ <b>&laquo;-cmd&raquo;</b>. При этом все дальнейшие ключи и параметры приводят к тому, что в результате программа не будет выполнена. Вместо этого на экран будут выведены результирующие команды, которые должны были выполниться. Т.е. таким образом можно посмотреть на различные команды <b>IP(6)TABLES / NFTABLES</b>.</p>
			<p>Например.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-30.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-31.png" width="800px"/>
			</div>
			<p>Таким образом просто добавляете ключ <b>&laquo;-cmd&raquo;</b>, вводите нужные вам дополнительные параметры и смотрите на результат нужной вам команды.</p>
			<p>Что касается просмотра содержимого черного или белого списков - то у вас здесь 3 режима просмотра + возможность сохранения результата просмотра в любой указанный вами файл.</p>
			<ul>
				<li>Без ключа <b>&laquo;-c&raquo;</b> - также как и с этим ключом, но со значением <b>&laquo;0&raquo;</b> - посмотреть все имеющиеся ip-адреса и количество раз, сколько раз они уже были забанены.</li>
				<li>С ключом <b>&laquo;-c&raquo;</b> и значениями больше <b>&laquo;1&raquo;</b>-ы - вывести все ip-адреса забаненные больше или равно указанного количества раз.</li>
				<li>При указании ключа <b>&laquo;-j&raquo;</b> - формат отображения превращается в <b>JSON</b>.</li>
			</ul>
			<p>Обратите внимание на то, что при использовании <b>JSON</b>-формата - ввод значений количества банов уже не будет иметь никакого влияния на вывод информации. Выведен будет весь список без исключений.</p>
			<p>Давайте посмотрим на несколько примеров всех этих команд на примере черного списка нескольких <b>BootNet</b>-сетей. Список соответственно я сократил, чтобы вывод был не такой огромный. + к этому немного подправил количество банов, чтобы пример был более наглядным.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-32.png" width="800px"/>
			</div>
			<p>Помимо указанных функций и вводе ключа <b>&laquo;-o&raquo;</b> или <b>&laquo;-output&raquo;</b>, с указанием файла вывода - то, что выводится на экран можно будет сохранить в отдельный файл в любом формате.</p>
			<p><u><b>Я веду к тому, что в любых скриптах важно не только показать какой-либо результат, сохранить то или иное событие в логах, но и также дать пользователям возможность сохранять данные в любом формате в указанное ими место в системе. Также, правильный формат журналов событий поможет не только вам как разработчикам. А работа с форматом JSON позволит выйти на новый уровень зрелости ваших программ и скриптов, т.к. в мире всё чаще и чаще применяют в той или иной области именно этот формат. А значит вам в разы станет легче, когда-нибуь в будущем, совместить ваше приложение с каким-либо другим, т.е. чужим.</b></u></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.6"></a></p>
			<h3>7.6. Работа с черным и белым списками.</h3>
			<p>Из главы <a href="#part7.1">&laquo;7.1. Черный и белый список. Введение.&raquo;</a> вы уже знаете зачем нужны черный и белый список ip-адресов.</p>
			<p>Заострю ваше внимание только на том, что в любых скриптах и утилитах обязательно должны раздельно сосуществовать оба списка! Причем при запуске программы сначала в <b>Netfilter</b> добавляются все ip-адреса без исключений из белого списка с правилами <b>ACCEPT</b>, и затем уже по вашему усмотрению или настройкам ip-драеса из черного списка с правилами <b>DROP</b>.</p>
			<p>Чаще всего любой пользователь изначально - это глупый пользователь и только со временем зреет и умнее. Это же касается и системных администраторов и программистов и многих других людей.</p>
			<p><b>Нет, я чейчас не оскорбляю людей. Здесь дело в другом.</b></p>
			<p><span style="color:blue;">Приведу один простой пример необходимости белого списка.</span></p>
			<p>Чаще всего, в большинстве современных организаций, особенно ГОС - ip-адрес на выходном в интернет роутере установлен белый, т.е. статичный. Редко можно встретить компанию, чей ip-адрес был бы динамическим, т.е. серым.</p>
			<p>Представьте себе ситуацию - у вас в организации есть сервер, но у вас нет доступа к управлению роутером, т.к. он в управлении вышестоящеего подведомства, которое запретило каким-либо образом менять его конфигурацию. При этом вам необходимо настроить удалённый доступ для нескольких сотрудников и вы не можете пробросить порты в роутере по вышеуказанной причине.</p>
			<p>Еественно выходом из ситуации - будет установка и настройка <b>VPS</b>-сервера и <b>VPN</b> соединения. Вы покупаете, устанавливаете и настраиваете его. Затем в нём же несколько сервисов, защита и многое другое. После чего рассказываете вашим коллегам как получить доступ к серверу в организации.</p>
			<p>Через какое-то время к вам прибегают эти же сотрудники и кричат, что ничего не работает.</p>
			<p>Вы тут же пытаетесь соединиться с вашим <b>VPS</b>-сервером и понимаете, что и сами не можете получить к нему доступ, даже по <b>SSH</b>.</p>
			<p>Всё дело не в в чрезмерности настроек безопасности. Например, в <b>Fail2ban</b>. Без них на ваш сервер будут регулярно стучаться <b>BootNet</b>-сети. И хорошо, если они не натворят плохих дел. Любая <b>BootNet</b>-сеть, скорее всего, просто положит ваш сервер. Правильнее говоря, такая сеть будет отправлять на сервер шквал неверных запросов. В результате никакой <b>NGINX</b> не справится с нагрузкой, да и сами сервисы тоже. И как результат - и сервисы и сам <b>NGINX</b> зависают. А перезапустить их работу можно только вручную.</p>
			<p>Это хорошо если на сервер будут стачаться только <b>BootNet</b>-сети. А бывает гораздо хуже. Если у вас имеются хоть какие-то конфедициальные или личные данные в ваших сервисах - лучше уже точно сделать эти настройки безопасности, чем жалеть о том, что они скомпрометированы или использованы злоумышленниками не в самых лучших целях.</p>
			<p><u>Когда у любого пользователя не работает веб-сайт или веб-сервис - что мы с вами делаем??? - Правильно - пытаемся перезагрузить веб-страницу! Вместо того, чтобы немного подождать. Потом ещё и ещё разочек ... В принципе, так делают большинство людей в мире. Это обычное дело.</u></p>
			<p>Конечно это дело привычки, и отучиться можно от чего угодно.</p>
			<p>В результате сервер просто не успевает обработать запрос, а следовательно и ответить. А далее, как правило, практически все утилиты анализа файлов журналов думают, что это одна из <b>5xx-ых</b> ошибок сервера или <b>4xx-ых</b> ошибок запросов.</p>
			<p>Например, <b>403</b> или <b>501</b>.</p>
			<p>Достигая лимита обращений к серверу - утилиты анализа блокируют пользователям доступ. Через несколько таких блокировок ip-адрес благополучно попадает в черный список. И как результат у пользователей совсем перестаёт работать доступ.</p>
			<p>И они прибегают к вам с воплями!</p>
			<p>Без белого списка ip-адресов, вы, будучи находясь в неком подведомстве, откуда один из пользователей потерял доступ к вашему <b>VPS</b>-серверу, и сами не сможете зайти на сервер по <b>SSH</b>-соединению.</p>
			<p>Не сможете, потому, что ip-адрес подведомства уже был внесён в черный список и при попытке подключиться по <b>SSH</b> он просто блокируется правилами <b>DROP</b> в таблицах <b>INPUT</b> фаервола. Поэтому запрос не может пройти дальше таблиц входящих соединений фаервола.</p>
			<p>В результате вам приходится заходить в панель хостинга сервера и через веб-панель вручную сбрасывать блокировки.</p>
			<p><b>Это хорошо, если у сервера есть панель управления как у хостинга сайтов. А если нету? Доступ потерян навсегда? Как исправить?</b></p>
			<p>Всё бы ничего, но даже с объяснением пользователям - они скорее всего машинально будут продолжать перезагружать веб-страницу. В какой-то момент вам снова придётся их разблокировать.</p>
			<p>Если бы у вас был белый список ip-адресов, вы бы смогли внести его и в настройки утилит унализа лог-файлов и в скрипт в качестве постоянных разрешений. Таким образом подобная ситуация с разблокировкой никогда не возникнет.</p>
			<p>А возможно вы и сами по глупости можете что-нибудь натворить. И вот чтобы даже ваша глупость не обернулась для вас крахом - обязательно нужен белый список ip-адресов.</p>
			<p>В моей <b>ГОС</b>-организации статичный белый ip-адрес по умолчанию. Также, у меня дома используется провайдер <b>РОСТЕЛЕКОМ</b>-а. Через личный кабинет оф. сайта я написал им в тех-поддержку и за определённую доплату подключил статичный ip-адрес.</p>
			<p>Оба ip-адреса я внёс в белый список на моём <b>VPS</b>-сервере - и в настройки <b>Fail2ban</b>-а и в белый список скрипта <b>&laquo;py-blacklist.py&raquo;</b>. Чтобы даже если что-нибудь бы не сработало в <b>Fail2ban</b>-е - или если я сам натворю что-нибудь по глупости - эти адреса в любом случае в <b>Netfilter</b>-е всегда были в разрешающих правилах.</p>
			<p>Не у всех провайдеров поддерживается статичный ip-адрес. Однако, из ситации есть несколько выходов:</p>
			<ul>
				<li>DDNS.</li>
				<li>Дополнительный VPN.</li>
				<li>OpenVPN.</li>
			</ul>
			<p>И другие.</p>
			<p><b>DDNS</b> - есть и бесплатные, причём вполне адекватные.</p>
			<p>С дополнительным VPN будьте осторожнее. Во первых скорость значительно упадёт, во вторых не факт, что выданным вам IP-адресом не пользовались киберпреступники.</p>
			<p>А вот с <b>OpenVPN</b> всё немного интереснее. Скорость понятное дело упадёт. А вот ip-адреса бесплатных сервисов лучше вообще не брать. Мда, платить врядли кто-нибудь хочет. Но и злоумышленники чаще всего тоже. Ведь для них всегда необходимо иметь возможность быстро сменить адрес. С покупным быстро не сменишь. К тому же, это лишний кибер-след для отслеживания. Сколько надо купить адресов тогда - круглая сумма, к тому же явно не выгодная. А потому лучше лишний раз заплатить за адрес, который, скорее всего, ни разу ни у кого не был.</p>
			<p><span style="color:blue;">Приведу ещё один короткий пример.</span></p>
			<p>Когда я только настраивал <b>Fail2ban</b> - я изучал возможности регулярных выражений в фильтрах.</p>
			<p>К тому моменту я уже понимал, что эти регулярные выражения можно применять и в <b>BASH</b>-командах.</p>
			<p>Я вдруг сильно-сильно захотель отфильтроввать хотя бы суточной давности ip-адреса для внесения в черный список. Собственно я так и сделал - воспользовавшись новоиспечённой командой, но не подумав о белом списке.</p>
			<p>Как только я запустил блокировку этого списка - потерял доступ к серверу. Меня даже выбросило из <b>SSH</b>.</p>
			<p>Ну, я думал всё - капут. Нет, пришлось вручную заходиться на сервер через панель управления и долго долго выяснять - почему меня выбросило и исправлять всё.</p>
			<p>Именно в этот момент и зародился второй - белый список в новоиспечённом скрипте.</p>
			<p><span style="color:red;"><b>Глупость конечно глупостью, но ситуация то ведь не редкая!</b></span></p>
			<p>Для работы с черным и белым списками в моём скрипте <b>&laquo;py-blacklist.py&raquo;</b> предусмотрено 2 раздельных меню с одинаковым набором команд: меню <b>&laquo;black&raquo;</b> и <b>&laquo;white&raquo;</b> соответственно.</p>
			<p>Меню <b>black</b>:</p>
			<div class="codeses">
				<pre><b>$</b> sudo ./py-blacklist.py black

usage: py-blacklist.py black [-h] [-ban] [-unban] [-a] [-d] [-s] [-j] [-save]
                             [-o OUTPUT] [-empty] [-ip IP [IP ...]]
                             [-m MASK [MASK ...]]

Опции:
  -h, --help            Показать справку и выйти
  -ban, --ban           Заблокировать ip-адреса в {IP,IP6,NF}TABLES.
  -unban, --unban       Разблокировать ip-адреса в {IP,IP6,NF}TABLES.
  -a, --add             Добавить в черный список.
  -d, --delete          Удалить из черного списка.
  -s, --show            Посмотреть черный список.
  -j, --json            JSON формат просмотра.
  -save, --save         Сохранить.
  -o OUTPUT, --output OUTPUT
                        Выходной файл черного списка.
  -empty, --empty       Очистить черный список. Используйте осторожно!

Addressing:
  IP address management.

  -ip IP [IP ...], --ip IP [IP ...]
                        IP адреса.
  -m MASK [MASK ...], --mask MASK [MASK ...]
                        Маски сетей.</pre>
			</div>
			<p>Меню <b>white</b>:</p>
			<div class="codeses">
				<pre><b>$</b> sudo ./py-blacklist.py white

usage: py-blacklist.py white [-h] [-ban] [-unban] [-a] [-d] [-s] [-j] [-save]
                             [-o OUTPUT] [-empty] [-ip IP [IP ...]]
                             [-m MASK [MASK ...]]

Опции:
  -h, --help            Показать справку и выйти
  -ban, --ban           Разрешить ip-адреса в {IP,IP6,NF}TABLES.
  -unban, --unban       Удалить разрешения из {IP,IP6,NF}TABLES.
  -a, --add             Добавить в белый список.
  -d, --delete          Удалить из белого списка.
  -s, --show            Посмотреть белый список.
  -j, --json            JSON формат просмотра.
  -save, --save         Сохранить.
  -o OUTPUT, --output OUTPUT
                        Выходной файл белого списка.
  -empty, --empty       Очистить белый список. Используйте осторожно!

Addressing:
  IP address management.

  -ip IP [IP ...], --ip IP [IP ...]
                        IP адреса.
  -m MASK [MASK ...], --mask MASK [MASK ...]
                        Маски сетей.</pre>
			</div>
			<p>Оба меню <b>black</b> и <b>white</b> поддерживают множественное введение ip-адресов. Маска адреса указывается через обратный слеш - «/». Например: 192.168.0.2/32. При этом вы вполне можете указать и ipv4 и ipv6 в одной команде. Протокол автоматически будет поправлен в процессе работы с адресом.</p>
			<p>Например - добавим 2 адреса с разным протоколом в черный список:</p>
			<p class="codes">
				<b>$</b> sudo ./py-blacklist.py black -ip 192.168.0.2 2001:db8:abf2:29ea:5298:ad71:2ca0:4ff1 -a -save
			</p>
			<p>или так:</p>
			<p class="codes">
				<b>$</b> sudo ./py-blacklist.py black -ip 192.168.0.2/32 2001:db8:abf2:29ea:5298:ad71:2ca0:4ff1/128 -a -save
			</p>
			<p>Обратите внимание на то, что если вы не будете указывать маску - она будет применена автоматически. По умолчанию автоматическая маска ставится максимальной согласно протоколу адреса - IPV4 или IPV6.</p>
			<p>Либо маску можно указать отдельным ключом. НО, в этом случае количество масок должно быть равно количеству вводимых ip-адресов!</p>
			<p class="codes">
				<b>$</b> sudo ./py-blacklist.py black -ip 192.168.0.2 2001:db8:abf2:29ea:5298:ad71:2ca0:4ff1 -m 32 128 -a -save
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.7"></a></p>
			<h3>7.7. IP(6)TABLES / NFTABLES.</h3>
			<p>В моём скрипте <b>&laquo;py-blacklist.py&raquo;</b> предусмотрена работа с 2-мя таблицами <b>NetFilter</b>-а: и с <b>&laquo;{IP,IP6}TABLES&raquo;</b> и с <b>&laquo;NFTABLES&raquo;</b>. Т.е. и с фреймворком <b>&laquo;XTables&raquo;</b> и с <b>&laquo;nf_tables&raquo;</b>.</p>
			<p>Для переключения между фреймворками используются дополнительные ключи и параметры.</p>
			<p>При введении ключа <b>&laquo;-nft&raquo;</b> вы начинаете работу с <b>NFTABLES</b>. Без него вы будете работать только с <b>IPTABLES</b> и <b>IP6TABLES</b>. При этом, при работе с последними 2-мя таблицами, не имеет значения что вы будете вводить по ключам наименования таблиц и цепочек. Значения будут автоматически програмно перезаписаны в целях безопасности.</p>
			<p>При выборе ключа <b>&laquo;-personal&raquo;</b> и ключа <b>&laquo;-nft&raquo;</b> программа выбирет предопределённые таблицы и цепочки во фрейворке <b>NFTABLES</b>. При этом не имеет значения, что вы будете пытаться вводить соответствующими ключам. Все значения будут переопределены програмно.</p>
			<p>Тоже самое касается ключей <b>&laquo;-run&raquo;</b> и <b>&laquo;-fine&raquo;</b>. Первый определяется вместо использования 2 ключей <b>&laquo;-newtable&raquo;</b> и <b>&laquo;-newchain&raquo;</b>. Ну т.е. когда используются оба последних ключа, проще указать один <b>&laquo;-run&raquo;</b> вместо 2 ключей. Для <b>&laquo;-fine&raquo;</b> соответственно будет аналогичное обращение ко всем функциям очистки и удаления таблиц и цепочек после завершения работы приложения.</p>
			<p>Также такое обращение по указанным выше ключам будет автоматически применено в меню управления сервисом <b>Systemd</b>, т.е. учтено при создание сервиса и таймера.</p>
			<p>При удалении и очистки таблиц и цепочек есть определённые ограничения, связанные со стандартными таблицами и цепочками системы в пакетах со слоем совместимости между <b>NFTABLES</b> и <b>IP(6)TABLES</b> <i>Netfilter</i>-а. Поэтому не удивляйтесь если таблица или цепочка не была удалена из системы или не была очищена. Это сделано только для безопасности.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.8"></a></p>
			<h3>7.8. Работа с таблицами и цепочками.</h3>
			<p>Как вы уже знаете из пунтка <a href="#part4.4"><b>&laquo;4.4. NFTABLES.&raquo;</b></a>, что работать с <b>&laquo;NFTABLES&raquo;</b> немного сложнее, чем с <b>&laquo;IP(6)TABLES&raquo;</b>, т.к. здесь нет ни стандартных таблиц, ни стандартных цепочек. Все таблицы и цепочки вы создаете самостоятельно.</p>
			<p>Работа с таблицами и цепочками очень хорошо описана в <a target="_blank" href="https://wiki.archlinux.org/title/Nftables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: nftables (Русский)&raquo;</b></a> и в более короткой версии - <a target="_blank" href=""><b>&laquo;Безопасности сетевых соединений: 6. Блокировке ip адреса или всей подсети&raquo;</b></a>.</p>
			<p>В этом же пункте будет рассказано о тех же самых командах, но в контексте использования скрипта <a target="_blank" href="https://github.com/maximalisimus/blacklist-scripts/blob/main/py-blacklist.py"><b>&laquo;py-blacklist.py&raquo;</b></a>, которые заранее в него встроены. Это сделано только для упрощения взаимодействия со всем <b>Netfilter</b>-ом как таковым и также для более безопасного на него воздействия.</p>
			<p>Да, в этом скрипте предусмотрены некоторые защитные механизмы. Поэтому накосячить с ним будет в разы сложнее.</p>
			<p><span style="color:blue;"><b>Поработаем пока над nf_tables.</b></span></p>
			<p>Для начала необходимо узнать список доступных таблиц <b>NFTABLES</b>.</p>
			<p class="codes">
				<b>$</b> sudo ./py-blacklist.py -nft service -show -tb
			</p>
			<p>Ответ будет примерно такой:</p>
			<p class="codes">
				table ip nat</br>
				table ip filter</br>
				table inet firewalld</br>
				table ip firewalld</br>
				table ip6 firewalld</br>
				table ip6 filter
			</p>
			<p>Возможно у вас будет другой ответ. У меня все необходимые таблицы и цепочки заранее созданы. У вас их скорее всего не будет и их будет необходимо создать.</p>
			<p>Нам важно понимать, что либо мы будем работать с универсальным протоколом <b>&laquo;inet&raquo;</b>, т.е. отдельной и таблицей и цепочкой для всех типов адресов - <b>&laquo;IPV4&raquo;</b> и <b>&laquo;IPV6&raquo;</b>, либо мы работаем со стандартными протоколами <b>&laquo;IP&raquo;</b> и <b>&laquo;IP6&raquo;</b>.</p>
			<p>Разница в том, что в первом случае все ip-адреса и <b>&laquo;IPV4&raquo;</b> и <b>&laquo;IPV6&raquo;</b> будут попадать в одну и ту же таблицу и цепочку. Во втором случае их обязательно необходимо разделять на разные таблицы и цепочки, если не хотите получить массу системных ошибок.</p>
			<p>К счастью, скрипт автоматически разделит все типы ip-адресов на <b>&laquo;ip&raquo;</b> и <b>&laquo;ip6&raquo;</b> и поместит тот или иной адрес в нужную таблицу и цепочку.</p>
			<p><span style="color:red;"><b>НО! Чтобы скрипт автоматически поместил тот или иной ip-адрес в нужную таблицу и цепочку - их необходимо создать перед использованием!</b></span></p>
			<p>Вот за этим и необходимо было просматривать все списки таблиц. В этом списке необходимо найти <u><b>2 одинаковые таблицы, но с разным протоколом</b></u>. У них в названии должен быть - <b>&laquo;ip&raquo;</b> и <b>&laquo;ip6&raquo;</b>. Даже если вы оставили название таблицы и цепочки по умолчанию - таких таблиц и цепочек может и не существовать, но всё равно должно быть 2-е, для 2-ух разных протоколов - <b>&laquo;IPV4&raquo;</b> и <b>&laquo;IPV6&raquo;</b>.</p>
			<p>Хорошим примером подобного ответа будет любая виртуальная машина с <b>&laquo;Debian 11&raquo;</b> на борту.</p>
			<p>Зачем нам 2 разные таблицы?</p>
			<p>Дело в том, что <b>&laquo;IPV6&raquo;</b> адреса не могут быть помещены в таблицу и цепочку с протоколом <b>&laquo;IPV4&raquo;</b>, и в результате возникнет ошибка выполнения команды и ip-адрес не будет заблокирован. Хорошим примером, автоматического создания 2 разных таблиц и цепочек для 2 указанных протоколов будет фаервол <b>Firewalld</b>. Если вы заметили, в первом ответе на список таблиц, у меня имеются 2 таблицы для этого фаервола. Они создались автоматически для 2 разных протоколов связи, во время его установки.</p>
			<p><u>Однако, таблиц то всё равно 2!</u></p>
			<p>Чтобы создать таблицу через скрипт <b>&laquo;py-blacklist.py&raquo;</b>, необходимо воспользоваться ключом <b>&laquo;-newtable&raquo;</b>. Для создания цепочки воспользуйтесь ключом <b>&laquo;-newchain&raquo;</b>. В конце завершите создание указанных таблиц и цепочек с помощью ключа <b>&laquo;-e&raquo;</b>.</p>
			<p>Или же вы можете воспользоваться одним единственным ключом <b>&laquo;-run&raquo;</b> в сочетании с завершением команды <b>&laquo;-e&raquo;</b>.</p>
			<p>Например.</p>
			<p class="codes">
				<b>$</b> sudo ./py-blacklist.py -nft -newtable -newchain -e</br>
				<span style="color:blue;"># или</span></br>
				<b>$</b> sudo ./py-blacklist.py -nft -run -e
			</p>
			<p>Самое приятное в этом скрипте то, что когда мы не указываем протокол, мы используем протокол по умолчанию - <b>IPV4</b>. В этом случае вторая таблица и цепочка для протокола <b>IPV6</b> будет создана автоматически без нашего участия как необходимость.</p>
			<p>Для очистки таблиц и/или цепочек воспользуйтесь следующими ключами:</p>
			<ul>
				<li><b>-cleartable</b></li>
				<li><b>-clearchain</b></li>
			</ul>
			<p>Для удаления таблиц и/или цепочек воспользуйтесь другими ключами:</p>
			<ul>
				<li><b>-Deltable</b></li>
				<li><b>-Delchain</b></li>
			</ul>
			<p><u><b>Вот здесь как раз и появляются защитные механизмы.</b></u></p>
			<p>Дело в том, что во всех дистрибутивах, не важно имеется ли в них слой совместимости <b>IPTABLES</b> с <b>NFTABLES</b> или нет, имеют на борту некоторые стандартные таблицы и цепочки. Большинство программ и утилит системы создают их автоматически без участия пользователя для своих нужд. И в них как раз и помещаются так называемся ссылки на собственные цепочки правил. И только после этого автоматически создаются эти самые отдельные цепочки правил.</p>
			<p>Таким образом основная таблица с различными цепочками не будет загромождена правилами.</p>
			<p>Однако, если работа осуществляется через <b>IP(6)TABLES</b> такой способ необходимо тщательно контролировать, иначе такая отдельная цепочка правил, рано или поздно, может перестать фильтровать все пакеты, согласно внесённым в неё правилам.</p>
			<p>Именно по этой причине в скрипте <b>&laquo;py-blacklist.py&raquo;</b> при работе с <b>IP(6)TABLES</b> используется строго прямой подход.</p>
			<p>Посмотрим на простой пример с дистрибутивом <b>&laquo;Debian 11&raquo;</b> и фаерволом <b>&laquo;UFW&raquo;</b>, что находится в стандартной таблице <b>&laquo;filter&raquo;</b> и цепочке правил <b>&laquo;INPUT&raquo;</b> для протокола <b>&laquo;IPV4&raquo;</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-33.png" width="800px"/>
			</div>
			<p>Как видите - фаервол напихал туда ссылки на собственные цепочки правил.</p>
			<p><span style="color:blue;"><u><b>А ведь так делают большинство программ и утилит любых дистрибутивов Linux.</b></u></span></p>
			<p>Чтобы сохранить такие правила в неприкосновенности в скрипт встроена система безопасности запрещающая очищать и удалять стандартные таблицы и цепочки <b>NFTABLES</b>. Т.е. конкретно таблицу <b>&laquo;filter&raquo;</b> и цепочку <b>&laquo;INPUT&raquo;</b> не зависимо от протокола - <b>&laquo;IPV4&raquo;</b> или <b>&laquo;IPV6&raquo;</b>.</p>
			<p>Ну а чтобы не приходилось принудительно очищать нужные вам таблицы и цепочки в скрипт встроен список безопасности. В него попадает всё что отправляется хоть в <b>IP(6)TABLES</b>, хоть в <b>NFTABLES</b>. Скрипт автоматически сравнит все имеющиеся в нём ip-адреса не зависимо от протокола с теми, которые имеются в обоих <b>JSON</b>-списках - и с белым и с черным. И всё что не совпадает с этими списками, но имеется в списке безопасности - он автоматически разблокирует при следующем запуске любой сервисной команды скрипта.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.9"></a></p>
			<h3>7.9. Сервисные команды скрипта.</h3>
			<p>В любом скрипте должны быть отдельные методы запуска, остановки и перезапуска скрипта, в которых будут обрабатываться оба списка ip-адресов - и черный и белый.</p>
			<p>Без таких методов скрипт добавит полученные ip-адреса в <b>Netfilter</b>, но никогда не удалит их по окончании работы.</p>
			<p>Что это значит?</p>
			<p>Вы прекрасно знаете, что после перезагрузки ОС все правила <b>Netfilter</b>-а должны сбрасываться, если не задана их пред-загрузка. Допустим, вы внесли несколько адресов в правила для блокировки доступа, но не добавляли их в настройки при перезагрузке ОС. Через некоторое время вы, скорее всего, забываете о том, что вносили эти ip-адреса в правила брендмауэра.</p>
			<p>Один из этих адресов оказался статическим адресом сети организации конкурента. У них имеется свой собственный сервер, на котором установлен некий сканер веб-сайтов, который просто собирает информацию о конкурентах. Ничего особенного - такое часто можно встретить.</p>
			<p>Если в вашем сервере используются фильтры подобные примерам в скрипте <b>&laquo;py-blacklist.py&raquo;</b>, то они жесткие и скорее всего уже отфильтровали поведение таких сканеров и занесли их ip-адреса в черный список. Или же вы сами внесли эти адреса как подозрительные и забыли об этом.</p>
			<p>Через некоторое время вам вдруг понадобилось сотрудничать с этими конкурентами, только для того чтобы Тендер на какой-нибудь проект в итоге достался только вашей фирме. Или некая выгодная сделка в итоге была заключена только с вами, т.е. вашей организацией.</p>
			<p>В любом случае вам будет необходимо предоставить некоторый доступ конкурентам к вашему серверу. И тут возникают проблемы. Да, вы можете перезапустить сервер и все правила будут сброшены. Но а если перезапускать сервер недопустимо? Ну т.е. от его работы зависит не просто доступ в интернет всей вашей фирмы, а доступ к определённым ресурсам вышестощей организации. Например, именно через этот сервер осуществляется подключение ко всем сетям какого-нибудь министерства. И при перезапуске уже и вам и всей организации очень долго пришлось бы ждать пока сервер не просто запуститься, а синхронизирует свою работу с остальными сервисами этого самого министерства.</p>
			<p>Естественно вы будете искать причину в ПО и в различных логах, только для того чтобы не перезапускать сервер. А проблема кроется в том, что вы забыли разблокировать один единственный ip-адрес.</p>
			<p>Поэтому важно обрабатывать оба списка адресов - и белых и черных. По отдельному аргументу командной строки добавлять все ip-дреса с разными правилами в <b>Netfilter</b>, а по команде остановки удалять их все оттуда. Ну и естественно, также, аргументами командной строки просматривать оба списка.</p>
			<p>Если бы в вашем скрипте такие команды имелись вам бы не пришлось долго искать проблему - всё что вам нужно было бы сделать - это найти ip-адрес конкурентной организации, просмотреть черный список вашего скрипта и удалить этот адрес и из списка и из таблиц <b>Netfilter</b>-а.</p>
			<p>В скрипте <b>&laquo;py-blacklist.py&raquo;</b> такие команды имеются - и запуска, и остановки и перезапуска, и другие.</p>
			<p>Рассмотрим их более подробно.</p>
			<ol>
				<li><b>&laquo;-start&raquo;</b> - Запустить черный список.</li>
				<li><b>&laquo;-stop&raquo;</b> - Остановить черный список.</li>
				<li><b>&laquo;-nostop&raquo;</b> - Не делает ровным счетом ничего. Нужна для замены предыдущей команды в <b>Systemd</b>, если вдруг потребуется не очищать таблицы <b>Netfilter</b>-а, при остановке работы черного списка. Просто чтобы строку остановки не оставлять пустой.</li>
				<li><b>&laquo;-reload&raquo;</b> - Перезапустить черный список.</li>
				<li><b>&laquo;-grep&raquo;</b> - Фильтрация просмотра правил <b>Netfilter</b>-а в соответствии с указанным регулярным выражением. Некий аналог утилиты <b>Grep</b> без её дополнительных преимуществ, только для уменьшения результата просмотра или поиска в последнем определённой информации. Регулярные выражения абсолютно такие же.</li>
			</ol>
			<p>Итак, 1. <b>&laquo;-start&raquo;</b> - запускает черный список. Это значит, что скрипт не просто запускает только один черный список, а обрабатывает оба списка - и черный и белый, т.е. оба списка в соответствии с заданным количеством блокировок заносятся в таблицы межсетевого экрана. Имеется введу, что запускается сервис скрипта с одноимённым наименованием.</p>
			<p>Соответственно 2. <b>&laquo;-stop&raquo;</b> останавливает работу скрипта и также обрабатывает оба списка, удаляя все внесённые адреса из межсетевого экрана.</p>
			<p>4. <b>&laquo;-reload&raquo;</b> - перезапускает работу скрипта. Т.е. сначала оба списка полностью удаляются из брендмауэра, в соответствии с заданным количеством блокировок и заносятся заново.</p>
			<p class="codes">
				<span style="color:blue;"># Для IP(6)TABLES</span></br>
				<b>$</b> sudo ./py-blacklist.py -c 3 service -start</br>
				<b>$</b> sudo ./py-blacklist.py -c 3 service -stop</br>
				<b>$</b> sudo ./py-blacklist.py -c 3 service -reload</br></br>
				<span style="color:blue;"># или для NFTABLES</span></br>
				<b>$</b> sudo ./py-blacklist.py -nft -c 3 service -start</br>
				<b>$</b> sudo ./py-blacklist.py -nft -c 3 service -stop</br>
				<b>$</b> sudo ./py-blacklist.py -nft -c 3 service -reload
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.10"></a></p>
			<h3>7.10. Systemd.</h3>
			<p><b>Systemd</b> — это менеджер управления службами и демонами по запросам, сокетами и параллелизацией, <b>D-BUS</b> активацией и отслеживанием процессов с помощью контрольных групп в <b>Linux</b>.</p>
			<p>Загрузка Linux – сложный и многоэтапный процесс, здесь нет никакой &laquo;магии&raquo;.</p>
			<p>Как правило, процесс загрузки воспринимают как нечто цельное, но это неправильно.</p>
			<p>Загрузка состоит из, как минимум, трех разных этапов:</p>
			<ul>
				<li><b>Загрузка аппаратной части</b> - т.е. запуск &laquo;железа&raquo;.</li>
				<li><b>Загрузка Linux</b> - загрузка ядра, а затем, <b>systemd</b>.</li>
				<li><b>Запуск рабочей среды</b> - т.е. <b>systemd</b> подготавливает систему к работе.</li>
			</ul>
			<p>Запуск Линукса начинается после того, как ядро запустило либо init, либо systemd — в зависимости от того, что используется в дистрибутиве. Демоны init и systemd запускают и управляют всеми другими процессами, поэтому их часто называют прародителем всех процессов.</p>
			<p>Важно четко понимать различия между аппаратной загрузкой, загрузкой Linux и запуском рабочей среды. Если вы понимаете, где заканчивается один процесс и начинается другой, а также какую роль играет каждый из них в запуске системы до рабочего состояния, вы с легкостью найдете, в каком конкретно месте «загрузки» возникает проблема.</p>
			<p>Запуск Linux — последний этап процесса загрузки. Именно он позволяет вывести систему в рабочее состояние, когда вы можете работать с ней. Запуск начинается тогда, когда ядро передает управление systemd.</p>
			<hr style="border: none; border-top: 2px dashed #808080;">
			<p><span style="color:blue;">По сути <b>Systemd</b> можно представить себе как службы <b>Windows</b>. Проведём небольшую аналогию, но упростим её до 3 пунктов как для <b>Linux</b> дистрибутивов выше.</span></p>
			<p>При запуске любого <b>Windows</b> по клавише <b>&laquo;F8&raquo;</b> мы абсолютно также можем увидеть меню загрузки. После чего появляется логотип и анимация запуска системы.</p>
			<p><b>&laquo;1.&raquo;</b> В этот момент происходит запуск апаратной части и практически сразу без дополнительной визуализации происходит <b>&laquo;2.&raquo;</b> запуск ядра и передача управления службам системы.</p>
			<p><b>&laquo;3.&raquo;</b> Далее службы <b>Windows</b> уже запускают все остальные необходимые для работы процессы. Таким образом управление уже передано службам.</p>
			<p>Далее мы видим либо вход в систему, либо сразу загрузку рабочего стола.</p>
			<p>Аналогично запуску <b>Linux</b> дистрибутивов службы <b>Windows</b> подготавливают рабочее место пользователя к запуску и сразу отображают результат своей работы, передавая управление уже самому пользователю.</p>
			<p>В отличии от служб <b>Windows</b> - <b>Systemd</b> управляет практически каждым аспектом работающей системы <b>Linux</b>. Он также управляет аппаратной частью, процессами и группами процессов, монтированием файловых систем и многим другим. Т.е. по сути это более низкоуровневый и простой доступ к службам и процессам системы, по сравнению с <b>Windows</b>.</p>
			<p>В <b>Windows</b> же на самом деле, автозагрузка ложится на плечи служб. Вот только управление автозагрузкой в разы легче. Например, чтобы добавить какую-либо программу в автозапуск необходимо всего лишь сделать на неё ярлык и скопировать его в определённую папку. Или можно тоже самое сделать, если прописать определенную строку в редакторе реестре по определенным путям для пользователя, всех пользователей или всей системы.</p>
			<p>В <b>Linux</b> же с этим немного сложнее. Чтобы добавить какую-либо программу в автозапуск необходимо создать файл сервиса по определённым правилам, расположить его в определённом каталоге и дать команду на активацию.</p>
			<p>В теории в <b>Windows</b> мы конечно можем поступить 2 способами:</p>
			<ul>
				<li>Создать bat(cmd, vbs) скрипт запуска той или иной программы и добавить службу, которая напрямую будет запускать этот скрипт. Либо же просто сразу создать необходимую службу, которая будет напрямую запускать то или иное приложение.</li>
				<li>Аналогично предыдущему пункту, но создавать не службу, а задачу в планировщике задач. В <b>Linux</b> тоже так можно.</li>
			</ul>
			<p>На практике так никто никогда не делает. Дело в том, что в <b>Windows</b> службы нужны для запуска определённых фоновых процессов, которые всегда скрыты от глаз пользователя. Они выполняют свои функции в системе и при необходимости, т.е. обращении к строго определённым ресурсам, сообщают (выдают) пользователям определённую информацию на более высоком уровне. Т.е. чтобы не навредить системе и системным файлам и ресурсам они работают на низкоуровневом доступе. В это время все наши программы с графическим интерфейсом будут обращаться именно к этим утилитам низкоуровневого доступа.</p>
			<p>Иначе нам бы всякий раз пришлось бы запускать то или иное приложение в режиме от имени администратора. Более того, такой способ доступа к аппаратной части через операционной систему в принципе может навредить. Поэтому, чаще всего, и создают отдельные фоновые службы безопасного управления, а доступ осуществляется через любую внешнюю программу, даже вашу, но обращение всё равно будет через такую вот фоновую службу доступа.</p>
			<p>В <b>Linux</b> в качестве примера таких служб можно привести 2 известных фреймворка: <b>&laquo;XTables&raquo;</b> и <b>&laquo;nf_tables&raquo;</b>.</p>
			<p><u>В теории мы вполне могли бы напрямую взаимодействовать с ядром дистрибутива и самой системой. В таком случае управление будет идти напрямую в аппаратную часть ПК в обход всех драйверов и утилит ОС. Однако, такое взаимодействие, скорее всего только навредит. И при этом не важно работаете вы в <b>Windows</b> или <b>Linux</b>.</u></p>
			<p>Именно поэтому и создали некую прослойку - системные службы, драйвера и фоновые утилиты. Чтобы безопасно взаимодействовать с аппаратной частью ПК и его ядром. Ведь по сути драйвера и фоновые утилиты - это тоже службы, но работают они всегда в фоновом режиме, т.е. не зримо для пользователя.</p>
			<p>Зачем, как говорится, мучаться, если всё уже продуманно за нас. Бери, да пользуйся.</p>
			<hr style="border: none; border-top: 2px dashed #808080;">
			<p>Инструментарий <b>systemd</b> — компилированные бинарные файлы, но набор инструментов открыт, потому что все конфигурационные файлы — это <b>ASCII-текст</b>. Конфигурацию запуска можно менять через различные инструменты командной строки или GUI. Также можно менять или добавлять различные конфигурационные файлы, при необходимости.</p>
			<p>Systemd запускает сервисы описанные в его конфигурации. Конфигурация состоит из множества файлов, которые по-модному называют юнитами.</p>
			<p>Все эти юниты разложены в трех каталогах:</p>
			<ul>
				<li><b>&laquo;/usr/lib/systemd/system/&raquo;</b> - юниты из установленных пакетов — всякие nginx, apache, mysql и прочее.</li>
				<li><b>&laquo;/run/systemd/system/&raquo;</b> - юниты, созданные в рантайме.</li>
				<li><b>&laquo;/etc/systemd/system/&raquo;</b> - юниты, созданные системным администратором.</li>
			</ul>
			<p>В первом каталоге очень много различных юнитов и все они расположены в одной куче. Обычно здесь и располагают большинство различных сервисов или таймеров. Если не знать наименование сервиса, таймера или сокета найти нужный будет сложно. Другое дело последняя папка.</p>
			<p>Вот в неё и нужно сохранять собственные юниты.</p>
			<p>Вообще, ещё существует каталог юнитов пользователя - у каждого свой и при этом необходимо указывать <b>Systemd</b> что запуск или активация происходит только для заданного пользователя. Однако, такой способ запуска крайне специфичный и подходит только тем программам и утилитам, которым не нужны <b>ROOT</b>-права. Т.е. такие приложения не работают с системными файлами и журналами, на которые установлены конкретно <b>root</b>-ограничения.</p>
			<p>Нас же интересуют только юниты, расположенные в каталоге <b>&laquo;/etc/systemd/system/&raquo;</b>.</p>
			<p><b>Разберём основные параметры юнитов сервисов и таймеров в теории и перейдём к практике.</b></p>
			<h3>Юнит сервиса.</h3>
			<p><u>Секция <b>&laquo;[Unit]&raquo;</b> - описание и порядок запуска.</u></p>
			<p>Описание юнита:</p>
			<p class="selections">Description=MyUnit</p>
			<p>Далее следует блок переменных, которые влияют на порядок загрузки сервисов. Запускать юнит после какого-либо сервиса или группы сервисов (например network.target):</p>
			<p class="selections">
				After=syslog.target<br>
				After=network.target<br>
				After=nginx.service<br>
				After=mysql.service
			</p>
			<p>Для запуска сервиса необходим запущенный сервис mysql:</p>
			<p class="selections">
				Requires=mysql.service
			</p>
			<p>Для запуска сервиса желателен запущенный сервис:</p>
			<p class="selections">
				Wants=nginx.service
			</p>
			<p>Если сервис есть в <b>Requires</b>, но нет в <b>After</b>, то наш сервис будет запущен параллельно с требуемым сервисом, а не после успешной загрузки требуемого сервиса. Зависимости обычно указываются для служб, но не для целей. Так, цель <b>etwork.target</b> будет "подтянута" ещё на этапе настройки сетевых интерфейсов одной из соответствующих служб, и можно спокойно указывать эту цель как зависимость в пользовательской службе, поскольку <b>network.target</b> будет запущена в любом случае.</p>
			<p>Учтите, что если вы указываете <b>Requires</b>, и такого сервиса не существует ваша служба не просто не запуститься, а ещё и выдаст системную ошибку и может даже застопить весь запуск системы. Лучше указывать одновременно и <b>After</b> и <b>Wants</b>.</p>
			<p class="selections">
				Wants=nginx.service<br>
				After=nginx.service
			</p>
			<p>Так хотя бы не будет ошибок, если указанный сервис не будет найден.</p>
			<p><u>Секция <b>&laquo;[Service]&raquo;</b> - команды управления, включая пользователей и группы.</u></p>
			<p>Тип сервиса:</p>
			<p class="selections">
				Type=simple
			</p>
			<ul>
				<li><i>Type=simple</i> - systemd запустит эту службу незамедлительно. Процесс при этом не должен разветвляться (fork). Если после данной службы должны запускаться другие, то этот тип использовать не стоит (исключение — служба использует сокетную активацию).</li>
				<li><i>Type=forking</i> - systemd считает службу запущенной после того, как процесс разветвляется с завершением родительского процесса. Используется для запуска классических демонов за исключением тех случаев, когда в таком поведении процесса нет необходимости. Укажите параметр PIDFile=, чтобы systemd мог отслеживать основной процесс.</li>
				<li><i>Type=oneshot</i> - удобен для сценариев, которые выполняют одно задание и завершаются. Если задать параметр RemainAfterExit=yes, то systemd будет считать процесс активным даже после его завершения.</li>
				<li><i>Type=notify</i> - идентичен параметру Type=simple, но с уточнением, что демон пошлет systemd сигнал готовности.</li>
				<li><i>Type=dbus</i> - служба считается находящейся в состоянии готовности после появления указанного BusName в системной шине DBus.</li>
				<li><i>Type=idle</i> - systemd отложит выполнение двоичного файла службы до окончания запуска остальных ("более срочных") задач. В остальном поведение аналогично Type=simple.</li>
			</ul>
			<p>Также следует определить <b>PIDFile=</b>, чтобы systemd могла отслеживать основной процесс:</p>
			<p class="selections">
				PIDFile=/opt/www/myunit/pids/service.pid
			</p>
			<p>Рабочий каталог, он делается текущим перед запуском команд:</p>
			<p class="selections">
				WorkingDirectory=/opt/www/myunit/
			</p>
			<p>Пользователь и группа, под которым надо запускать сервис:</p>
			<p class="selections">
				User=user<br>
				Group=users
			</p>
			<p>Переменные окружения:</p>
			<p class="selections">
				Environment=MYENV_ENV=production
			</p>
			<p>Запрет на убийство сервиса вследствие нехватки памяти и срабатывания механизма OOM: -1000 полный запрет (такой у sshd стоит), -100 понизим вероятность.</p>
			<p class="selections">
				OOMScoreAdjust=-100
			</p>
			<p>Команды запуска, остановки и перезапуска сервиса.</p>
			<p class="selections">
				ExecStart= <br>
				ExecStop= <br>
				ExecReload=
			</p>
			<p>Тут есть тонкость — в <b>systemd</b> необходимо указывать полный путь к исполняемому файлу. Но можно и немного обыграть этот момент, если сделать символическую ссылку на ваш исполняемый файл в <b>&laquo;/usr/bin/&raquo;</b>. Тогда в этих строках можно будет указать только наименование символической ссылки.</p>
			<p>Таймер обработки команд запуска и остановки.</p>
			<p class="selections">
				TimeoutSec=300
			</p>
			<p>Попросим systemd автоматически перезапускать наш сервис, если он вдруг перестанет работать. Контроль ведется по наличию процесса из PID файла.</p>
			<p class="selections">
				Restart=always
			</p>
			<p>Считать сервис запущеным, даже если он не активен. Чаще всего используется в сочетании с <b>&laquo;Type=oneshot&raquo;</b> - типом сервиса одноразового запуска при запуске ОС.</p>
			<p class="selections">
				RemainAfterExit=yes
			</p>
			<p><u>Секция <b>&laquo;[Install]&raquo;</b> - уровень запуска сервиса.</u></p>
			<p>Уровень запуска:</p>
			<p class="selections">
				WantedBy=multi-user.target
			</p>
			<p><b>multi-user.target</b> или <b>runlevel3.target</b> соответствует многопользовательскому режиму без графики. Пользователи, как правило, входят в систему при помощи множества консолей или через сеть.</p>
			<p>Более подробно смотрите в статье: <a target="_blank" href="https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: systemd (Русский)&raquo;</b></a>.</p>
			<h3>Юнит таймера.</h3>
			<p>Таймер не обязательно должен называться точно также как и сервис, но расширение должно быть именно <b>&laquo;.timer&raquo;</b>.</p>
			<p>Параметры таймера:</p>
			<ul>
				<li><b>Unit</b> - какой сервис необходимо запускать по таймеру.</li>
				<li><b>AccuracySec</b> - точность таймера равна 1 секунде. По умолчанию точность таймера равно 1 минуте. Поэтому для заданий, которые выполняются чаще 1 минуты, нужно использовать этот параметр.</li>
				<li><b>OnUnitActiveSec</b> - определяет отсчёт времени от момента запуска юнита, который был активирован таймером. Другими словами отсчет ведётся с момента запуска test-timer.service, и когда он доходит до нуля, таймер срабатывает вновь. Вместо этого параметра можно использовать следующие:</li>
				<ul>
					<li><b>OnActiveSec</b> - отсчёт относительно момента активации самого таймера.</li>
					<li><b>OnBootSec</b> - отсчёт ведётся с момента запуска компьютера, например через 30 секунд, после запуска компьютера.</li>
					<li><b>OnUnitInactiveSec</b> - отсчёт начинается с момента деактивации юнита, который запускается таймером. Этот параметр противоположен <b>OnUnitActiveSec</b>.</li>
					<li><b>OnCalendar</b> - определяет таймер реального времени. Этот параметр может быть указан несколько раз, если нужно.</li>
				</ul>
			</ul>
			<p>Например, таймер, который будет запускаться один раз в неделю (в 12:00 в понедельник).</p>
			<div class="codeses">
				<pre><p style="text-indent: 0px; margin: 0px; padding: 0px 0px 10px 0px; font-weight:bold; border: none; border-bottom: 1px dashed #808080;">/etc/systemd/system/foo.timer</p>
[Unit]
Description=Run foo weekly

[Timer]
OnCalendar=weekly
Persistent=true

[Install]
WantedBy=timers.target</pre>
			</div>
			<p>Если требуется указать более точную дату и время, используйте следующий формат:</p>
			<p>ДеньНедели Год-Месяц-День Часы:Минуты:Секунды</p>
			<p>Звездочка может быть использована, чтобы указать все значения, а запятые, в свою очередь, для перечисления возможных значений. Используйте <b>&laquo;..&raquo;</b>, чтобы выделить какой-то конкретный промежуток.</p>
			<p>В следующем примере служба запускается в первые четыре дня каждого месяца в полдень, но только если день является понедельником или вторником.</p>
			<p class="codes">
				OnCalendar=Mon,Tue *-*-01..04 12:00:00
			</p>
			<p>Запуск службы в первую субботу каждого месяца:</p>
			<p class="codes">
				OnCalendar=Sat *-*-1..7 18:00:00
			</p>
			<p>По крайней мере один день должен быть указан при использовании <b>&laquo;ДеньНедели&raquo;</b>.</p>
			<p>Таймер, который будет запускаться каждый день в 4 утра:</p>
			<p class="codes">
				OnCalendar=*-*-* 4:00:00
			</p>
			<p>Если необходимо запускать службу в разное время, то можно указать параметр OnCalendar несколько раз.</p>
			<p>В этом примере служба запускается в 22:30 по рабочим дням и в 20:00 по выходным:</p>
			<p class="codes">
				OnCalendar=Mon..Fri 22:30<br>
				OnCalendar=Sat,Sun 20:00
			</p>
			<p>Указатели времени OnCalendar могут быть протестированы для того, чтобы проверить их правильность и вычислить следующее время срабатывания условия. Например, <b>&laquo;systemd-analyze calendar weekly&raquo;</b> или <b>&laquo;systemd-analyze calendar "Mon,Tue *-*-01..04 12:00:00"&raquo;</b>.</p>
			<p>Специальные выражения событий, такие как <i>daily</i> и <i>weekly</i>, относятся к конкретному времени начала и, таким образом, все таймеры, использующие эти выражения, запустятся одновременно. Таймеры, использующие специальные выражения, могут негативно сказаться на производительности системы, если сервисы, запускаемые таймерами, являются ресурсозатратными. Опция <i>RandomizedDelaySec</i> в разделе <b>[Timer]</b> помогает избежать подобных проблем посредством случайного выбора времени запуска каждого из таймеров.</p>
			<p>Добавьте опцию <i>AccuracySec=1us</i> в раздел <b>[Timer]</b>, чтобы не использовать значение погрешности <i>1m</i>, установленное по умолчанию.</p>
			<p>Можно использовать <b>&laquo;systemd-run&raquo;</b> для создания временных юнитов <b>&laquo;.timer&raquo;</b>. То есть можно назначить запуск определённой команды в нужное время, не имея соответствующего файла службы.</p>
			<p>Например, следующая команда создаст файл через 30 секунд:</p>
			<p class="codes">
				<b>$</b> systemd-run --on-active=30 /bin/touch /tmp/foo
			</p>
			<p>Кроме того, можно указать предварительно существующий файл сервиса, при этом не имея файла таймера.</p>
			<p>Например, запустим юнит, который называется <b>&laquo;некоторыйюнит.service&raquo;</b>, через 12.5 часов:</p>
			<p class="codes">
				<b>$</b> systemd-run --on-active="12h 30m" --unit некоторыйюнит.service
			</p>
			<p>Чтобы иметь возможность передавать параметры, т.е. аргументы командной строки, в сервис или таймер, необходимо в наименование сервиса перед расширением добавить собаку. Например, <b>&laquo;status_email_user@.service&raquo;</b>.</p>
			<p>Параметры(аргументы командной строки) передаются с помощью указания в строке запуска дополнительного ключа вместе с процентом: <b>&laquo;%i&raquo;</b>.</p>
			<p>Например, файл юнита для получения статуса.</p>
			<div class="codeses">
				<pre><p style="text-indent: 0px; margin: 0px; padding: 0px 0px 10px 0px; font-weight:bold; border: none; border-bottom: 1px dashed #808080;">/etc/systemd/system/status_email_user@.service</p>
[Unit]
Description=status email for %i to user

[Service]
Type=oneshot
ExecStart=/usr/local/bin/systemd-email address %i
User=nobody
Group=systemd-journal</pre>
			</div>
			<p>Более подробно смотрите в статье: <a target="_blank" href="https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)/Timers_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: systemd (Русский)/Timers (Русский)&raquo;</b></a>.</p>
			<h3>Перейдём к практике.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part8"></a></p>
			<h2>8. Использование скриптов в Fail2ban.</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
