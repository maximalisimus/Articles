<html>
<head>
	<meta charset="utf-8">
	<title>Чёрный список ip адресов.</title>
	<link rel="icon" href="../image/Blacklists-image/blacklists-logo.ico">
	<!--
		<link rel="icon" href="image/favicon.png">
		<link rel="shortcut icon" href="js-css/404-2.ico" Type="image/x-icon">
		type="image/png"
		<link rel="shortcut icon" href="favicon.png" type="image/png">
		<link rel="icon" href="image/favicon.svg" type=" image/svg+xml">
	-->
	<link rel="stylesheet" href="../html/main.css" type="text/css">	
	<link rel="stylesheet" href="../html/zoom.css" type="text/css">
	<link rel="stylesheet" href="../html/table.css" type="text/css">
	<link rel="stylesheet" href="../html/frame.css">
	<link rel="stylesheet" href="../html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="../html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="../html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Blacklists.</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="../image/Blacklists-image/firewall-network-security-scaled.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<center>
				<h1>Большое руководство по чёрным спискам ip адресов.</h1>
			</center>
			<p>Для начала давайте с вами определимся с основными понятиями:</p>
			<ul>
				<li>Что такое угроза?</li>
				<li>Что такое признак атаки?</li>
				<li>Как узнать о том, что сервер находится в большой опасности?</li>
				<li>Что вообще такое фаервол, и какие они бывают в <b>Linux</b>-ах.</li>
				<li>И многое другое ...</li>
			</ul>
			<p>После чего посмотрим каким образом блокировать и разблокировать угрозы безопасности.</p>
			<p>Далее определимся с пониятием черных и белых списков и зачем они вообще нужны.</p>
			<p>Посмотрим с вами на реальные примеры и виртуального и реального (<b>VPS</b>) серверов.</p>
			<p>И наконец, на примере виртуального сервера в разы усилим его безопасность.</p>
			<p>Итак, приступим.</p>
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Что можно сделать с украденными личными данными?</a></li>
				<li><a href="#part2">Введение.</a></li>
				<li><a href="#part3">Одновременный доступ к файлам журналов.</a></li>
				<li><a href="#part4">Межсетевые экраны.</a></li>
				<ol>
					<li><a href="#part4.1">История, определения.</a></li>
					<li><a href="#part4.2">Netfilter.</a></li>
					<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
					<li><a href="#part4.4">NFTABLES.</a></li>
					<li><a href="#part4.5">UFW / Firewalld.</a></li>
					<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
				</ol>
				<li><a href="#part5">Fail2ban.</a></li>
				<ol>
					<li><a href="#part5.1">Оперативная память.</a></li>
				</ol>
				<li><a href="#part6">NGINX / Nginx Proxy Manager.</a></li>
				<li><a href="#part7">Черный и белый списки.</a></li>
				<ol>
					<li><a href="#part7.1">Черный и белый список. Введение.</a></li>
					<li><a href="#part7.2">Скрипты.</a></li>
					<li><a href="#part7.3">Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</a></li>
					<li><a href="#part7.4">Работа с логами, командами и выводом информации.</a></li>
					<li><a href="#part7.5">Работа с черным и белым списками.</a></li>
					<li><a href="#part7.6">IP(6)TABLES / NFTABLES.</a></li>
					<li><a href="#part7.7">Работа с таблицами и цепочками.</a></li>
					<li><a href="#part7.8">Запуск / остановка.</a></li>
					<li><a href="#part7.9">Systemd.</a></li>
				</ol>
				<li><a href="#part8">Использование скриптов в Fail2ban.</a></li>
				<ol>
					<li><a href="#part8.1">Фильтры.</a></li>
					<li><a href="#part8.2">Действия.</a></li>
					<li><a href="#part8.3">Правила.</a></li>
				</ol>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Что можно сделать с украденными личными данными?</h2>
			<p>Однажды человека может разбудить неожиданный звонок с требованием вернуть долг, а в почтовом ящике окажется повестка в суд. Но кредитов он не брал, закон не нарушал.</p>
			<p>Чтобы взять кредит в крупном банке, одних паспортных данных недостаточно: потребуется хотя бы копия документа. А вот оформить микрозаем в интернете можно с помощью сведений с первых страниц паспорта — номера, даты выдачи, кода подразделения и места рождения.</p>
			<p>Обратившись в несколько микрофинансовых организаций, мошенники получат существенную сумму на свои карты — а затем исчезнут, оставив жертву с долгами.</p>
			<p>Пользуясь данными чужого паспорта, мошенники регистрируют фирму-однодневку. Так они безнаказанно творят темные дела: уклоняются от налогов или собирают с обычных людей деньги за предзаказ дорогих товаров.</p>
			<p>Когда обман вскроется, мошенники заберут деньги и останутся вне подозрений — а вот владельцу паспорта придется объясняться с полицией.</p>
			<p>Некоторые интернет-магазины предлагают клиентам покупать товары в рассрочку: чтобы забрать вещь, нужно указать паспортные данные, а оплатить покупку можно позже.</p>
			<p>Это на руку мошенникам: они заказывают товар по чужому документу, а курьеру говорят, что покупку получит другой человек — не владелец паспорта. Предупрежденный курьер спокойно отдает дорогую вещь аферисту, но расплачиваться за нее должен ничего не подозревающий владелец паспорта.</p>
			<p>Если у «заемщика» хорошая кредитная история, рассрочку, скорее всего, одобрят. Правда, техника попадет в руки мошенникам, а расплачиваться придется вам.</p>
			<p>Зная ФИО жертвы и адрес регистрации, мошенники подделывают квитанции на оплату штрафов от государственных органов.</p>
			<p>По номеру паспорта на сайте налоговой службы легко узнать ИНН: этот номер поможет придать письму из налоговой убедительности и сообщить жертве об огромной задолженности.</p>
			<p>Чтобы оплатить «штраф» и избежать суда, аферисты просят как можно скорее воспользоваться вложенной квитанцией.</p>
			<p>Мошенники, которые обманывают людей в интернете, часто просят жертв выслать им деньги на электронный кошелек — поэтому аферистам выгодно использовать чужие данные. Так вся ответственность за мошенничество ляжет на плечи подставного владельца кошелька, а настоящие преступники останутся незамеченными.</p>
			<p>Чтобы изготовить паспорт, которым преступник сможет полноценно пользоваться, недостаточно подделать водяные знаки — паспорт с фальшивыми данными не пройдет ни одну проверку в электронных базах.</p>
			<p>Поэтому мошенники используют информацию из настоящего документа, а фотографию в фальшивый паспорт вклеивают свою. По паспорту с реальными данными, но фотографией афериста можно брать кредиты в мелких организациях, не вызывая подозрений, — а отвечать по долгам придется владельцу настоящего паспорта.</p>
			<p>Выяснить номер телефона по паспортным данным несложно. Многие указывают его на страницах в соцсетях или на страницах-визитках, которые можно найти, просто набрав имя и фамилию жертвы в поисковике.</p>
			<p>Мошенник размещает объявление о продаже дорогой вещи по бросовой цене: утверждает, что надо продать срочно, поэтому и скидка большая. А так как цена привлекательная, то и желающих много, поэтому аферист настаивает на предоплате: чтобы не терять время, если покупатель вдруг передумает. В качестве гарантии липовый продавец высылает скан паспорта — разумеется, чужого, а после получения денег перестает отвечать на сообщения.</p>
			<hr>
			<p><b>Это только цветочки, а бывают и ягодки!</b></p>
			<p><u>Это только для того, чтобы вы относились к безопасности вашего сервера серьёзно! Даже если у вас простенький сайт без каких-либо конфидециальных данных.</u></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h2>2. Введение.</h2>
			<p>Немного напугал, перейдём к теме серверов и их безопасности.</p>
			<p>Защита информации становится необходимостью для предотвращения потенциальных угроз и минимизации рисков.</p>
			<p>Защита информации обеспечивает личную безопасность и приватность, предотвращает утечку личных данных и защищает от возможных мошеннических действий.</p>
			<p>Под термином «угроза» следует понимать любое программное средство, косвенно или напрямую способное нанести ущерб компьютеру, сети, информации или правам пользователя (то есть вредоносные и прочие нежелательные программы). В более широком смысле термин «угроза» может означать любую потенциальную опасность для компьютера или сети (то есть ее уязвимость, которая может быть использована для проведения хакерских атак).</p>
			<p>Сетевая атака – это вторжение в операционную систему удаленного компьютера. Злоумышленники предпринимают сетевые атаки, чтобы захватить управление над операционной системой, привести ее к отказу в обслуживании или получить доступ к защищенной информации.</p>
			<p>Следует понимать, что защита от взлома серверов — это комплекс мер, в том числе подразумевающий постоянный мониторинг работы сервера и работу по совершенствованию защиты. Невозможно защитить сервер от внешнего доступа раз и навсегда, ведь каждый день обнаруживаются новые уязвимости и появляются новые способы взлома сервера.</p>
			<p>Основной признак попыток — «подозрительная активность» в логах. Это могут быть регулярные попытки подключения с разных IP-адресов, запросы к различным портам сервера, запросы на те или иные ресурсы.</p>
			<p>Лог (log) — это текстовый файл, куда автоматически записывается важная информация о работе системы или программы. Чаще всего говорят о логах сервера. Их записывает программное обеспечение, которое управляет внутренней частью сайта или онлайн-системы. Лог-файл — своеобразный журнал событий.</p>
			<p>В логи записываются сведения об ошибках, действиях пользователей и других событиях, которые происходят на сервере или в системе.</p>
			<p>Чтобы обнаружить угрозу, необходимо регулярно анализировать все логи, начиная с системных, и заканчивая логами различных утилит, которые работают на вашем сервере.</p>
			<p>Однако, анализировать логи вручную - не самая лучшая затея, хотя и вполне возможная. Для анализа логов существуют специальнные утилиты автоматического анализа и блокирования несанкционированного доступа. В простейшем случае они анализируют логи на подозрительную активность и при необходимости блокируют все попытки несанкционированного получения доступа на те или иные ресурсы сервера.</p>
			<p><b>Что значит несанкционированного?</b></p>
			<p><b>Несанкционированно</b> - осуществляемый без санкции, официального разрешения. Т.е. в нашем случае при самом простом способе прямого входа на ваш веб-сайт через веб-браузер вы увидите в логах действительные статусы состояний сервера. При любой попытке обойти формы ввода логина и пароля, даже напрямую вручную через браузер, в логи будет выведен совершенно другой статус состояния вашего сайта или всего сервера. При этом там же будут отображены все попытки запросов и все адреса и порты, на которые происходили запросы. В случае же использования любых утилит - не браузеров - эта информация сразу же отобразится в логах.</p>
			<p>Обычно любая утилита или программа (не важно Windows или Linux) во время запроса обязательно вставляет в посылаемый на сервер запрос (пакет) минимальную информацию о себе. В случае же хакерских утилит такой информации не будет.</p>
			<p>Посмотрим на частичный лог одного веб-сайта. IP-ардеса и некоторые другие данные лога я закрасил в целях безопасности.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-1.png" width="800px"/>
			</div>
			<div style="clear:both"></div>
			<p>Мы здесь можем видеть - что некий IP-адрес (пользователь, закрашен в самой левой части перед датой и временем) делает <b>GET</b>-запрос. При этом у адреса есть операционная система, и делает он свой запрос через браузер <b>Google-chrome</b>. Ну и соответственно видим дату и время запроса, а также статус состояния сайта, т.е. ответ веб-сайта.</p>
			<p>Судя по этой скудной информации мы можем сделать вывод о том, что некий пользователь напрямую через веб-браузер, т.е. санкционированно, обращался к некому веб-сайту.</p>
			<p>В последних 2 строках <b>GET</b>-запросы происходили не через браузер и с помощью утилиты <b>Curl</b>. При этом видим также и версию этой утилиты.</p>
			<p>В этих последних строках из-за статуса состояния сайта мы можем сделать вывод о том, что запрос хоть и был санкционированный, но не прямой, т.е. не через веб-браузер, и к этому стоит присмотреться.</p>
			<p>Существуют утилиты не только для автоматического мониторинга работы сервера и его доступности в интернете, но и оповещения по электронной почте или СМС в случае обнаружения проблем.</p>
			<p>Причём располагать утилиты мониторинга доступности сервера в интернете и оповещений непосредственно на самом сервере - не самая лучшая затея, хотя и вполне реализуемая и частенько практикуемая. Практикуемая именно потому что денег на второй сервер только для мониторинга нет. Такие утилиты вполне можно установить на сервер в виртуальной машине, которая будет не доступна из интернета, тем самым защищена. Она же и будет производить мониторинг работы и оповещать в случае проблем. Однако, не все могут оставить работать свой ПК с работающей виртуальной машиной на круглосуточную работу ради одного сервера. Обычно так делают когда серверов много.</p>
			<p>Кстати говоря, любые подобные утилиты мониторинга и оповещений вполне можно создать самостоятельно.</p>
			<p><span style="color:blue;">Сегодня мы с вами рассмотрим одну из утилит для блокировки вторжений на сервер.</span> Рассматривать утилиты оповещений и мониторинга сегодня мы не будем.</p>
			<p>Однако, это не говорит о том, что при использовании утилит блокировок вам не нужно будет использовать утилиты мониторинга или антивирусные средства. Как раз наоборот.</p>
			<p><span style="color:blue;"><u>Просто базовое понимание утилит блокировки даст вам понимание того, как запускать все программы и под-программы мониторинга, блокировок и оповещений одновременно так, чтобы данные получаемые из логов были на тот момент актуальными и одинаковыми для всех утилит. Иначе вы можете столкнуться с тем, что для одной из программ в логах у вас будут одни данные, для другой уже другие. В результате одна из утилит просто не сработает во время. Или вообще пропустит важные данные для обработки результата.</u></span></p>
			<p><span style="color:red;"><b>Чем это чревато? Надеюсь, вы и сами понимаете!</b></span></p>
			<p>Также, этот же момент не говорит о том, что вам всё равно не придётся создавать регулярные резервные копии данных сайта или всего сервера. <u>Потому что взломать можно всё что угодно! Было бы желание.</u> Вот как раз на случай проникновения и/или захвата управления, чтобы иметь возможность быстро восстановить сервер после атаки, как раз и нужны резеревные копии данных.</p>
			<p>Помимо описанного, необходимо регулярно следить за обновлениями программного обеспечения и операционной системы сервера. Обновления обычно устраняют уязвимости, которые могут использоваться для проведения атак.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h2>3. Одновременный доступ к файлам журналов.</h2>
			<p>При чтении или записи любого файла создаётся так называемый файловый дескриптор.</p>
			<p>Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом.</p>
			<p>Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux.</p>
			<p>В Linux библиотека libc открывает для каждого запущенного приложения(процесса) 3 файл дескриптора, с номерами 0,1,2.</p>
			<ul>
				<li>Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения.</li>
				<li>Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print.</li>
				<li>Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке.</li>
			</ul>
			<p>Если в вашей программе вы откроете какой-либо файл на чтение или запись, то скорее всего вы получите первый свободный ID и это будет номер 3.</p>
			<p>Файл дескриптор с номером 255 можете смело игнорировать, он был открыт для своих нужд уже самим bash, а не прилинкованной библиотекой.</p>
			<p>Например, откроем консоль с bash и посмотрим PID нашего процесса.</p>
			<div class="codeses">
				<pre><b>[user@localhost Загрузки]$</b> echo $$
11644
<b>[user@localhost Загрузки]$</b> ls -lha /proc/11644/fd/
итого 0
dr-x------ 2 user users  0 июл 22 08:26 .
dr-xr-xr-x 9 user users  0 июл 22 08:26 ..
lrwx------ 1 user users 64 июл 22 08:26 0 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 1 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 2 -> /dev/pts/1
lrwx------ 1 user users 64 июл 22 08:26 255 -> /dev/pts/1
<b>[user@localhost Загрузки]$</b></pre>
			</div>
			<p>Сейчас все 3 файл дескриптора связаны с устройством псевдотерминала /dev/pts, но мы все равно можем ими манипулировать, например запустим во второй консоли.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> echo "hello world" > /proc/11644/fd/0
			</p>
			<p>И в первой консоли мы увидим.</p>
			<p class="codes">
				<b>[user@localhost ]$</b> hello world
			</p>
			<p>Вы можете легко переопределить эти 3 файл дескриптора в любом процессе, в том числе и в bash, например через трубу(pipe), соединяющую два процесса.</p>
			<p>Продолжение смотрите в статье: <a href="https://habr.com/ru/articles/471038/">&laquo;Файл дескриптор в Linux с примерами&raquo;</a>.</p>
			<p>Допустим нас есть некий лог-файл, в который постоянно ведётся запись разных данных. Например, в лог-файл <b>NGINX</b>-а запись будет производиться только при поступления запроса на сервер и только на тот веб-адрес, который имеется в настройках конфигурации.</p>
			<p>К примеру, у нас есть несколько программ в виде коротких скриптов, которые постоянно с разными временными задержками анализируют этот лог-файл.</p>
			<p>Возникает логичный вопрос: А одинаковые ли будут данные у каждого из этих скриптов для анализа?</p>
			<p>Проведём небольшой эксперимент. Для этого создадим 3 разных скрипта. Один будет записывать данные в некий предопределённый нами лог-файл, а 2 других читать этот лог и выводить результат чтения на экран.</p>
			<p>Файл <b>&laquo;./write.sh&raquo;</b>. Здесь мы будет 10 раз записывать время с секундами и наносекундами в лог-файл <b>&laquo;./text.log&raquo;</b>, но с задержкой между записями в 2 секунды. Т.е. итоговое время выполнения, по идее, должно быть 18 секунд, включая вывод на экран.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./write.sh
#!/bin/bash
echo &quot;&quot; &gt; text.log
for x in {1..10}; do
	_date=$(date '+%H:%M:%S:%N')
	_random=$(echo &quot;${_date}&quot; | rev | cut -d ':' -f1 | rev)
	echo "${_date} - ${_random}"
	echo "${_date} - ${_random}" &gt; text.log
	sleep 2
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read.sh&raquo;</b>. Здесь мы будет читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, но вместо простого вывода содержимого на экран будем подсчитать количество строк в этом файле, что будет несколько нагляднее. Читать будем 3 раза с задержкой открытого файла дескриптора на 1 секунду в каждый цикл чтения. Итоговое время выполнения, по идее, должно быть 3 секунды.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 1
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Файл <b>&laquo;./read2.sh&raquo;</b>. Ну а в этом скрипте мы также будем читать наш лог-файл <b>&laquo;./text.log&raquo;</b>, но с задержкой файла-дескриптора уже на 2 секунды при каждом цикле чтения. Итоговое время выполнения, по идее, должно быть 6 секунд.</p>
			<div class="codeses">
				<pre><b>$</b> nano ./read2.sh
#!/bin/bash
for x in {1..3}; do
	date '+%H:%M:%S:%N'
	count=0
	while read line; do
		let count+=1
		sleep 2
	done &lt;text.log
	echo &quot;${count}&quot;
	date '+%H:%M:%S:%N'
	echo &quot;&quot;
done
exit 0

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>Теперь, откроем 3 разных косноли и попытаемся быстро-быстро запустить эти скрипты одновременно. Разумеется они будут работать не одновременно. Однако, из-за временных <b>sleep</b> задержек это будет не важно.</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-2.png" width="1024px"/>
			</div>
			<p>Как видите, и в первой и во второй консоли, из-за того, что скрипты долго держат файловый дескриптор открытым, они продолжают читать старый файл. Таким образом скрипты продолжает использовать старые данные и не успевают получить новые для обработки, в то время как в лог-файл уже была произведена запись и он был обновлён.</p>
			<p>Более того, 2-й скрипт <b>&laquo;./read2.sh&raquo;</b> вообще потерял много данных, а задержка была неоправдано долго и в данном случае именно из-за того, что файловый дескриптор уже был открыт другим процессом, т.е. занятым в этот момент.</p>
			<p>В простонародье говорят, что файл-журнала успел отротироваться, в то время как один из скриптов продолжает читать старый файл, уже после его ротации. При этом, открытый файловый дескриптор на чтение не позволяет другому скрипту прочитать тот же самый файл, и второму скрипту приходится ждать закрытия файлового дескриптора.</p>
			<p>Под таким понятием как &laquo;ротация&raquo; подразумевается переодическая и в тоже время последовательная и целенаправленная смена чего-то или же кого-то.</p>
			<p>В итоге, из-за такой, казалось бы, простой операции как <b>&laquo;Чтение файла&raquo;</b> - образовалась маленькая локальная война за ресурсы, в результате которой было потеряно много данных.</p>
			<p>Проблема чтения данных ещё состоит и в том, что практически все утилиты или скрипты анализа лог-файлов могут быть очень разными и сложными, или наоборот простыми. <u>Какие-то из них потребляют мало оперативной памяти, а какие-то напротив - очень много.</u></p>
			<p><u>Уменьшать время работы одной из утилит ради ускорения обработки данных очень и очень плохая затея!</u> Ведь таким образом вы можете чрезмерно нагрузить и процессор и оперативную память. А если у вас VPS или VDS сервер с ограниченным количеством ресурсов - в результате вы можете просто напросто зависнуть. Да-да, в Linux-е и зависнуть. Это не шутка!</p>
			<p><span style="color:purple;"><b>Этот маленький эксперимент должен был сказать вам</span> <span style="color:blue;"><u><i>не о том</i></u></span></b>, что необходимо уменьшать время запуска тех или иных программ или скриптов анализа, <b><span style="color:blue;"><u><i>а о том</i></u></span></b>, <b><span style="color:red;">что анализировать данные лучше какой-то одной единственной утилитой, и уже в ней, внутри, запускать все остальные необходимые вам внешние скрипты и программы обработки результатов, при обнаружении проблем.</span> </span> <span style="color:green;">При условии, что такая функция запуска внешних скриптов или программ имеется внутри утилиты анализа.</b></span></p>
			<p>Обычно, у всех программ и утилит анализа имеются специальные макросы для запуска внешних программ или скриптов для обработки результатов или запуска какого-нибудь действия / противодействия в самой ОС.</p>
			<p>Если же возможности самого анализа как такового ограничены - тогда да, запуск отдельной программы или отдельного скрипта в системе по таймеру - будет хорошим выходом из ситуации.</p>
			<p>Но, тогда вы, скорее всего, будете вынуждены подбирать и калибровать время запуска по таймеру только ради 2 вышеуказанных условий - аткуальность данных и нагрузка на оперативную память.</p>
			<p>Актуальность данных подразумевает несколько важных пунктов.</p>
			<ul>
				<li>Как часто обновляется нужный вам лог-файл, т.е. как часто в него записываются новые данные?</li>
				<li>Как часто необходимо анализировать лог-файл?</li>
			</ul>
			<p>В зависимости от данных ответов настраивается время таймера.</p>
			<p>Нагрузка же на процессор имеет немного более высокий приоритет. Для корректной настройки вам также необходимо будет ответить на пару вопросов.</p>
			<ul>
				<li>Сколько максимально в пике оперативной памяти потребляет ваша утилита или скрипт?</li>
				<li>Как сильно ваша утилита или скрипт нагружают процессор?</li>
			</ul>
			<p>Последние 2 вопроса имеют место быть, в случае, когда утилита имеет внутри себя множество различных сложных вычислений. В таком случае стоит задуматься насчет частоты запуска и соответственно об увеличении времени таймера для её запуска.</p>
			<p>При этом как именно будет запускаться утилита или скрипт не особо играет роли - будь то системный <b>systemd-таймер</b> или процесс запущенный из под сервиса <b>cron</b>, т.е. <b>crontab</b>.</p>				
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>4. Межсетевые экраны.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava4 { 
					counter-reset: list1; /* Список первого уровня*/ 
				} 
				.glava4 li:before { /* Список первого уровня */ 
					counter-increment: list1; /* Увеличиваем значение счетчика */ 
					content: "4." counter(list1) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava4">
				<li><a href="#part4.1">История, определения.</a></li>
				<li><a href="#part4.2">Netfilter</a></li>
				<li><a href="#part4.3">Таблицы и цепочки IPTables.</a></li>
				<li><a href="#part4.4">NFTABLES.</a></li>
				<li><a href="#part4.5">UFW / Firewalld.</a></li>
				<li><a href="#part4.6">Примеры использования UFW / Firewalld.</a></li>
			</ol>
			<hr>
			<p><a name="part4.1"></a></p>
			<h3>4.1. История, определения.</h3>
			<p>Рассмотрим первую линию обороны - межсетевые экраны.</p>
			<p>Брандмауэр, фаервол или межсетевой экран – это система, которая выполняет роль защитной стены между глобальным интернетом и устройством пользователя.</p>
			<p>Брандмауэр фильтрует всю входящую информацию и не пропускает вредоносный контент и вирусы.</p>
			<p>Брандмауэры, как правило, контролируют двунаправленный поток трафика, поэтому представьте себе брандмауэр перед организацией, отделяющий ее от общедоступного Интернета. Он должен иметь возможность блокировать входящий трафик, чтобы попытаться удержать злоумышленников, но он также должен иметь возможность разрешать исходящий трафик, потому что людям нужно просматривать веб-страницы, отправлять электронные письма и иметь связь, которая выходит за пределы сети.</p>
			<p>Наиболее распространённое место для установки межсетевых экранов — граница периметра локальной сети для защиты внутренних хостов от атак извне. Однако атаки могут начинаться и с внутренних узлов — в этом случае, если атакуемый хост расположен в той же сети, трафик не пересечёт границу сетевого периметра, и межсетевой экран не будет задействован. Поэтому в настоящее время межсетевые экраны размещают не только на границе, но и между различными сегментами сети, что обеспечивает дополнительный уровень безопасности.</p>
			<p>Программные межсетевые экраны появились существенно позже и были гораздо моложе, чем антивирусные программы. Например, проект <b>&laquo;Netfilter/iptables&raquo;</b> (один из первых программных межсетевых экранов, встраиваемых в ядро <b>Linux</b> с версии <b>2.4</b>) был основан <b>в 1998 году</b>.</p>
			<p>Фильтрация трафика осуществляется на основе набора предварительно сконфигурированных правил, которые называются ruleset. Удобно представлять межсетевой экран как последовательность фильтров, обрабатывающих информационный поток. Каждый из фильтров предназначен для интерпретации отдельного правила. Последовательность правил в наборе существенно влияет на производительность межсетевого экрана. Например, многие межсетевые экраны последовательно сравнивают трафик с правилами до тех пор, пока не будет найдено соответствие.</p>
			<p>Существует два принципа обработки поступающего трафика. Первый принцип гласит: «Что явно не запрещено, то разрешено». В данном случае, если межсетевой экран получил пакет, не попадающий ни под одно правило, то он передаётся далее. Противоположный принцип — «Что явно не разрешено, то запрещено» — гарантирует гораздо большую защищённость, так как он запрещает весь трафик, который явно не разрешён правилами. Однако этот принцип оборачивается дополнительной нагрузкой на администратора.</p>
			<p>В конечном счёте межсетевые экраны выполняют над поступающим трафиком одну из двух операций: пропустить пакет далее (allow) или отбросить пакет (deny). Некоторые межсетевые экраны имеют ещё одну операцию — reject, при которой пакет отбрасывается, но отправителю сообщается о недоступности сервиса, доступ к которому он пытался получить. В противовес этому, при операции deny отправитель не информируется о недоступности сервиса, что является более безопасным.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.2"></a></p>
			<h3>4.2. Netfilter.</h3>
			<p>Посмотрим на компаненты, которые входят в состав <b>Netfilter</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/Netfilter-components.png" width="800px"/>
			</div>
			<p>Все компаненты обозначенные голубым цветом - это пользовательские утилиты, т.е. програмная часть, с помощью которых осуществляется доступ к нижележащим таблицам фильтрации и преобразования пакетов. У <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в итоге к <b>&laquo;Xtables&raquo;</b>, соответственно у <b>&laquo;iptables-nftables&raquo;</b> и <b>&laquo;nft&raquo;</b> к <b>&laquo;nf_tables&raquo;</b>.</p>
			<p>Долгое время <b>&laquo;Xtables&raquo;</b>, встроенная в ядро, считалась единственным способом управления <b>Netfilter</b>-ом.</p>
			<p><b>iptables</b> — утилита командной строки для настройки встроенного в ядро Linux межсетевого экрана, разработанного в рамках проекта <b>Netfilter</b>.</p>
			<p>Термином iptables также часто называют сам межсетевой экран в ядре. Настройка экрана выполняется либо напрямую с помощью iptables, либо через один из фронтендов, консольных или графических. iptables работает с протоколом IPv4, для IPv6 разработана утилита ip6tables. В основном их синтаксис совпадает, но некоторые специфичные для протоколов опции различаются.</p>
			<p>Тем временем постепенно развивался проект <b>&laquo;nf_tables&raquo;</b>. Проект должен и выступил в качестве замены существующего фреймворка <b>&laquo;{ip,ip6,arp,eb}tables&raquo;</b> в 2021 году.</p>
			<p>Этот проект предоставляет новую систему фильтрации пакетов, пользовательскую утилиту ntf, а также слой совместимости с {ip,ip6}tables. nftables использует существующие хуки, отслеживание соединений, очереди в пространстве пользователя и подсистему логирования netfilter.</p>
			<p>Фреймворк iptables постепенно выходит из употребления; более современная замена — nftables, в котором предусмотрен слой совместимости.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-3.png" width="717px"/>
			</div>
			<p>В <b>Debian 11</b> фреймворк <b>nftables</b> встроен в систему по умолчанию со слоем совместимости для <b>iptables</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-4.png" width="717px"/>
			</div>
			<p><b>IPTABLES</b> умер в 2021 году. Он конечно всё ещё встроен во многие системы, но постепенно будет полностью заменён на более эффективный <b>NFTABLES</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/iptables-rip.png" width="277px"/>
			</div>
			<div style="clear:both"></div>
			<br>
			<hr>
			<p><u>Плохая новость:</u> документация <b>&laquo;NFTABLES&raquo;</b> (&laquo;nft&raquo;: man nft) содержит больше 3 тысяч строк.</p>
			<hr>
			<p>Для облегчения перехода можно конвертировать правила <u><i>iptables</i></u> в <u><i>nftables</i></u> с помощью утилит <u><i>iptables-translate</i></u>, <u><i>iptables-restore-translate</i></u>, <u><i>iptables-nft-restore</i></u> и т.п. Утилиты находятся в пакете <u><i>iptables</i></u>, который необходимо установливать отдельно.</p>
			<p>Грубо говоря, <b>Netfilter</b> по сути является как бы внутренней обороной ОС. Однако, самой ОС нужна ещё и внешняя оборона - инструмент или средство для управления брандмауэром, такие как <b>UFW</b> или <b>Firewalld</b>.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> - является самым простым и довольно популярным инструментарием командной строки для настройки и управления брандмауэром.</p>
			<p><b>Firewalld</b> — программное обеспечение для управления брандмауэрами, поддерживаемое многими дистрибутивами <b>Linux</b>.</p>
			<p>Чтобы понять как работает фильтрация пакетов в межсетевых экранах, для этого надо заглянуть в раздел <a href="#part4.3"><b>&laquo;Таблицы и цепочки IPTABLES&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.3"></a></p>
			<h3>4.3. Таблицы и цепочки IPTables.</h3>
			<p>Чтобы разобрать работу <b>Netfilter/iptables</b> возьмём схему работы из википедии.</p>
			<div class="images">
				<img src="../image/Blacklists-image/netfilter-diagram.png" width="400px"/>
			</div>
			<p>Ну, а для базового понимания схемы разберём с вами основные понятия: <i>таблицы, цепочки, действия над пакетами и механизм определения состояния</i>.</p>
			<p><u>Каждый из пунктов важен для понимания работы любого межсетевого экрана.</u></p>
			<p><b>Цепочки.</b></p>
			<ul>
				<li><b>PREROUTING</b> - для изначальной обработки входящих пакетов.</li>
				<li><b>INPUT</b> - для входящих пакетов, адресованных непосредственно локальному компьютеру.</li>
				<li><b>FORWARD</b> - для проходящих (маршрутизируемых) пакетов.</li>
				<li><b>OUTPUT</b> - для пакетов, создаваемых локальным компьютером, т.е. исходящих.</li>
				<li><b>POSTROUTING</b> - для окончательной обработки исходящих пакетов.</li>
			</ul>
			<p>Цепочки можно создавать самостоятельно, и также их уничтожать.</p>
			<p><b>Почти в каждой цепочке имеется 4 таблицы:</b></p>
			<ul>
				<li><b>raw</b> - пакет проходит данную таблицу до передачи системе определения состояний. Используется редко, например для маркировки пакетов, которые НЕ должны обрабатываться системой определения состояний. Для этого в правиле указывается действие NOTRACK. Содержитcя в цепочках PREROUTING и OUTPUT.</li>
				<li><b>mangle</b> - содержит правила модификации IP‐пакетов. Среди прочего, поддерживает действия TTL, TOS, и MARK (для изменения полей TTL и TOS, и для изменения маркеров пакета). Редко необходима и может быть опасна.</li>
				<li><b>nat</b> - предназначена для подмены адреса отправителя или получателя. Данную таблицу проходят только первый пакет из потока, трансляция адресов или маскировка (подмена адреса отправителя или получателя) применяются ко всем последующим пакетам в потоке автоматически. Поддерживает действия <i>DNAT</i>, <i>SNAT</i>, <i>MASQUERADE</i>, <i>REDIRECT</i>. Содержится в цепочках <i>PREROUTING</i>, <i>OUTPUT</i>, и <i>POSTROUTING</i>.</li>
				<li><b>filter</b> - основная таблица, используется по умолчанию если название таблицы не указано. Используется для фильтрации пакетов. Содержится в цепочках INPUT, FORWARD, и OUTPUT.</li>
			</ul>
			<p><b>Действия над пакетами.</b></p>
			<ul>
				<li><b>ACCEPT</b> - принять пакет.</li>
				<li><b>DROP</b> - отбросить пакет, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>REJECT</b> - отбросить пакет, отправив отправителю ICMP-сообщение, при этом пакет не передается в другие таблицы/цепочки.</li>
				<li><b>RETURN</b> - возвратить пакет в предыдущую цепочку и продолжить ее прохождение начиная со следующего правила.</li>
				<li><b>SNAT</b> - применить трансляцию адреса источника в пакете. Может использоваться только в цепочках <b>POSTROUTING</b> и <b>OUTPUT</b> в таблицах <b>nat</b>.</li>
				<li><b>DNAT</b> - применить трансляцию адреса назначения в пакете. Может использоваться в цепочке <b>PREROUTING</b> в таблице <b>nat</b>.</li>
				<li><b>LOG</b> - протоколировать пакет и обработать остальными правилами.</li>
				<li><b>MASQUERADE</b> - используется вместо <b>SNAT</b> при наличии соединения с динамическим <b>IP</b> (допускается указывать только в цепочке <b>POSTROUTING</b> таблицы <b>nat</b>).</li>
				<li><b>MARK</b> - используется для установки меток на пакеты, передается для обработки дальнейшим правилам.</li>
			</ul>
			<p>Есть и другие действия. Остановимся на базовых.</p>
			<p><b>Механизм определения состояний (conntrack).</b></p>
			<p>В общем, механизм определения состояний (он же state machine, он же connection tracking, он же conntrack) является частью пакетного фильтра и позволяет определить определить к какому соединению/сеансу принадлежит пакет.</p>
			<p><b>Conntrack</b> анализирует состояние всех пакетов, кроме тех, которые помечены как NOTRACK в таблице raw. На основе этого состояния определяется принадлежит пакет новому соединению (состояние NEW), уже установленному соединению (состояние ESTABLISHED), дополнительному к уже существующему (RELATED), либо к "другому" (неопределяемому) соединению (состояние INVALID). Состояние пакета определяется на основе анализа заголовков передаваемого TCP-пакета. Модуль conntrack позволяет реализовать межсетевой экран сеансового уровня (пятого уровня модели OSI). Для управления данным механизмом используется утилита conntrack, а так же параметр утилиты iptables: -m conntrack или -m state. Состояния текущих соединений conntrack хранит в ядре. Их можно просмотреть в файле /proc/net/nf_conntrack (или /proc/net/ip_conntrack).</p>
			<hr>
			<p>Итак, разберём схему работы.</p>
			<p>Пакет (из интернета в сеть, затем) из сети обязательно проходит цепочку <b>PREROUTING</b>, далее попадает в таблицу маршрутизации и в зависимости от принадлежности определяет куда пойдёт дальше. Если пакет не адресован локальной системе, он попадёт в цепочку <b>FORWARD</b>. Если адресован - в цепочку <b>INPUT</b>. После <i>INPUT</i> пакет обрабатывают системные процессы и демоны. После локальной обработки программы могут сформировать ответ и этот ответ в соответствии с правилами маршрутизации направляется в цепочку <b>OUTPUT</b>. Затем снова маршрутизируется и наконец попадает в цепочку <b>POSTROUTING</b>, как и пакет из цепочки <b>FORWARD</b>. И только после всех этих манипуляций с пакетом он наконец вновь отправляется обратно в сеть и уже дальше в интернет, если стоит такая задача.</p>
			<p><b>Почему пакет несколько раз проходит через таблицу маршрутизации?</b></p>
			<p>Каждая цепочка, которую проходит пакет состоит из набора таблиц (table). Таблицы в разных цепочках имеют одинаковое наименование, но тем не менее никак между собой не связаны. Например таблица nat в цепочке PREROUTING никак не связана с таблицей nat в цепочке POSTROUTING. Каждая таблица состоит из упорядоченного  набора (списка) правил. Каждое правило содержит условие, которому должен соответствовать проходящий пакет и действия к пакету, подходящему данному условию.</p>
			<p>Проходя через серию цепочек пакет последовательно проходит каждую таблицу и в каждой таблице последовательно сверяется с каждым правилом, и если пакет соответствует какому-либо критерию, то выполняется заданное действие над пакетом. При этом, в каждой таблице (кроме пользовательских) существует заданная по-умолчанию политика. Данная политика определяет действие над пакетом, в случае, если пакет не соответствует ни одному из правил в таблице. Чаще всего - это действие ACCEPT, чтобы принять пакет и передать в следующую таблицу или DROP - чтобы отбросить пакет. В случае, если пакет не был отброшен, он завершает свое путешествие по ядру системы и отправляется в сетевой интерфейс, которая подходит по правилам маршрутизации.</p>
			<p><u>Таблица <b>nat</b> и <b>mangle</b> может модифицировать получателя или отправителя сетевого пакета. Именно поэтому сетевой пакет несколько раз сверяется с таблицей маршрутизации.</u></p>
			<p>Блокировку и разблокировку ip-адресов, разрешающие и запрещающие правила, а также сохранение состояния при перезагрузке <b>ОС</b> вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part6"><b>&laquo;Безопасность сетевых соединений: 6. Блокировка ip адреса или всей подсети&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.4"></a></p>
			<h3>4.4. NFTABLES.</h3>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные таблицы. Количество таблиц и их имена определяется пользователем. Тем не менее, каждая таблица имеет только одно семейство адресации и применяется к пакетам только этого семейства.</p>
			<p>В отличие от <b>iptables</b>, в <b>nftables</b> отсутствуют встроенные цепочки. Соответственно, если опрелённые типы или хуки фреймворка <b>netfilter</b> не задействованы ни в одной цепочке, то проходящие через эти цепочки пакеты обрабатываться не будут (в отличие от <b>iptables</b>).</p>
			<p>Есть два типа цепочек. Базовая цепочка является точкой входа для пакетов из сетевого стека; в ней указывается хук. Обычная цепочка может использоваться в качестве цели перехода и используется для лучшей организации правил.</p>
			<p>Все спрашивают почему я так люблю <b>Acrhlinux</b> - как минимум за его прекрасную векипедию. Поэтому более подробную информацию о работе с <b>NFTABLES</b> вы можете найти на его страницах в статье: <a target="_blank" href="https://wiki.archlinux.org/title/Nftables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)"><b>&laquo;ArchWiki: nftables (Русский)&raquo;</b></a>, а если вам будет мало этой информации и у вас по прежнему останутся пару вопросов - добро пожаловать в статью на losst.pro: <a target="_blank" href="https://losst.pro/kak-polzovatsya-nftables"><b>&laquo;losst.pro: Как пользоваться nftables&raquo;</b></a>.</p>
			<p>В этих статья подробно с разъяснено как работать с <b>NFTABLES</b>. Словом, мне дополнить нечем. Читайте внимательно, тогда ничего не пропустите и вам всё будет понятно.</p>
			<p>Разьве что <u>раздел установки для разных дистрибутивов <b>Linux</b> будет у всех разный. Во всём остальном - и настройки и работа с фреймворком будет абсолютно одинаковой.</u></p>
			<p><b>Но самое главное в том, что знание схемы движения пакетов в системе IP(6)TABLES даёт вам базовое понимание того, какие таблицы и цепочки с предопределёнными типами и хуками для работы вашего сервера нужно будет создавать, а также какие правила и приоритеты устанавливать для этих цепочек. Понимание работы IP(6)TABLES значительно ускоряет процес настройки.</b></p>
			<p>Также уделите внимание <b>Firewalld</b>, ибо с ним, вам в разы меньше придётся создавать различных таблиц, цепочек и правил поведения вашего сервера, включая <b>nat</b>-преобразование адресов, в разы будет усилена защита, но также может и в разы усложниться жизнь при работе с различными сервисами в т.ч. базами данных.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.5"></a></p>
			<h3>4.5. UFW / Firewalld.</h3>
			<p>Cерверы постоянно подвергаются различным атакам или сканируются в поиске уязвимостей. Как только эти уязвимости находятся, мы рискуем стать частью ботнета, раскрыть конфиденциальные данные или потерять деньги из-за сбоев в работе веб-приложений. Одной из первых мер по снижению рисков безопасности является грамотная настройка правил межсетевого экрана.</p>
			<p><b>UFW (Uncomplicated Firewall)</b> — удобный интерфейс для управления политиками безопасности межсетевого экрана. Он представляет собой интерфейс iptables, предназначенный для упрощения процесса настройки брандмауэра. Хотя iptables — надежный и гибкий инструмент, начинающим бывает сложно научиться использовать его для правильной настройки брандмауэра.</p>
			<p>Подробно об установке и настройке <b>UFW</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part4.1"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.1. Фаервол UFW&raquo;</b></a>.</p>
			<p>По сути <b>UFW</b> и <b>Firewalld</b> это фасад сервера, а <b>{IP,IP6,ARP,EB}Tables / NFTables</b> - это интерьер.</p>
			<p><b>Firewalld</b> - более продвинутая утилита управления <b>Linux</b> брандмауэром <b>Netfilter</b>. Несмотря на собственный синтаксис, имеет такой же принцип работы, как и <b>Iptables</b>.</p>
			<p>В отличие от <b>IPTABLES</b> имеет более продвинутую безопасность, настройки, стабильную работу, а также сохранение правил фильтрации и маршрутизации без лишних скриптов и сервисов, и многое другое.</p>
			<p>Подробно об установке и настройке <b>Firewalld</b> фаервола вы можете посмотреть в статье: <a target="_blank" href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part4.2"><b>&laquo;Безопасность сетевых соединений: 4. Фаерволы: 4.2. Фаервол Firewalld&raquo;</b></a>.</p>
			<p><u><b>Удивительно, но Docker не работает из коробки с UFW, т.е. &laquo;Universal Firewall&raquo; Linux.</b></u></p>
			<p>Проблема в том, что <b>UFW</b> и <b>Docker</b> пытаются изменить одни и те же базовые правила брандмауэра. В результате фаервол разрешает трафику идти дальше к <b>Docker</b>-контейнерам.</p>
			<p>Допустим вы настроете базовый брандмауэр <b>UFW</b> на запрет по умолчанию и сделаете разрешение по <i>HTTP</i> и <i>SSH</i> портам. Однако, <b>UFW</b> не будет блокировать доступ к <b>Docker</b>-контейнерам, которые привязаны к другим портам.</p>
			<p>Эту проблему может быть трудно обнаружить, поскольку <b>UFW</b> и <b>Docker</b> – это отдельные системы.</p>
			<p>Тем не менее, <b>UFW</b> покажет, что всё настроено верно и с вашего рабочего места так и будет выглядеть, даже с учетом белого списка доступа. В результате вам будет казаться что всё в порядке. Но это не так!</p>
			<p>Если какое-либо приложение запущено через <b>Docker</b>, например на порту 8000, то по умолчанию это приложение будет видно из любого места за пределами сервера.</p>
			<p>Это может стать серьезной проблемой, если вы не решите ее! Потому что у любого пользователя интернета появляется возможность обращаться к любым сервисам внутри сервера по портам, включая и базы данных, и сервисы контроля баз (например, PHPMyAdmin). При этом пределить доступные порты для подключения абсолютно не сложно.</p>
			<p>Для совмещения <b>Docker</b>-а и <b>UFW</b> воспользуйтесь статьёй: <a href="https://itsecforu.ru/2022/07/06/%F0%9F%90%B3-%D0%BA%D0%B0%D0%BA-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-docker-%D1%81-ufw-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE/"><b>&laquo;Как использовать Docker с UFW параллельно&raquo;</b></a>.</p>
			<p>Однако, не спешите переходить по ссылке. В данной статье используются решения, основанные на <b>IPTABLES</b>, фреймворке, который постепенно выходит из употребления.</p>
			<p>Эти правила специфичны для каждого отдельного сервера и их придётся корректировать, чтобы они работали правильно. А самое забавное в том, что когда вы будете запускать какой-то новый <b>Docker</b>-контейнер - правила снова придётся корректировать. Плюс ко всему их обязательно необходимо восстанавливать при перезапуске ОС.</p>
			<p><u>Не факт, что у вас получится, но если получится - вы счастливчик.</u> Но, опять таки, не спешите радоваться. Потому что ваша настройка, скорее всего, продержится максимум лет 5...10, пока последний фреймворк полностью не заместит всеми любимый <b>IPTABLES</b>.</p>
			<p>Из сложившейся ситуации есть выход - фаервол <b>Firewalld</b>.</p>
			<p>В свою очередь он требует тщательной настройки и понимания как всё устроено! А самое главное - он легко совмещается с <b>Docker</b>-контейнерами.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part4.6"></a></p>
			<h3>4.6. Примеры использования UFW / Firewalld.</h3>
			<p>Вот тут начинается самое интересное!</p>
			<p>Рассмотрим с вами несколько примеров на основе моего <b>Archlinux</b> на ноутбуке и виртуальной машине на <b>Debian 11</b> со следующими характеристиками:</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-5.png" width="1024px"/>
			</div>
			<p>Самое главное здесь то, что <u>сеть</u> установлена <u>в режиме сетевого моста</u>. Таким образом, если в <b>ОС</b> нет никаких фаерволов, кроме межсетевого экрана, то все внутренние сервисы должны быть доступны в локальной сети по <b>IP</b>-адресу, буквально напрямую.</p>
			<p>Последовательно произведём все, почте без исключения, настройки по порядку, согласно статье: <a href="https://maximalisimus.github.io/Articles/webpage/Configuratons_Linux_Servers.html#oglavlenie"><b>&laquo;Базовые настройки серверов Linux&raquo;</b></a>, но установим и настроим, пока что, фаервол <b>UFW</b>.</p>
			<p>В <b>Docker</b> установим 2 сервиса: <b>Whoogle</b> и <b>Portainer</b> - как наиболее простые для проведений тестов. К первому проще всего прикрутить <b>NGINX</b> и <b>Fail2ban</b>, а с помощью второго будет легче следить за всеми контейнерами.</p>
			<p>Запуск <b>Portainer</b>-а:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir -p portainer-data && cd portainer-data
<b>$</b> nano docker-compose.yml
version: &quot;3&quot;

volumes:
  portainer_data:

services:

  portainer:
    image: portainer/portainer-ce
    container_name: portainer
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    ports:
      - 9000:9000
      - 8000:8000
    restart: always

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<p>Запуск <b>Whoogle</b>:</p>
			<div class="codeses">
				<pre>
<b>$</b> cd ~
<b>$</b> mkdir whoogle && cd whoogle
<b>$</b> nano docker-compose.yml
---
version: '2'
services:
	whoogle:
		image: benbusby/whoogle-search:latest
		container_name: whoogle
		ports:
			- 5000:5000
		restart: unless-stopped

<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$</b> sudo docker-compose up -d</pre>
			</div>
			<br>
			<div class="images">
				<img src="../image/Blacklists-image/bls-6.png" width="1024px"/>
			</div>
			<p>Без вышеупомянутого совмещения <b>Docker</b>-а и <b>UFW</b> все внутренние сервисы <b>Docker</b>-а будут доступны за пределами вашего сервера.</p>
			<p>Проверить последнее утверждение не составит никакого труда. Можно это сделать с помощью браузера, а можно воспользоваться утилитой <b>Curl</b>, которая вернёт нам статусное состояние нашего <b>NGINX</b>.</p>
			<p>Т.е. если мы увидим в консоли ответ в виде числа <u><b>200</b></u> - значит и в браузере мы увидим сайт или сервис виртуальной машины, расположенный по запрашиваемому веб-адресу.</p>
			<p>При числах - вроде 1xx или 3xx - скорее всего мы сами запрашиваем неправильно, например веб-адрес.</p>
			<p>При числах - 4xx и 5xx - это ошибки в запросе и ошибки сервера.</p>
			<p>А вот если у нас будет число <u><b>000</b></u> - это будет значит сразу 3 вещи:</p>
			<ul>
				<li>Сервис не доступен за фаерволом.</li>
				<li>Настройка фаервола выполнена верно.</li>
				<li>и <b>Docker</b> с фаерволом вполне неплохо ужились на одном сервере.</li>
			</ul>
			<p>Команда <b>curl</b> выглядит следующим образом:</p>
			<p class="codes">
				curl -s -o /dev/null -w "%{http_code}\n" веб-адрес
			</p>
			<p>Например.</p>
			<p class="codes">
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120/<br>
				<span style="color:blue;"># и</span></br>
				<b>$</b> curl -s -o /dev/null -w "%{http_code}\n" https://192.168.0.120:9000/</br>
				<span style="color:blue;"># т.к. запущен сервис и whoogle и portainer</span>
			</p>
			<p>Смотрим на результат.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-7.png" width="1024px"/>
			</div>
			<p>Без указанного совмещения всё печально. Все сервисы, какие бы у вас не были запущены будут доступны за пределами сервера - и базы данных (например, MySQL / MariaDB) и сервисы доступа к последним (например, PHPMyAdmin) и многое другое, что вы не хотели бы выпускать в открытый доступ в интернет.</p>
			<p>Однако, есть гораздо более продвинутая альтернатива - <b>Firewalld</b>.</p>
			<p>Теперь согласно указанной инструкции настройки серверов, установим и настроим <b>Firewalld</b>, запустим <b>Fail2ban</b>.</p>
			<p>Прямой просмотр <b>Systemd</b> может выглядеть достаточно ёмко, т.е. занимать много экранного места. Вместо этого в <b>systemctl</b> существует такая операция, как <b>&laquo;is-active&raquo;</b>. Дословно - <b>&laquo;Check whether units are active&raquo;</b> переводится как - <b>&laquo;Проверка активности устройства&raquo;</b>.</p>
			<p>Т.е. на выходе у нас будет конкретный ответ - запущен ли тот или иной сервис, сокет или таймер или нет.</p>
			<p>Также с помощью <b>Curl</b> проверяем доступность запущенных <b>docker</b> сервисов. Я же, согласно инструкции, давал доступ только к <b>NGINX</b> портам - 80 и 443. 51820 в данном случае служит примером настроек <b>wireguard</b>.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-8.png" width="1024px"/>
			</div>
			<p><span style="color:green;"><b>ЧУДО СВЕРШИЛОСЬ, причём без танцев с бубном!</b></span> Шутка. Но в каждой шутке...</p>
			<p><u>Внутренние сервисы, к которым вы явно не давали доступа теперь не доступны за пределами самого сервера.</u></p>
			<p><span style="color:blue;">Это не может не радовать.</span></p>
			<p>При этом лишний раз лазить в <b>IP(6)TABLES / NFTABLES</b> не придётся.</p>
			<p>На самом деле дело в том, что в <b>Firewalld</b> имеется несколько сетей по умолчанию - внутренняя, внешняя (публичная) и другие. Это непосредственно связано с принципом работы самого фаервола как такового. Все сети разделяются разными правами доступа, разными политиками обработки пакетов, разными приоритетами и т.д. и т.п. Т.е. для любого сервиса можно настроить своё собственное поведение. Таким образом, для каждого сервиса будут разные базовые правила брендмауера, которые вы сами настроили. В итоге <b>Docker</b> просто перестаёт конфликтовать с фаерволом. Только если явно не указать другие настройки.</p>
			<p>Правда появляется другой недостаток - не возможно запустить или остановить какой-либо <b>Docker-контейнер</b>. Для этого просто остановите сервис фаервола. Этого будет вполне достаточно.</p>
			<p class="codes">
				<b>$</b> sudo systemctl stop firewalld.service
			</p>
			<p>Если вы настраивали фаервол по моей инструкции и создавали таймер запуска, то сначала придётся остановить этот таймер и затем уже сервис. Поработали с контейнерами - что-то остановили, что-то запустили, после этого вновь запустите только один сервис фаервола. Если у вас есть связанный с фаерволом <b>Fail2ban</b>, то и его и таймер, и сервис тоже надо будет остановить, а после всех работ запустить хотя бы сервис. После этого не забудьте проверить новые сети <b>Docker</b>-контейнеров и обязательно добавить их во внутреннюю зону <b>internal</b> фаервола с сохранением параметров при перезагрузке.</p>
			<p class="codes">
				<b>$</b> sudo systemctl stop firewalld.timer<br>
				<b>$</b> sudo systemctl stop firewalld.service<br><br>
				<b>$</b> sudo systemctl start firewalld.timer<br>
				<b>$</b> sudo systemctl start firewalld.service
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part4">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part5"></a></p>
			<h2>5. Fail2ban</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava5 { 
					counter-reset: list2; /* Список первого уровня*/ 
				} 
				.glava5 li:before { /* Список первого уровня */ 
					counter-increment: list2; /* Увеличиваем значение счетчика */ 
					content: "5." counter(list2) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava5">
				<li><a href="#part5.1">Оперативная память.</a></li>
			</ol>
			<hr>
			<p><b>Fail2Ban</b> – программа для защиты серверов от атак методом грубой силы. Написанная на языке <b>Python</b>, может работать на <b>POSIX-системах</b> имеющих встроенный менеджер пакетов и брандмауэр. Например, <b>IPTABLES</b> или <b>NFTABLES</b>. Также работает и с <b>Firewalld</b>.</p>
			<p>Описывая <b>Fail2ban</b> в двух словах, можно сказать, что он позволяет на основе анализа логов блокировать тех, кто злоупотребляет доступностью сервера по сети. Например, защитить почтовые ящики от взлома путем перебора паролей или многократного запроса какого-либо ресурса.</p>
			<p><b>Fail2Ban</b> считывает логи (например, /var/log/apache2/error.log) и блокирует IP-адреса, активность которых является подозрительной (например, большое количество попыток войти с неправильно введенным паролем, выполнение опасных или бессмысленных действий и т.д.). В случае обнаружения подобных действий программа обновляет правила брандмауэра для блокировки такого IP-адреса на определенный промежуток времени. Программа может быть настроена и для выполнения любых других действий (например, отправки электронного письма).</p>
			<p>Конфигурация программы по умолчанию содержит фильтры для Apache, Lighttpd, sshd, vsftpd, qmail, Postfix, Courier Mail Server, Asterisk и других популярных серверных приложений. В фильтрах используются регулярные выражения, которые могут быть легко изменены и настроены в случае необходимости.</p>
			<p>Говоря о слабых сторонах <b>Fail2Ban</b>, вы должны знать, что он не очень хорошо работает против распределенных атак методом перебора. Причина в том, что мониторинг лог-файлов происходит примерно раз в секунду. Этого должно быть достаточно в большинстве случаев, однако можно получить больше отказов входа, чем указано в параметре “maxretry”.</p>
			<p>Таким образом мы понимаем, что во первых файловый дескриптор какого-либо лога будет практически постоянно открыт и на чтение и на запись. Поэтому обратиться к файлу того или иного журнала с помощью стороннего скрипта может оказаться проблематично. Да и во вторых эффективность у <b>Fail2ban</b>-а, мне кажется, будет несколько выше, чем у сторонних скриптов и утилит.</p>
			<p>На самом деле, прописать регулярные выражения для собственных фильтров (если таковые понадобятся) не так уж и сложно, как кажется на первый взгляд. А уж тем более создать свои собственные экшены действий при обнаружении нежелательной активности.</p>
			<p><b>Таким образом необходимость в сторонних скриптах и утилитах анализа практически полностью отпадает.</b></p>
			<p>Нужны будут только скрипты или утилиты для работы с самими пойманными ip-адресами для того, чтобы прописать их в экшенах <b>Fail2ban</b>-а. Т.е. что делать с этими адресами вы решаете самостоятельно - блокировать навсегда или сделать что-то другое.</p>
			<p>Или же вы вполне можете прописать в экшенах отправку уведомлений по электронной почте или даже по СМС. Вообщем, на что хватит фантазии ...</p>
			<p>У <b>Fail2Ban</b> довольно низкие системные требования. При конфигурации только с <b>sshd</b> и несколькими различными правилами, <b>Fail2Ban</b> требует около 500 Мб памяти и загружает 1 ядро CPU в среднем менее чем на 0,2%.</p>
			<p>Если вам нужна информация по установке и настройке <b>Fail2ban</b>-а, фильтрам, экшенам и действиям с разлиными примерами - обратитесь к статье: <a href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part5.0"><b>&laquo;Безопасность сетевых соединений: 5. Fail2ban.&raquo;</b></a>.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part5">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part5.1"></a></p>
			<h3>5.1. Оперативная память.</h3>
			<p>Прежде чем обращаться к параметрам оперативной памяти процессов в <b>Linux</b> системах необходимо разобраться в нескольких понятиях, без которых вы можете не только запутаться в значениях, но и неверно их истолковать. В результате у вас будут ложные сведения не совпадающие с реальностью.</p>
			<p>Физическая память остается после отключения питания. Оперативная память после отключения питания обнуляется.</p>
			<p>К физической памяти можно отнести и жесткие диски (ЖД), в том числе, и твердотельные, встроенные к компьютер и внешние, а так же "флешки", забываемые ныне дискеты и пр.</p>
			<p>Оперативная память - планки оперативной памяти (хранят информацию только при работе компьютера).</p>
			<p>С виртуальной памятью можно легко соприкоснуться в случае, если операционной системе не хватает оперативной. В этом случае нехватка располагается на жестком или твердотельном диске.</p>
			<p>Виртуальная память - это область выделенная Операционной системой на жестком диске!</p>
			<p>Виртуальная память - временное хранилище, используемое компьютером для выполнения программ, превышающих размер доступной оперативной памяти. Например, программы могут использовать до 4 Гбайт виртуальной памяти на жестком диске, в то время как оперативная память компьютера составляет всего 32 Мбайт. Данные программы, для которых нет свободного места в оперативной памяти, сохраняются в файлах подкачки.</p>
			<p>Файл подкачки - Скрытый файл на жестком диске, используемый для хранения частей программ и файлов данных, не помещающихся в оперативной памяти. Файл подкачки и физическая память составляют виртуальную память. По мере необходимости операционная система перемещает данные из файла подкачки в оперативную память (для их использования программами) и обратно (для освобождения места для новых данных).</p>
			<p>Посмотрим сколько реально памяти занимает <b>Fail2ban</b> - физической, виртуальной, оперативной. Для начала посмотрим на физическую и фиртуальную.</p>
			<p class="codes">
				<b>$</b> ps -aux | grep -Ei "fail2ban"</br>
				<b>$</b> pgrep fail2ban</br>
				<b>$</b> free -h</br>
				<b>$</b> echo -e -n "$(ps -aux --sort -rss | sed '2,$d')\n$(ps -aux --sort -rss | grep -Ei 'fail2ban')\n"</br>
				<b>$</b> ps -p 1044 v
			</p>
			<br>
			<div class="images">
				<img src="../image/Blacklists-image/bls-9.png" width="800px"/>
			</div>
			<p>Ещё немного физической и виртуальной памяти, но уже с помощью прямого доступа к информации о процессе.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-10.png" width="800px"/>
			</div>
			<p>А теперь посмотрим на все эти данные вместе и разберёмся что происходит на всех скриншотах работы виртуальной машины.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-11.png" width="800px"/>
			</div>
			<p>Итак, на скриншотах имеются следующие переменные:</p>
			<ul>
				<li><b>USER</b> - Пользователь, от имени которого работает процесс.</li>
				<li><b>PID</b> - Идентификатор процесса.</li>
				<li><b>RSS</b>, <b>VmRSS</b> - Неподкачиваемая физическая память, используемая процессом.</li>
				<li><b>VSZ</b>, <b>VmSize</b>, <b>VmPeak</b> - Виртуальная память, используемая процессом - 2 текущих, т.е. в данный момент и пиковая, т.е. максимальная.</li>
				<li><b>SIZE</b>, <b>%MEM</b> - Оперативная память - в килобайтах и процентах соответственно.</li>
			</ul>
			<p>Как вы можете видеть - те самые 500 с лишним Мб - это виртуальной памяти. Реально же в оперативной всего 70 Мб. Соответственно физической памяти всего 24 Мб.</p>
			<p>А теперь немного данных с реального <b>VPS</b> сервера.</p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-12.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-13.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-14.png" width="800px"/>
			</div>
			<p><b>Проведём небольшое расследование оперативной и физической памяти. Посмотрим дурят нас или нет.</b></p>
			<p>Сначало необходимо узнать, а сколько у нас вообще имеется оперативной памяти и подкачки?</p>
			<p class="codes">
				<b>$</b> free -h
			</p>
			<p>После этого посмотрим сумму оперативной памяти всех процессов, затем также сумму физической памяти всех процессов. Смотреть на сумму виртуальной памяти бессмыслено - она будет занимать по меньшей мере около 10 Гб, а то и в разы больше.</p>
			<p class="codes">
				<b>$</b> ps -eo size --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'<br>
				<b>$</b> ps -eo rss --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'</br>
				<b>$</b> ps -eo vsz --sort -size | sed '1d' | awk '{ sum += $1 } END { print sum }'
			</p>
			<p><b>Подведём итоги</b> - общий объём оперативной памяти минус (сумма используемой памяти и кешируемой) должна примерно равняться свободной оперативной памяти.</p>
			<p><u>Если это так - то всё нормально!</u> <b>Если нет - у нас, возможно, утечка памяти и тогда - проблему необходимо решать! +/- 20...30 Мб обычное дело.</b></p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-15.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-16.png" width="800px"/>
			</div>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part5">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part6"></a></p>
			<h2>6. NGINX / Nginx Proxy Manager.</h2>
			<p><b>Nginx (NGINX, Engine-X, &laquo;Энджин-икс&raquo;)</b> — это веб-сервер, прокси-сервер, обратный прокси-сервер, smtp-сервер и балансировщик нагрузки с открытым кодом.</p>
			<p><b>Веб-сервер</b> — это программа, которая принимает и обрабатывает запросы от клиентов по протоколам HTTP и HTTPS и возвращает им ответ в виде HTML-страницы.</p>
			<p>Прокси-сервер принимает и обрабатывает запросы клиентов, а затем передает их дальше, другим программам.</p>
			<p><b>Обратный прокси-сервер</b> — принимает результат работы других серверов и отдаёт его клиентам. </p>
			<p><b>&laquo;Nginx Proxy Manager&raquo;</b> - является обратным прокси(reverse proxy), основанным на Nginx. Имеет приятный и интуитивно понятный веб интерфейс. Используется для того чтобы проксировать Ваше приложение на необходимый домен или под-домен. Другими словами для привязывания контейнера к домену или под-домену. <b>NPM</b> в автоматическом режиме будет продлевать самообновляющийся сертификаты каждые 3 месяца за нас. Ещё <b>NPM</b> умеет работать с редиректами и стримами.</p>
			<p><u>По сравнению с простым <b>NGINX</b> просто песня, если не сказка. Всё бы ничего, но есть и целая тарелка дёгтя в этой бочке мёда.</u></p>
			<div class="images">
				<img src="../image/Blacklists-image/bls-17.png" width="800px"/>
				<div style="clear:both"></div><br>
				<img src="../image/Blacklists-image/bls-18.png" width="800px"/>
			</div>
			<ul>
				<li>Количество файлов журналов на порядок увеличится.</li>
				<li>Вы можете включить защиту от эксплоитов, <b>DDOS</b> атак, <b>HSTS</b>. Но, к сожалению, вы не будете иметь понятия что это за настройки и на что они влияют. При настройке определенных веб-ресурсов это важно знать! Искать эти настройки внутри контейнера <b>NPM</b>, только для того, чтобы разобраться что это за настройки крайне не удобно. Вам, скорее всего, придётся пробрасывать от этих файлов доступ наружу к системе в режиме только для чтения. И вы не будете наверняка уверены - будут ли эти файлы от сайта к сайту меняться или оставаться неизменными.</li>
				<li>Читать файлы журналов, у которых проброшен доступ изнутри контейнера в систему в режиме только для чтения не самая лучшая идея. Могут возникнуть проблемы с различными правами доступа прямо во время работы. В результате вы, скорее всего, не сможете прочитать нужные файлы логов или данные могут быть не полными.</li>
				<li>В менеджере есть только стандартные настройки безопасности. Остальных, имеющихся в <b>NGINX</b> по умолчанию, нет. Вы, конечно, можете прописать различные параметры на последней вкладке вручную текстом. Однако, это придётся делать для каждого веб-адреса.</li>
				<li>При необходимости создать отдельную <b>NGINX</b>-файлопомойку у вас ничего не получится. Такая функция не поддерживается. Вам, как минимум, придётся создавать отдельный контейнер с <b>NGINX</b> на неком порту, и уже затем прописывать к нему <b>Nginx Reverse Proxy</b> доступ. Самое забавное в том, что не понятно где лучше прописывать ручные настройки безопасности и <b>SSL</b> - в контейнере или в самом <b>NPM</b> на последней вкладке во время добавления прокси хоста. В каком месте будет работать, а в каком нет?</li>
			</ul>
			<p>Дело в том, что с большим количеством журналов не столько может возникнуть путаница, сколько на порядок возрастёт потребляемая оперативная память в <b>Fail2ban</b>-е. Да и нагрузка на процессор точно не заставит себя ждать.</p>
			<p>Прибавьте к этому неизвестные параметры для <b>SSL</b> сертификатов, которые хотелось бы контролировать.</p>
			<p>И ещё много других недостатков.</p>
			<p>Говоря о настройках безопасности, имеются введу следующие:</p>
			<ul>
				<li>NGINX DDoS (req limit).</li>
				<li>NGINX настройка файлов.</li>
				<li>NGINX настройка сжатия GZIP.</li>
				<li>NGINX X-XSS-Protection.</li>
				<li>NGINX X-Frame-Options.</li>
				<li>NGINX X-Permitted-Cross-Domain-Policies.</li>
				<li>NGINX Strict-Transport-Security.</li>
				<li>NGINX X-Content-Type-Options.</li>
				<li>NGINX настройки SSL.</li>
				<li>Nginx Отключение серверных токенов.</li>
				<li>Nginx Задание размеров буферов.</li>
			</ul>
			<p>И многие другие параметры. Это базовые, одни из наиболее важных, на мой взгляд, правил.</p>
			<p>Мне кажется, что такой менеджер подойдёт только новичкам, которые толком ничего не знают об <b>NGINX</b>. Хотя, по мне, так лучше сразу начать его изучать.</p>
			<p>К тому же, если у вас на сервере предполагается иметь некие конфедициальные или личные данные я бы сразу начал настраивать только <b>NGINX</b>.</p>
			<p>Объяснение всех настроек безопасности для <b>NGINX</b> можете посмотреть в статье: <a href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part5.0"><b>&laquo;Безопасность сетевых соединений: 5. Fail2ban&raquo;</b></a>.</p>
			<p>Пример готовых настроек безопасности можно посмотреть в статье: <a href="https://maximalisimus.github.io/Articles/webpage/Configuratons_Linux_Servers.html#part16"><b>&laquo;Базовые настройки серверов Linux: 16. Nginx Reverse Proxy.&raquo;</b></a>.</p>
			<p>Если всё таки решите устанавливать <b>NPM</b> в <b>Docker</b>-контейнер вместо <b>NGINX</b>, но вместе с <b>Fail2ban</b>-ом, будьте готовы к множеству трудностей, среди которых оперативная память будет занимат далеко не последнее место.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part7"></a></p>
			<h2>7. Черный и белый списки.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava7 { 
					counter-reset: list3; /* Список первого уровня*/ 
				} 
				.glava7 li:before { /* Список первого уровня */ 
					counter-increment: list3; /* Увеличиваем значение счетчика */ 
					content: "7." counter(list3) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava7">
				<li><a href="#part7.1">Черный и белый список. Введение.</a></li>
				<li><a href="#part7.2">Скрипты.</a></li>
				<li><a href="#part7.3">Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</a></li>
				<li><a href="#part7.4">Работа с логами, командами и выводом информации.</a></li>
				<li><a href="#part7.5">Работа с черным и белым списками.</a></li>
				<li><a href="#part7.6">IP(6)TABLES / NFTABLES.</a></li>
				<li><a href="#part7.7">Работа с таблицами и цепочками.</a></li>
				<li><a href="#part7.8">Запуск / остановка.</a></li>
				<li><a href="#part7.9">Systemd.</a></li>
			</ol>
			<hr>
			<p><a name="part7.1"></a></p>
			<h3>7.1. Черный и белый список. Ведение.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.2"></a></p>
			<h3>7.2. Скрипты.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.3"></a></p>
			<h3>7.3. Символическая ссылка в <b>&laquo;/usr/bin/&raquo;</b>.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.4"></a></p>
			<h3>7.4. Работа с логами, командами и выводом информации.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.5"></a></p>
			<h3>7.5. Работа с черным и белым списками.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.6"></a></p>
			<h3>7.6. IP(6)TABLES / NFTABLES.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.7"></a></p>
			<h3>7.7. Работа с таблицами и цепочками.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.8"></a></p>
			<h3>7.8. Запуск / остановка.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part7.9"></a></p>
			<h3>7.9. Systemd.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part7">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part8"></a></p>
			<h2>8. Использование скриптов в Fail2ban.</h2>
			<h3>Содержание главы.</h3>
			<style> 
				.glava8 { 
					counter-reset: list4; /* Список первого уровня*/ 
				} 
				.glava8 li:before { /* Список первого уровня */ 
					counter-increment: list4; /* Увеличиваем значение счетчика */ 
					content: "8." counter(list4) ". "; /* Выводим значение типа 4.1, 4.2,... */ 
				}
			</style>
			<ol class="glava8">
				<li><a href="#part8.1">Фильтры.</a></li>
				<li><a href="#part8.2">Действия.</a></li>
				<li><a href="#part8.3">Правила.</a></li>
			</ol>
			<hr>
			<p><a name="part8.1"></a></p>
			<h3>8.1. Фильтры.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part8">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part8.2"></a></p>
			<h3>8.2. Действия.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part8">Перейти к главе</a>.</p>
			<hr>
			<p><a name="part8.3"></a></p>
			<h3>8.3. Правила.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>. <a href="#part8">Перейти к главе</a>.</p>
			<hr>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
