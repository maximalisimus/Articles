<html>
<head>
	<meta charset="utf-8">
	<title>Базовые настройки серверов Linux</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/Configuratons_Linux_Servers_image/server.ico">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">	
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Базовые настройки серверов Linux</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/Configuratons_Linux_Servers_image/server.jpg" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<center>
				<h1>Хорош тот сервер, который настроен тщательно и с умом.</h1>
			</center>
			<h2>Предисловие</h2>
			<p>В данной статье рассматриваются базовые настройки серверов почти на любом дистрибутиве <b>Linux</b>. Статья пригодится для тех не всё помнит, может что-нибудь забыть, впервые настраивает или имеет пробелы в знаниях. <u>Главное постоянно развиваться.</u></p>
			<p>Все настройки проверены годами на многих дистрибутивах <b>Linux</b>: <i>Debian, Ubuntu, Xubuntu, Mint, ArchLinux, ArcoLinux, Manjaro, Fedora, RedOS, Astra, Alt, OpenSuse, SlackWare, Calculate</i>.</p>
			<p>Для всех примеров за основу возьмем <b>Debian 11</b> на <b>VPS-сервере</b> в сравнении на домашней виртуальной машине в <b>Virtual Box</b>. Однако, все настройки легко подойдут хоть на <b>Archlinux</b>, хоть на свеженький <b>Ubuntu</b>. Главное заменить один менеджер пакета на другой и подправить наименования некоторых утилит или библиотек, требующихся для установки. В некоторых дистрибутивах могут также измениться расположение файлов настроек в системе, но сами параметры остануться абсолютно одинаковыми.</p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Настройка репозиториев в Debian и Ubuntu подобных дистрибутивах.</a></li>
				<li><a href="#part2">Права доступа.</a></li>
				<li><a href="#part3">Swap, swappiness.</a></li>
				<li><a href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part3" target="_blank">Настройка безопасности SSH соединений.</a></li>
				<li><a href="#part4">Форвардинг, sysctl.</a></li>
				<li><a href="#part5">Настройки сетевых соединений.</a></li>
				<li><a href="#part6">Конфликт портов или автозапуск из ниоткуда apache2.</a></li>
				<li><a href="#part7">Apparmor.</a></li>
				<li><a href="#part8">Настройка времени и локали.</a></li>
				<ol>
					<li><a href="#part8.1">Синхронизация timesyncd.</a></li>
					<li><a href="#part8.2">Синхронизация времени с помощью ntp и ntpdate.</a></li>
					<li><a href="#part8.3">Настройка локали и языка.</a></li>
				</ol>
				<li><a href="#part9">Настройка DNS.</a></li>
				<ol>
					<li><a href="#part9.1">Порядок источников имен NSSWITCH.</a></li>
					<li><a href="#part9.2">DNS-Кеш.</a></li>
					<li><a href="#part9.3">DNS-резолвер.</a></li>
					<li><a href="#part9.4">DNS-сервер.</a></li>
				</ol>
				<li><a href="#part10">Docker, docker-compose.</a></li>
				<li><a href="#part11">Настройка wireguard.</a></li>
				<li><a target="_blank" href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part4">Настройка фаервола.</a></li>
				<li><a target="_blank" href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part5.0">Настройка Fail2ban</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Настройка репозиториев в Debian и Ubuntu подобных дистрибутивах.</h2>
			<p>Обычно при запуске любого Linux сервера на Debian или Ubuntu подобных дистрибутивах Linux у вас всегда будут одинаковые настройки репозиториев.</p>
			<p>Обычно одна единственная настройка всегда мешает обновлению сервера и в принципе любой установке. А именно - это наличия ссылки на CD или DVD диск репозитория, с которого производилась установка системы, в настройках репозиториев.</p>
			<p>Чтобы её исправить нужно выполнить всего одну команду - открыть файл с настройкой и закоментировать строку с этой ссылкой, сохранить и закрыть файл.</p>
			<p class="codes">
				<span style="color:blue;"># Регистрируемся как суперпользователь, если вы входили под каким-нибудь обычным пользователем, например, когда система установлена вами самими, а не хостингом, или на вашем оборудовании</span></br>
				<b>$ su</b></br>
				<b>$ nano /etc/apt/sources.list</b></br></br>
				# deb cdrom ...</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p>Всё можно обновлять список пакетов.</p>
			<p class="codes">
				$ apt update</br>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h2>2. Права доступа.</h2>
			<p>Обычно при запуске любого VPS или VDS сервера на любом дистрибутиве Linux у вас всегда будет только один суперпользователь. Если вы самостоятельно устанавливали систему, то наверняка указывали какого-нибудь пользователя.</p>
			<p>В случае же когда у вас только один суперпользователь лучше сразу разграничить права доступа с помощью создания пользователей. Позже это разграничение поможет в настройке безопасности SSH-соединений. И ваш сервер станет чуточку безопаснее.</p>
			<p>Для начала необходимо установить утилиту sudo (она предназначена для того, чтобы делегировать привелегированные ресурсы пользователем с ведением протокола работы), создать группу привелегированного доступа (хотя это и не обязательно), дать группе соответствующие права доступа, создать пользователя и добавить пользователя в эту группу.</p>
			<p class="codes">
				<span style="color:blue;"># Устанавливаем sudo</span></br>
				$ apt install sudo -y</br></br>
				<span style="color:blue;"># Добавляем группу. Там уже в принципе есть нужная группа (&laquo;sudo&raquo;), но мне, например, понятнее со своей группой, а не системной.</span></br>
				$ /usr/sbin/groupadd wheel</br></br>
				<span style="color:blue;"># Создаем пользователя и сразу добавляем в созданную группу</span></br>
				$ /usr/sbin/useradd myuser -m -g users -G wheel,users -s /bin/bash</br></br>
				<span style="color:blue;"># Меняем пароль пользователя</span></br>
				$ passwd myuser</br></br>
				<span style="color:blue;"># Добавляем группу wheel в sudo файл в самом конце</span></br>
				$ nano /etc/sudoers</br></br>
				%wheel ALL=(ALL:ALL) ALL</br></br>
				CTRL + o</br>
				CTRL + x
			</p>
			<p>Если вам необходимо можно добавить пользователю необходимые дополнительные полномочия. Вот список групп с описаниями полномочий. Обратите внимание, что в разных дистрибутивых могут быть разные наборы групп с соответствующими полномочиями. Т.е. каких-то групп может и не быть. Поэтому обязательно проверьте есть ли вообще в системе такая группа.</p>
			<p>Проверим существование группы, например администрирования - <b>adm</b>.</p>
			<p class="codes">
				$ sudo cat /etc/group | grep -Ei "adm"
			</p>
			<p>Переходим к спискам групп и полномочий.</p>
			<table>
				<caption>Пользователь.</caption>
				<tr>
					<td><b>adm</b></td>
					<td>Администрирование</td>
				</tr>
				<tr>
					<td><b>ftp</b></td>
					<td>Доступ к файлам FTP</td>
				</tr>
				<tr>
					<td><b>games</b></td>
					<td>Доступ к игровым программам</td>
				</tr>
				<tr>
					<td><b>http</b></td>
					<td>Доступ к файлам HTTP</td>
				</tr>
				<tr>
					<td><b>log</b></td>
					<td>Доступ к лог-файлам, syslog-ng</td>
				</tr>
				<tr>
					<td><b>rfkill</b></td>
					<td>Управление питанием беспроводных устройств</td>
				</tr>
				<tr>
					<td><b>sys</b></td>
					<td>Администрирование принтеров CUPS</td>
				</tr>
				<tr>
					<td><b>systemd-journal</b></td>
					<td>Доступ к журналам systemd</td>
				</tr>
				<tr>
					<td><b>users</b></td>
					<td>Стандартная группа пользователей</td>
				</tr>
				<tr>
					<td><b>uucp</b></td>
					<td>Доступ к устройствам RS-232</td>
				</tr>
			</table>
			<br>
			<table>
				<caption>Система.</caption>
				<tr>
					<td><b>dbus</b></td>
					<td>Используется внутри dbus.</td>
				</tr>
				<tr>
					<td><b>kmem</b></td>
					<td>Доступ к виртуальной памяти ядра</td>
				</tr>
				<tr>
					<td><b>locate</b></td>
					<td>Доступ к быстрому поиску файлов по имени</td>
				</tr>
				<tr>
					<td><b>lp</b></td>
					<td>Доступ к устройствам параллельного порта</td>
				</tr>
				<tr>
					<td><b>mail</b></td>
					<td>Доступ к почтовым клиентам</td>
				</tr>
				<tr>
					<td><b>nobody</b></td>
					<td>Непривилигированная группа</td>
				</tr>
				<tr>
					<td><b>proc</b></td>
					<td>Доступ к информации о процессах</td>
				</tr>
				<tr>
					<td><b>smmsp</b></td>
					<td>sendmail группа</td>
				</tr>
				<tr>
					<td><b>tty</b></td>
					<td>Доступ к последовательным и параллельным портам</td>
				</tr>
				<tr>
					<td><b>utmp</b></td>
					<td>Полные представления о пользователях системы</td>
				</tr>
			</table>
			<br>
			<table>
				<caption>Группы, существовавшие до перехода на systemd.</caption>
				<tr>
					<td><b>audio</b></td>
					<td>Прямой доступ к звуковому оборудованию</td>
				</tr>
				<tr>
					<td><b>disk</b></td>
					<td>Доступ к блочным устройствам</td>
				</tr>
				<tr>
					<td><b>floppy</b></td>
					<td>Доступ к флоппи-дискам</td>
				</tr>
				<tr>
					<td><b>input</b></td>
					<td>Доступ к устройствам ввода</td>
				</tr>
				<tr>
					<td><b>kvm</b></td>
					<td>Доступ к виртуальным машинам KVM</td>
				</tr>
				<tr>
					<td><b>optical</b></td>
					<td>Доступ к CD, DVD, ISO</td>
				</tr>
				<tr>
					<td><b>scanner</b></td>
					<td>Доступ к сканерам</td>
				</tr>
				<tr>
					<td><b>storage</b></td>
					<td>Доступ к съемным дискам</td>
				</tr>
				<tr>
					<td><b>video</b></td>
					<td>Доступ к устройствам захвата видео</td>
				</tr>
			</table>
			<br>
			<p>Добавляем пользователя во все необходимые группы одной командой.</p>
			<p class="codes">
				$ sudo /usr/sbin/usermod -aG audio,video myuser
			</p>
			<p>Если не получается, можно добавить в каждую группу по очерди, т.е. по одной.</p>
			<p class="codes">
				$ gpasswd -a myuser audio<br>
				$ gpasswd -a myuser video
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h2>3. Swap, swappiness.</h2>
			<p>SWAP – один из механизмов виртуальной памяти, при котором отдельные фрагменты памяти перемещаются из ОЗУ в так называемые области подкачки (swap area или swap space), расположенные на вторичном хранилище данных (отдельный дисковый раздел или просто файл в файловой системе), освобождая ОЗУ для загрузки других активных фрагментов памяти.</p>
			<p>У файла подкачки существуют параметры, которые сообщают ОС, как часто его нужно использовать. Это явление называется «свопингом» и может иметь значение в пределах 0 - 100. Если это значение ближе к 100, ядро будет перемещать в раздел подкачки больше информации чтобы освободить память. При значениях ближе к нулю, система будет использовать подкачку только при крайней необходимости.</p>
			<p>К примеру, в версии Ubuntu Linux для рабочего стола устанавливается параметр 60, а в серверных редакциях операционной системы - 1.</p>
			<p>Существует много споров - нужен ли swap вообще. Когда у вас большое количество оперативной памяти - то такой раздел может быть и не нужным, а если есть то скорее всего никогда не будет использоваться.</p>
			<p><span style="color:red;"><b>НО! Обратите внимание!</b></span></p>
			<p>Если swappinses у вас стоит по умолчанию, то скорее всего при заполнении оперативной памяти всего лишь на 40% - система потребует swap раздел, если система не находит такой раздел - то создаёт его автоматически. Естественно если у вас твердотельный накопитель - скорость не сильно упадёт. Но вот если жесткий диск - даже в Linux могут ощущаться тормоза. Да, даже в Linux. Я такое несколько раз видел.</p>
			<p><b>Самое интересное в том, что на любых VPS или VDS серверах swap раздела в принципе не существует, т.е. его никогда не создают, а swappines по умолчанию установлен на 60.</b></p>
			<p>Давайте исправлять этот момент. Посмотрим сколько у нас оперативной памяти, есть ли вообще swap, если нет, то создадим.</p>
			<p>В VPS и VDS серверах лучше хотя бы создать файл подкачки в корне системного раздела, т.к. менять структуру диска во избежании проблем с последним не рекомендуется. На своих серверах заранее продумывайте стркутукру и создавайте такой раздел хотя бы в 2 ГБ. О размерах такого раздела уже говорилось ранее в одной из предыдущих статей.</p>
			<p class="codes">
				<span style="color:blue;"># Смотрим на всю оперативную память</span></br>
				$ free -h</br>
				<span style="color:blue;"># Проверяем swap</span></br>
				$ sudo swapon --show</br></br>
				<span style="color:blue;"># Создаем файл подкачки, форматируем и подключаем</span></br>
				$ sudo fallocate -l 2G /swapfile</br>
				$ sudo chmod 600 /swapfile</br>
				$ sudo mkswap /swapfile</br>
				$ sudo swapon /swapfile</br></br>
				<span style="color:blue;"># Проверяем</span></br>
				$ sudo swapon --show				
			</p>
			<p>Создали и подключили. Однако после перезагрузки системы он не подключиться автоматически. Сделаем это.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fstab</b></br></br>
				/swapfile none swap defaults,discard 0 0</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p>Теперь займемся настройкой swappiness.</p>
			<p>Посмотрим сколько у нас установленно на данный момент.</p>
			<p class="codes">
				$ sudo cat /proc/sys/vm/swappiness
			</p>
			<p>Установим временное значение до перезагрузки системы.</p>
			<p class="codes">
				$ sudo sysctl vm.swappiness=10
			</p>
			<p>Установим значение постоянным.</p>
			<p class="codes">
				$ sudo nano /etc/sysctl.d/00-sysctl.conf</br>
				vm.swappiness=10</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>5. Форвардинг, sysctl.</h2>
			<p>sysctl — в BSD и Linux — программа, предназначенная для управления отдельными параметрами ядра, безопасности, сетевой подсистемы. Позволяет определять и задавать такие параметры как размер сегмента разделяемой памяти, ограничение на число запущенных процессов, а также включать функции наподобие маршрутизации.</p>
			<p>Имеет конфигурационный файл /etc/sysctl.conf, в котором переопределяются необходимые параметры.</p>
			<p>Для начала сделаем его бэкап следующей командой:</p>
			<p class="codes">
				$ sudo cp /etc/sysctl.conf /etc/sysctl.conf.back
			</p>
			<p>Значение sysctl загружаются во время загрузки системы из файла /etc/sysctl.conf. В этом файле могут быть пустые строчки, комментарии (строки, начинающиеся на символ «#» или точку с запятой), а также строки в формате «переменная=значение». Если вы хотите применить его в любой момент времени, вы можете сделать это с помощью команды &laquo;sysctl -p&raquo;.</p>
			<p>О каждом из параметров вы можете почитать вот в этой <a target="_blank" href="https://rtfm.wiki/linux/sysctl_settings">&laquo;статье&raquo;</a>. Я же расскажу о наиболее часто применяемых.</p>
			<ul>
				<li>включить пересылку IP-пакетов (ipv4, ipv6).</li>
				<ul>
					<li><b>net.ipv4.ip_forward = 1</b></li>
					<li><b>net.ipv4.conf.all.forwarding = 1</b></li>
					<li><b>net.ipv6.conf.all.forwarding = 1</b></li>
					<li><b>net.ipv6.conf.default.forwarding = 1</b></li>
				</ul>
				<li>Позволяет осуществлять фильтрацию пакетов по адресу назначения (проверка адреса получателя).</li>
				<ul>
					<li><b>net.ipv4.conf.all.rp_filter = 1</b></li>
				</ul>
				<li>Включает/выключает проксирование arp-запросов для заданного интерфейса. ARP-прокси позволяет маршрутизатору отвечать на ARP запросы в одну сеть, в то время как запрашиваемый хост находится в другой сети. С помощью этого средства происходит обман отправителя, который отправил ARP запрос, после чего он думает, что маршрутизатор является хостом назначения, тогда как в действительности хост назначения находится на другой стороне маршрутизатора. Маршрутизатор выступает в роли уполномоченного агента хоста назначения, перекладывая пакеты от другого хоста.</li>
				<ul>
					<li><b>net.ipv4.conf.default.proxy_arp = 1</b></li>
					<li><b>net.ipv4.conf.all.proxy_arp = 1</b></li>
				</ul>
				<li>Включает/выключает выдачу ICMP Redirect другим хостам. Эта опция обязательно должна быть включена, если хост выступает в роли маршрутизатора любого рода. Как правило ICMP-сообщения о переадресации отправляются в том случае, когда необходимо сообщить хосту о том, что он должен вступить в контакт с другим сервером. Переменная может иметь два значения 0 (выключено) и 1 (включено). Значение по-умолчанию 1 (включено). Если компьютер не выступает в роли маршрутизатора, то эту переменную можно отключить.</li>
				<ul>
					<li><b>net.ipv4.conf.default.send_redirects = 1</b></li>
					<li><b>net.ipv4.conf.all.send_redirects = 0</b></li>
				</ul>
				<li>Отключения поддержки IPv6.</li>
				<ul>
					<li><b>net.ipv6.conf.all.disable_ipv6 = 1</b></li>
					<li><b>net.ipv6.conf.default.disable_ipv6 = 1</b></li>
					<li><b>net.ipv6.conf.lo.disable_ipv6 = 1</b></li>
				</ul>
			</ul>
			<p>Вот все указанные настройки. Благо у меня на VPS сервере не используется IPV6, поэтому я его отключу. При необходимости, смогу зайти через ssh, закоментировать соответствующие строки и перезагрузить правила соответствующей командой.</p>
			<p class="codes">
				<b>$ sudo nano /etc/sysctl.conf</b></br>
				net.ipv4.ip_forward=1</br>
				net.ipv4.conf.all.forwarding=1</br>
				net.ipv6.conf.all.forwarding=1</br>
				net.ipv6.conf.default.forwarding = 1</br>
				net.ipv4.conf.all.rp_filter = 1</br>
				net.ipv4.conf.default.proxy_arp = 1</br>
				net.ipv4.conf.all.proxy_arp=1</br>
				net.ipv4.conf.default.send_redirects = 1</br>
				net.ipv4.conf.all.send_redirects = 0</br></br>
				net.ipv6.conf.all.disable_ipv6 = 1</br>
				net.ipv6.conf.default.disable_ipv6 = 1</br>
				net.ipv6.conf.lo.disable_ipv6 = 1</br></br>
				
				<span style="color:blue;"># Сохраняем и выходим</span></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b></br>
				<span style="color:blue;"># Принимаем правила без перезагрузки ОС.</span></br>
				<b>$ sudo sysctl -p</b></br>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part5"></a></p>
			<h2>6. Настройки сетевых соединений.</h2>
			<p>Обычно в VPS или VDS серверах настраивать сетевые интерфейсы не просто не требуется, а в принципе не рекомендуется. В домашнем сервере - будь то реальный ПК или виртуальная машина, такая настройка чаще всего просто необходима, чтобы не в роутере настраивать IP адреса ваших домашних ПК, а только на сервере. В организациях же чаще всего такая настройка тоже необходима, т.к. сам сервер и раздает всем ПК в сети IP адреса из заданного диапазона.</p>
			<p>Поэтому рассмотрим только базовую настройку того, что вам точно пригодится.</p>
			<p>Если какие-то команды не выполняются просто допишите к ним следующую строку: <b>&laquo;/usr/sbin/&raquo;</b>. Дело в том, что почти во всех Debian или Ubuntu подобных дистрибутивах ссылки на многие утилиты перенесли именно в этот каталог, но не стали добавлять эти же ссылки в базовый путь по умолчанию. И также возможно, что данные утилиты просто не установлены в систему. Это вполне нормальное явление. В качестве примера - всеми любимая утилита ifconfig.</p>
			<p>Доустановим всего, что нам не хватает.</p>
			<p class="codes">
				$ sudo apt install curl gnupg wget bash-completion net-tools git -y
			</p>
			<p>Теперь все необходимые утилиты точно есть в <b>&laquo;/usr/sbin/&raquo;</b>.</p>
			<p>Далее мне понадобится ip-калькулятр. Можно было бы посчитать подсети вручную, но лично мне лень и я воспользуюсь специальным калькулятором.</p>
			<p class="codes">
				$ sudo apt install ipcalc -y</br>
				<span style="color:blue;"># Пользоваться примерно так</span></br>
				$ ipcalc 192.168.0.100/24
			</p>
			<p>Теперь посмотрю какой мне на моем VPS выдал IP адрес провайдер, а также маску, вещательный адрес и шлюз по умолчанию. Просто, чтобы не потерять доступ их же и буду вводить в ручных настройках сети. На домашнем сервере или в организации, скорее всего, такой адрес будет выбран системным администратором самостоятельно, а не выдан неким маршрутизатором, чтобы не лазить в настройки маршрутизатора или роутера. Такое необходимо когда доступа к самому роутеру или маршрутизатору нет, а вы при этом всё равно хотите установить фиксированный ip-адрес.</p>
			<p>Для примера, пусть ответ будет как на домашней виртуальной машине.</p>
			<div class="codeses">
				<pre>
<b>$ /usr/sbin/ifconfig</b>
...
enp0s3: ...
	inet 192.168.0.110 netmask 255.255.255.0 broadcast 192.168.0.255
...

<b>$ sudo route</b>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.0.1     0.0.0.0         UG    0      0        0 enp0s3
...</pre>
			</div>
			<p>Записываем.</p>
			<ul>
				<li><b>192.168.0.110</b> - ipv4.</li>
				<li><b>255.255.255.0</b> - маска.</li>
				<li><b>192.168.0.255</b> - вещательный адрес.</li>
				<li><b>192.168.0.1</b> - шлюз по умолчанию.</li>
			</ul>
			<p>Проверяем через ip-калькулятор - на всякий случай. Вдруг что-нибудь где-нибудь введёте неправильно, ошибётесь на одну единственную циферку - из-за чего можете даже потерять доступ. Такие настройки лучше лишний раз перепроверить, т.е. перепроверить самого себя и убедиться что всё сделано правильно и без ошибок.</p>
			<div class="codeses">
				<pre>
<b>$ ipcalc 192.168.0.110/24</b>
Address:   <span style="color:blue;">192.168.0.110</span>         <span style="color:Khaki;">11000000.10101000.00000000. 01101110</span>
Netmask:   <span style="color:blue;">255.255.255.0 = 24</span>    <span style="color:red;">11111111.11111111.11111111. 00000000</span>
Wildcard:  <span style="color:blue;">0.0.0.255</span>             <span style="color:Khaki;">00000000.00000000.00000000. 11111111</span>
=>
Network:   <span style="color:blue;">192.168.0.0/24</span>        <span style="color:Violet;">110</span><span style="color:Khaki;">00000.10101000.00000000. 00000000</span>
HostMin:   <span style="color:blue;">192.168.0.1</span>           <span style="color:Khaki;">11000000.10101000.00000000. 00000001</span>
HostMax:   <span style="color:blue;">192.168.0.254</span>         <span style="color:Khaki;">11000000.10101000.00000000. 11111110</span>
Broadcast: <span style="color:blue;">192.168.0.255</span>         <span style="color:Khaki;">11000000.10101000.00000000. 11111111</span>
Hosts/Net: <span style="color:blue;">254</span>                   <span style="color:Violet;">Class C</span><span style="color:white;">, Private Internet</span></pre>
			</div>
			<ul>
				<li><b>HostMin</b> - шлюз. Верно.</li>
				<li><b>Broadcast</b> - вещательный адрес. Тоже верно.</li>
				<li><b>Netmask</b> - маска сети. Верно.</li>
				<li><b>Address</b> - ip адрес присвоенный провайдером или маршрутизатором.</li>
			</ul>
			<p>В домашней сети я могу выбрать любой другой адрес в той же подсети. В организации надо смотреть на наличие свободных, т.е. не занятых, адресов в имеющейся подсети. <span style="color:red;"><b>В VPS и VDS серверах менять их ни в коем случае нельзя!</b></span> Именно поэтому и нужно было узнать все эти параметры. Теперь можно вручную указать их в настройках сетевой конфигурации.</p>
			<p>Вот теперь можно переходить к настройкам интерфесов.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/network/interfaces</b>
...
allow-hotplug enp0s3
auto enp0s3
# iface enp0s3 inet dhcp
iface eth1 inet static
	address 192.168.0.110
	netmask 255.255.255.0
	gateway 192.168.0.1
	broadcast 192.168.0.255
	# dns-nameservers 192.168.0.1 8.8.8.8
# pre-up ifconfig enp0s3 hw ether xx:xx:xx:xx:xx:xx
# pre-up ip link set enp0s3 address xx:xx:xx:xx:xx:xx
...
<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$ sudo systemctl restart networking</b>
<span style="color:blue;"># Но лучше бы было просто перезагрузить сервер и снова войти по ssh</span></pre>
			</div>
			<p>Параметр &laquo;dns-nameservers&raquo; закоментирован и отвечает за настройку DNS-серверов для данного сетевого адаптера. Однако, здесь dns-сервера никогда не указывают, потому что это не совсем правильно, хотя и вполне возможно. Об этом будет подробнее рассказано <a href="#part9.3">в другой главе</a>.</p>
			<p>Настройка &laquo;pre-up&raquo; отвечает за запуск дополнительных параметров в зависимости от состояния сетевого адаптера. Например, смена мак-адреса перед запуском интерфейса. В данном случае указны 2 способа смены - утилитой из &laquo;net-tools&raquo; и встроенной. Их можно указывать несколько штук построчно, и даже одинаковые состояния в каждой из строк. Также сюда же можно вносить дополнительные iptables правила, которые должны быть вставлены при запуске того или иного интерфейса. Например, перед запуском интерфейса добавлять правила, а после отключения удалять. Или же, например записать все iptables правила добавления в один скрипт, правила удаления в другой скрипт и укаждый из этих скриптов указать в соответствующих строках перед запуском интерфейса и после отключения интерфейса.</p>
			<p>Вот список состояний, которые могут вам пригодиться.</p>
			<ul>
				<li><b>pre-up</b> - Выполнить команду перед запуском интерфейса.</li>
				<li><b>post-up</b> - Выполнить команду после запуска интерфейса.</li>
				<li><b>pre-down</b> - Команда перед отключением.</li>
				<li><b>post-down</b> - Команда после отключения.</li>
			</ul>
			<p>Если вы что-нибудь меняете вручную - вот список параметров, которые можно использовать в ручных, а не скриптовых, настройках.</p>
			<ul>
				<li><b>iface</b> -  Указывает имя интерфейса.</li>
				<li><b>up</b> - Выполнить команду при запуске интерфейса.</li>
				<li><b>auto</b> - автоматический запуск интерфейса.</li>
				<li><b>inet</b> - Указывает description такие как static, dhcp или manual.</li>
				<li><b>address</b> - Устанавливает ip адрес для статического соединения.</li>
				<li><b>netmask</b> - Установка маски сети.</li>
				<li><b>broadcast</b> - Широковещательный адрес.</li>
				<li><b>metric</b> - Приоритет для шлюза по умолчанию.</li>
				<li><b>gateway</b> - Шлюз по умолчанию.</li>
				<li><b>hwaddress</b> - Установить MAC адрес.</li>
				<li><b>mtu</b> - Размер одного пакета.</li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part6"></a></p>
			<h2>7. Конфликт портов или автозапуск из ниоткуда apache2.</h2>
			<p>Иногда, не только в <b>VPS</b> или <b>VDS</b>, но и при установке на домашний ПК или в организации при установке совершенно нового образа <b>Debian</b> или <b>Ubuntu</b> может встретиться такая ситуация - когда вы попросту не можете запустить какой-либо сервис на выбранном порту.</p>
			<p>Я встретился с ситуацией, когда на совершенно новом дистрибутиве <b>Debian 11</b> не cмог запустить только что установленный <b>nginx</b> на <b>80 порту</b>.</p>
			<p>Что делать в таком случае?</p>
			<p>Во первых отследить - сервис, который перекрывает вам доступ, а точнее порт сервиса.</p>
			<p class="codes">
				$ sudo netstat -tlnp
			</p>
			<p>Команда покажет все запущенные процессы и прослушиваемые порты. По портам сможете найти интересующий вас сервис. В последнем столбце как раз и увидете наименование сервиса, который портит вам жизнь.</p>
			<p><u>Теперь необходимо именно выключить найденый сервис</u>, а не просто убить процесс. В моём случае это был сервис <b>apache2</b>.</p>
			<p class="codes">
				$ sudo update-rc.d apache2 disable
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part7"></a></p>
			<h2>8. Apparmor.</h2>
			<p><b>AppArmor</b> - программный инструмент упреждающей защиты, основанный на политиках безопасности, которые определяют, к каким системным ресурсам и с какими привилегиями может получить доступ то или иное приложение. В AppArmor включён набор стандартных профилей, а также инструменты статического анализа и инструменты, основанные на обучении, позволяющие ускорить и упростить построение новых профилей. <br>Т.е. <b>AppArmor</b> - это реализация Модуля безопасности линукс по управлению доступом на основе имен. AppArmor ограничивает отдельные программы набором перечисленных файлов и возможностями в соответствии с правилами Posix 1003.1e. <br><b>AppArmor</b> устанавливается и загружается по умолчанию. Он использует профили приложений для определения какие файлы и права доступа требуются приложению.</p>
			<p>AppArmor является важным элементом безопасности, который по умолчанию включен в Ubuntu начиная с версии Ubuntu 7.10. Тем не менее, AppArmor работает в фоновом режиме, поэтому Вы можете не знать, что это такое и что AppArmor делает.</p>
			<p>AppArmor блокирует уязвимые процессы, ограничивая уязвимость в системе безопасности, которая может возникнуть из-за уязвимости этих процессов. AppArmor можно также использовать для того, чтобы заблокировать Mozilla Firefox для повышения безопасности, но по умолчанию это не делается.</p>
			<p>Например, одним из приложений, для которого по умолчанию в Ubuntu задано такое ограничение, является Evince — программа просмотра файлов PDF. Когда Evince работает под вашей пользовательской учетной записью, он может выполнять только вполне определенные действия. Для Evince предоставлены минимальные права доступа, необходимые только для запуска и работы с документами PDF. Если при рендеринге PDF с помощью Evince или при открытии вредоносного PDF, который хочет перехватить управление от Evince, были обнаружены уязвимости, AppArmor сможет ограничить ущерб, который может нанести Evince. В традиционной модели безопасности Linux для Evince будет разрешен доступ ко всему тому, к чему у вас есть доступ. При использовании AppArmor, доступ имеется только к тем вещам, которые требуются программе для просмотра PDF.</p>
			<p>AppArmor, в частности, полезен для ограничения работы программ, в которых могут быть экспойты, например, веб-браузера или серверного программного обеспечения.</p>
			<p>Для просмотра текущего состояния AppArmor, выполните в терминале следующую команду.</p>
			<p class="codes">
				$ sudo apparmor_status
			</p>
			<p>Вы также можете заметить, что AppArmor поставляется с профилем для Firefox - это файл usr.bin.firefox, находящийся в каталоге /etc/apparmor.d. По умолчанию он не включен, так как в нем для Firefox задано слишком много ограничений и из-за этого могут возникать проблемы. В каталоге /etc/apparmor.d/disable имеется ссылка на этот файл, что указывает, что этот профиль отключен.</p>
			<p>Чтобы включить профиль Firefox и с помощью AppArmor ограничить действия, выполняемые Firefox, выполните следующие команды.</p>
			<p class="codes">
				$ sudo rm /etc/apparmor.d/disable/usr.bin.firefox<br>
				$ cat /etc/apparmor.d/usr.bin.firefox | sudo apparmor_parser –a
			</p>
			<p>После выполнения этих команд, снова запустите команду sudo apparmor_status и вы увидите, что теперь загружены профили для Firefox.</p>
			<p>Чтобы отключить профиль Firefox в случае, если из-за него возникают проблемы, выполните следующие команды.</p>
			<p class="codes">
				$ sudo ln -s /etc/apparmor.d/usr.bin.firefox /etc/apparmor.d/disable/<br>
				$ sudo apparmor_parser -R /etc/apparmor.d/usr.bin.firefox
			</p>
			<p>Создать профиль для AppArmor не так сложно как кажется на первый взгляд. Для этого в системе существует несколько утилит. Но для начала давайте рассмотрим синтаксис файла, чтобы было понятно с чем мы имеем дело. Возьмем опять же файл от man.</p>
			<div class="codeses">
				<pre>
include &lt;tunables/global&gt;
/usr/bin/man {
#include &lt;abstractions/base&gt;
#include &lt;abstractions/nameservice&gt;
capability setgid,
capability setuid,
/usr/bin/man r,
/usr/lib/man-db/man Px,
}</pre>
			</div>
			<p>Основу профиля составляют адреса файлов, к которым программа может иметь доступ, а также разрешения для этих файлов. Синтаксис такой.</p>
			<p class="codes">
				<span style="color:blue;">/адрес/файла права</span>
			</p>
			<p>Доступны такие права.</p>
			<ul>
				<li><b>r</b> - разрешить чтение</li>
				<li><b>w</b> - разрешить запись</li>
				<li><b>a</b> - разрешить запись в конец файла</li>
				<li><b>px</b> - разрешить запуск новых процессов если для них есть профиль</li>
				<li><b>Px</b> - разрешить запуск новых процессов, если для них есть профиль и стереть переменные окружения</li>
				<li><b>ix</b> - разрешить запуск нового процесса под профилем текущего</li>
				<li><b>m</b> - разрешить загружать исполняемые файлы в память и запускать</li>
				<li><b>l</b> - разрешить создавать символические ссылки на исполняемые файлы</li>
				<li><b>k</b> - разрешить блокировать файлы</li>
				<li><b>ux</b> - не контролировать новые процессы</li>
				<li><b>Ux</b> - не контролировать новые процессы и очистить переменные окружения.</li>
			</ul>
			<p>Этих полномочий вполне достаточно, для управления правами, но кроме списка файлов и их полномочий, файл профиля содержит еще директивы include и capability.</p>
			<p>include позволяет включать другие файлы с разрешениями, они находятся в папке /etc/apparmor.d/abstractions/. Это такие же части профиля, со списком файлов и правами доступа. Они облегчают создание новых профилей.</p>
			<p>С capability все немного сложнее. Программа может обращаться к ядру с помощью системных вызовов, эти вызовы Apparmor тоже контролирует. Посмотреть все доступные вызовы вы можете командой man capabilities. В нашем случае мы разрешаем процессу задать свой uid и gid, то есть сменить пользователя и группу, от которого он запущен.</p>
			<p>Есть еще папка /etc/apparrmor.d/thunables с переменными, которые могут использоваться в каждом профиле. Но с ними разберемся по ходу. Теперь вы готовы к тому, чтобы создать профиль apparmor. Для примера будем создавать новый профиль для утилиты free. Напомню, что эта утилита показывает доступную оперативную память.</p>
			<p>Сначала выполните такую команду, чтобы инициализировать шаблон профиля.</p>
			<p class="codes">
				$ sudo aa-autodep free
			</p>
			<p>Шаблон профиля создан, можете его посмотреть, теперь нужно выполнить профилирование программы, чтобы посмотреть какие ей файлы нужны и добавить их в профиль.</p>
			<p class="codes">
				$ sudo aa-genprof free
			</p>
			<p>Программа может попросить что запустить в отдельном окне терминала, и выполнить все действия, которые она может делать, затем нажать S.</p>
			<p>Готово, теперь нажимаем F, чтобы завершить работу утилиты.</p>
			<p>Если вы меняли профиль вручную, то его необходимо перезагрузить, чтобы изменения вступили в силу, для этого используйте команду.</p>
			<p class="codes">
				$ sudo aa-parser имя_профиля -a
			</p>
			<p>Перезагрузить все профили можно командой.</p>
			<p class="codes">
				$ sudo service apparmor reload
			</p>
			<br>
			<p>Вообще, docker использует AppArmor для защиты, притом Docker Engine сам генерирует дефолтный профиль для AppArmor при запуске контейнера. Другими словами, вместо.</p>
			<p class="codes">
				$ docker run --rm -it hello-world
			</p>
			<p>запускается.</p>
			<p class="codes">
				$ docker run --rm -it --security-opt apparmor=docker-default hello-world
			</p>
			<p>Вообще, AppArmor не рекомендуется отключать, но бывает, что это необходимо - например из-за конфликта доступа, или потому что он потребляет слишком много оперативной памяти...</p>
			<p>Если вам больше не нужен Apparmor и вы не не хотите, чтобы программа тратила системные ресурсы или хотите просто отключить ее для отладки, это можно сделать следующей командой.</p>
			<p class="codes">
				$ sudo systemctl stop apparmor && sudo systemctl disable apparmor && sudo systemctl mask apparmor
			</p>
			<p>Включить обратно можно аналогичной командой.</p>
			<p class="codes">
				$ sudo systemctl unmask apparmor && sudo systemctl enable apparmor && sudo systemctl start apparmor
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part8"></a></p>
			<h2>9. Настройка времени и локали.</h2>
			<h3>Настройка и синхронизация времени.</h3>
			<p><a name="part8.1"></a></p>
			<h4>9.1. Синхронизация timesyncd.</h4>
			<p>Системное время - важный параметр в работе сервера, так как на него завязаны почти все службы. Сегодня мы рассмотрим с вами, как настроить время в сервере Debian - установить его, указать или сменить часовой пояс, а так же настроить автоматическое обновление.</p>
			<p>Во время установки Debian, сервер автоматически настраивает системное время на основе информации из bios. Инсталлятор предлагает вам выбрать только часовой пояс. При этом, если вы не правильно указали часовой пояс (timezone), его без проблем можно изменить после установки.</p>
			<p>Так же ситуация, когда необходимо изменить время или часовой пояс, может возникнуть, если вы арендуете сервер за границей и вам разворачивают систему из готового образа. В таком случае timezone может быть указана не такая, как вы хотите.</p>
			<p>Зачем, собственно, следить за точным временем на сервере, кроме непосредственно удобства восприятия этого времени? Причин может быть много.</p>
			<ul>
				<li>Для корректного логирования всех событий и последующего расследования инцидентов. Более того, одинаковое время должно быть на всех серверах, которые участвуют в работе.</li>
				<li>В доменной середе Windows для корректной работы протокола аутентификации Kerberos требуется примерно одинаковое время на всех участниках домена. Если ваш сервер Debian является членом домена, важно, чтобы его время не сильно отличалось от времени контроллера домена. Его нужно обязательно синхронизировать с ним.</li>
				<li>На сервере может располагаться какой-то сервис, который взаимодействует с пользователями. Если неправильно настроить часы или timezone, может возникнуть ситуация, когда для некоторых пользователей материалы будут отображаться со временем из будущего.</li>
				<li>Планировщик cron в своей работе использует системные часы. Если вы хотите предсказуемое поведение запланированных задач, время и часовой пояс должны быть настроены правильно.</li>
			</ul>
			<p>Сначала посмотрим на системное время.</p>
			<p class="codes">
				$ date
			</p>
			<p>Сразу видим часовой пояс, дату и время в 12-ти или 24 часовом формате. Если у вас отображается 12-ти часовой формат добавьте +%R к date.</p>
			<p class="codes">
				$ date +%R
			</p>
			<p>Подобные параметры удобно использовать в скриптах.</p>
			<p class="codes">
				$ date +%Y-%m-%d<br>
				$ date +%H-%M-%S<br>
				$ date +%Y-%m-%d_%H-%M-%S<br>
				$ date +%H-%M_%d.%m.%Y
			</p>
			<p>Чтобы увидеть более подробную информацию о состоянии воспользуемся другой командой.</p>
			<p class="codes">
				$ timedatectl status
			</p>
			<p>Для того, чтобы вручную установить дату, используем упомянутую выше команду date, только уже с дополнительными параметрами.</p>
			<p class="codes">
				$ sudo date 04220900
			</p>
			<p>Здесь 04 — месяц, 22 — число, 09 — час, 00 — минут. Таким образом, формат команды получился вот такой - date MMDDhhmm.</p>
			<p>То же самое, только через timedatectl.</p>
			<p class="codes">
				$ sudo timedatectl set-time "2023-04-22 08:45:00"
			</p>
			<p>Если вы получили ошибку - Failed to set time: Automatic time synchronization is enabled, значит у вас уже настроено автоматическое обновление времени. В таком случае timedatectl, в отличие от date, время менять не будет.</p>
			<p>В моем случае timezone установлена как MSK, то есть московский часовой пояс. Если у вас указан другой часовой пояс, а вы, к примеру, хотите установить московский, то делается это просто. Смена часового пояса выполняется через timedatectl.</p>
			<p class="codes">
				<span style="color:blue;"># Перед настройкой или изменением часового пояса, рекомендуется обновить список timezone на сервере.</span></br>
				$ sudo apt update && sudo apt upgrade tzdata</br></br>
				<span style="color:blue;"># Список всех timezоne, доступных для установки на сервере</span></br>
				$ timedatectl list-timezones</br>
				<span style="color:blue;"># Устанавливаем выбранную зону</span></br>
				$ sudo timedatectl set-timezone Europe/Moscow</br>
				<span style="color:blue;"># Включаем автообновление времени</span></br>
				$ sudo timedatectl set-ntp true
			</p>
			<p>В большинстве современных дистрибутивов с systemd служба синхронизации времени уже присутствует в дефолтной установке и реализуется через systemd-timesyncd. Эта служба призвана заменить ntpd. Со слов разработчиков, она легче и быстрее, чем ntpd, плюс интегрирована в systemd, поэтому для автоматической синхронизации времени рекомендуется использовать именно ее.</p>
			<p>Тут важно понимать, что systemd-timesyncd не может работать в качестве сервера времени. Так что, если у вас одиночный сервер, вам вполне подойдет timesyncd. Если же вы хотите использовать свой сервер времени, то надо настраивать ntp.</p>
			<p>Посмотрим на службу timesyncd.</p>
			<p class="codes">
				$ timedatectl timesync-status</br>
				<span style="color:blue;"># Для надежности, можно убедиться, что служба работает, плюс, добавим ее сразу в автозагрузку, если ее там нет.</span></br>
				$ sudo systemctl status systemd-timesyncd<br>
				$ systemctl enable systemd-timesyncd
			</p>
			<p>Список серверов для синхронизации времени в timedatectl настраивается в конфигурационном файле <b>&laquo;/etc/systemd/timesyncd.conf&raquo;</b>. В случае, когда вы используете timesyncd, а не ntp, то сервера будут браться из этого файла.</p>
			<p>Если у вас возникают ошибки при попытке синхронизировать время, возможно настройка этого файла поможет решить проблему.</p>
			<p>В этом файле нас интересуют 2 строки: <b>&laquo;NTP&raquo;</b> и <b>&laquo;FallbackNTP&raquo;</b>. Раскомментируйте их. Первая стркоа отвечает за сервера по умолчанию, вторая за сервера, если не удалось установить соединение с первыми.</p>
			<p>Итак, вот пример конфигурации, например, Российской федерации. Сервера можно посмотреть на официальном сайте: <a target="_blank" href="https://www.ntppool.org/zone/ru"><b>&laquo;ntppool.org&raquo;</b></a>. Самое интересное в том, что сервера можно выбирать как с суб-зонами, так и без суб-зон.</p>
			<p class="codes">
				NTP=0.ru.pool.ntp.org 1.ru.pool.ntp.org 2.ru.pool.ntp.org 3.ru.pool.ntp.org</br>
				FallbackNTP=0.arch.pool.ntp.org 1.pool.ntp.org 2.europe.pool.ntp.org 3.asia.pool.ntp.org
			</p>
			<p>Пробуем синхронизироваться.</p>
			<p class="codes">
				$ sudo timedatectl set-ntp true
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part8.2"></a></p>
			<h4>9.2. Синхронизация времени с помощью ntp и ntpdate.</h4>
			<p>Если вам по какой-то причине не подходит описанная выше синхронизация, либо вам нужен свой сервер времени в сети, то timesyncd можно выключить.</p>
			<p class="codes">
				$ systemctl stop systemd-timesyncd</br>
				$ systemctl disable systemd-timesyncd
			</p>
			<p>Теперь установим ntpdate.</p>
			<p class="codes">
				$ sudo apt install ntpdate</br>
				<span style="color:blue;"># Запускаем для разовой синхронизации.</span></br>
				$ sudo systemctl start ntp</br>
				$ sudo systemctl enable ntp<br>
				$ sudo ntpdate pool.ntp.org<br><br>
				<span style="color:blue;"># Проверяем.</span></br>
				$ sudo systemctl status ntp
			</p>
			<p>Если у вас ntpdate выдает ошибку — the NTP socket is in use, exiting, значит у вас уже установлена и запущена служба ntp, которая заняла udp порт 123, необходимый для работы ntpdate. </p>
			<p>При этом, для проверки статуса службы времени ntp можно использовать утилиту ntpq. Посмотрим статус синхронизации.</p>
			<p class="codes">
				$ ntpq -p
			</p>
			<p><b>Настройка своего NTP сервера синхронизации в данной статье не рассматривается.</b></p>
			<p>Рассмотрим настройку ntp чуть более подробно.</p>
			<p>Если вы хотите изменить сервера своей страны, воспользуйтесь файлом &laquo;/etc/ntp.conf&raquo;. <br>Посмотреть сервера в зависимости от страны можно на официальном сайте <a target="_blank" href="https://www.ntppool.org/zone/ru">ntppool.org</a>. <br>Соответственно вставляйте эти настройки вместо таких же строк. Или просто закоментируйте такие же строки настроек и вставляйте свои чуть ниже.</p>
			<p class="codes">
				server 0.ru.pool.ntp.org iburst<br>
				server 1.ru.pool.ntp.org iburst<br>
				server 2.ru.pool.ntp.org iburst<br>
				server 3.ru.pool.ntp.org iburst
			</p>
			<p>Опция 'iburst' рекомендуется, с ее помощью посылается шквал пакетов, если не удается установить соединение с сервером с первого раза. Напротив, опцию 'burst' не используйте никогда без особого разрешения, так как Вы можете попасть в "черный список".</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part8.3"></a></p>
			<h4>9.3. Настройка локали и языка.</h4>
			<p>Системная локаль устанавливается с помощью переменной <b>LANG</b>.</p>
			<p>Программы, использующие <b>gettext</b> для перевода, учитывают также переменную <b>LANGUAGE</b> в дополнение к стандартным переменным. Это позволяет пользователям установить список локалей, которые будут использоваться в указанном порядке для поиска перевода. Если перевод для более предпочтительной локали (которая идет первее в списке) недоступен, будет произведена попытка получить перевод для следующей, и так далее.</p>
			<p>Переменная <b>LC_TIME</b> отвечает за формат даты и времени.</p>
			<p>Переменная <b>LC_COLLATE</b> отвечает за порядок сортировки и регулярных выражений. Установка значения LC_COLLATE=C, например, приведет к тому, что команда ls будет располагать файлы, имена которых начинаются с точки, первыми, за ними последуют имена, начинающиеся с цифры, затем с заглавной и, наконец, со строчной буквы.</p>
			<p>Переменная <b>LC_ALL</b> переопределяет своим значением все LC_*-переменные, включая LANG, независимо от того, установлены они или нет.</p>
			<p>Переменная <b>LC_ALL</b> — единственная из всех LC_-переменных, которую нельзя установить в <b>&laquo;/etc/locale.conf&raquo;</b>. Она предназначена только в целях проверки при решении проблем.</p>
			<p>Посмотрим определение текущей locale в системе.</p>
			<p class="codes">
				<span style="color:blue;"># Текущая locales</span></br>
				$ locale<br><br>
				<span style="color:blue;"># Список сгенерированных locales в системе</span></br>
				$ locale -a<br><br>
				<span style="color:blue;"># Список сгенерированных locales с подробным описанием</span></br>
				$ locale -a -v
			</p>
			<p>Настраиваем <b>&laquo;/etc/default/locale&raquo;</b></p>
			<p class="codes">
				<b>$ sudo nano /etc/default/locale</b></br>
				LANG=en_US.utf-8
			</p>
			<p>Теперь записываем переменные окружения, чтобы при перезагрузке сервера настройки остались.</p>
			<p class="codes">
				<b>$ sudo nano /etc/environment</b></br>
				LANGUAGE=en_US.UTF-8</br>
				LANG=en_US.utf-8</br>
				LC_ALL=ru_RU.UTF-8</br>
				LC_COLLATE=ru_RU.UTF-8</br>
				LC_TIME=en_US.utf-8
			</p>
			<p>Чтобы не перезагружать систему, выполним ещё несколько команд.</p>
			<p class="codes">
				$ export LANGUAGE=en_US.UTF-8<br>
				$ export LANG=en_US.utf-8<br>
				$ export LC_ALL=ru_RU.UTF-8<br>
				$ export LC_COLLATE=ru_RU.UTF-8<br>
				$ export LC_TIME=en_US.utf-8<br><br>
				$ locale-gen
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9"></a></p>
			<h2>10. Настройка DNS.</h2>
			<h3>Введение.</h3>
			<p>DNS — это система для связывания доменных имен с соответствующими им IP-адресами. DNS-серверы позволяют хранить данные IP-адресов соответствующих доменов, обеспечивать их кэширование и выдачу информации пользователю по запросу в сжатые сроки. Расположенные в разных локациях серверы повышают скорость загрузки страницы и, соответственно, лояльность пользователя к ресурсу.</p>
			<p>На самом деле весь интернет работает именно с системой IP-адресов, а привычные нам названия нужны только для удобства людей: их проще запоминать и вводить. Поэтому всё, что вам нужно, — написать в адресной строке браузера веб-адрес и нажать Enter. Дальше браузер всё сделает сам: отправит нужные запросы, разыщет IP-адрес и откроет страницу.</p>
			<p>Вообще, DNS состоит из двух частей: протокола и сети серверов. Протокол отвечает за способ передачи данных по сети, а серверы представляют собой машины, которые помогают протоколу эффективно работать. Но когда говорят о DNS, чаще всего подразумевают именно протокол.</p>
			<p>По сути DNS-сервера в более простом понимании - это адресная книга. Мы вводим в браузер адрес, но он его не знает. Поэтому отправляет запрос в адресную книгу. По умолчанию в любой системе настроен только DNS провайдера, т.е. только то, что ПК (пусть даже и виртуальный) получил по сети в виде DHCP ответа на свой запрос при подключении к локальной, в данном случае домашней, сети.</p>
			<p>Его, в принципе и не нужно никак настраивать.</p>
			<p>Однако, если у вас есть сервисы, отвечающие, например, за VPN или вам нужен собственный фильтр рекламы AdBlocker (или AdGuard, или Pi-Hole), установленный на ваш сервер - то без настроек DNS уже никак не обойтись.</p>
			<p><b>Приведу пример. Задача.</b></p>
			<p>У вас есть домашний сервер в своей базовой конфигурации, т.е. dns никак не настроен, фаервола нет, т.к. это ваш домашний сервер, то по сути ни фаервол, ни fail2ban не нужны. Только если не проброшены порты через роутер для доступа из интернета. Вы используете этот сервер как файлопомойку. А потом узнали, что оказывается можно на него установить фильтр рекламы и убирать всю рекламу по всей локальной сети вашего дома, просто указав в настройках роутера IP-адрес вашего сервера. Ну, чтобы не указывать в настройках всех ваших гаджетов конкретный DNS-сервер.</p>
			<p>Пусть фильтром рекламы будет всеми любимый AdGuard как наиболее функциональный и удобный. Выбор не принципиален.</p>
			<p>Вы его установили, запустили, открыли веб-панель управления и видите что никакого трафика через него не идет, т.е. он вообще никак не фильтрует рекламу.</p>
			<p><b>Почему так происходит?</b></p>
			<p><b>Теория.</b></p>
			<p>Дело в том, что в сервере настройки согласно заданным условиям установлены по умолчанию. А значит dns-резолвер согласно заданному порядку источников имен nsswitch к серверам будет возвращать либо ip-адрес провайдера, либо ip-адрес вашего роутера, по которому сервер может искать доменные имена. Однако, резолвер не производит поиска имен, он может только возвращать конкретные адреса dns-серверов. Поиск же производит непосредственно dns-сервер. AdGuard - это и есть DNS-сервер. Однако, и в nsswitch задан порядок обращения по умолчанию и dns-резолвер настроен на стандартные настройки возращать dns по умолчанию, т.е. адрес шлюза по умолчанию вместо обращения непосредственно к AdGuard в первую очередь. Поэтому никакой фильтрации рекламы не происходит.</p>
			<p><b>Решение.</b></p>
			<p><span style="color:blue;">В данном примере необходимо хотя бы минимально настроить dns-резолвер, чтобы сервер в любом случае слал все запросы сначала в AdGuard и в случае, если ничего не выходит, то посылает запрос на запасные адреса (FallBack).</span></p>
			<p><b>Другой пример. Задача.</b></p>
			<p>Вы приобрели VPS или VDS сервер, минимально настроили его, установили VPN wireguard для личного использования, установили фаервол (пусть даже) ufw. Настроили по своим вкусам и знаниям. В настройках подключения уже домашнего wireguard - DNS естественно указали VPN адрес сервера, например 10.0.0.1.</p>
			<p>Подключаетесь и у вас не грузится ни одна веб-страница. Вы конечно будете пытаться разбираться. Но в итоге в настройках дома в строке DNS, скорее всего просто укажите Google-DNS и у вас всё заработает.</p>
			<p><b>Почему при попытке прописать в DNS строке в настройках wiregaurd - VPN адрес сервера wireguard не работает? <br>Однако статус говорит, что всё в порядке, соединение есть.</b></p>
			<p><b>Теория.</b></p>
			<p><span style="color:red;">Не хотелось бы вас огорчать, но такой VPN будет не полноценным и не безопасным!</span></p>
			<p><u>Да, весь трафик всё равно будет идти через ваш сервер, однако, DNS запросы будут отправляться через вашего провайдера к указанным вами Google-DNS.</u></p>
			<p>Дело в том, что опять же согласно заданным условиям настройки DNS оставлены по умолчанию. Значит порядок источников имен nsswitch задан по умолчанию. Соответственно dns-резолвер тоже оставлен в настройках по умолчанию. Это значит, что dns-резолвер будет возвращать адреса dns-серверов по умолчанию, т.е. либо адрес провайдера, либо шлюза по умолчанию, если в DHCP провайдера или вашего маршрутизатора не было указано иных параметров.</p>
			<p>Однако, резолвер не производит поиска имен, он может только возвращать конкретные адреса dns-серверов. Поиск же производит непосредственно dns-сервер. В данном примере, соглсно заданным условиям dns-сервера нет и он не настроен. Поэтому сервер не знает куда отправлять запросы из VPN подключения. Он понимает, что dns для него самого находится по этому адресу и по этому, но не знает что запросы из VPN тоже надо отправлять на эти же адреса.</p>
			<p><b>Решение.</b></p>
			<p><span style="color:blue;">В этом примере необходимо установить и настроить dns-сервер и настроить хотя бы dns-резолвер с адресами dns-серверов по умолчанию и запасными адресами.</span></p>
			<p><u>Перейдём ко всем настройкам по порядку.</u></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9.1"></a></p>
			<h3>10.1. Порядок источников имен NSSWITCH.</h3>
			<p><b>NSSWITCH</b> - это файл конфигурации Linux, который определяет, как система должна переключаться между различными поставщиками услуг имен.</p>
			<p>Этот файл можно использовать для настройки того, какие службы следует использовать для поиска имени хоста, поиска паролей и т.д.</p>
			<p>Файл /etc/nsswitch.conf считывается библиотекой Name Service Switch (NSS) при запуске системы. Затем библиотека NSS использует информацию в файле /etc/nsswitch.conf, чтобы определить, какие поставщики услуг имен должны использоваться для каждого типа поиска.</p>
			<p><b>/etc/nsswitch.conf является важной частью операционной системы Linux, и любые изменения в этом файле могут привести к серьезным проблемам. Поэтому важно понимать, как работает /etc/nsswitch.conf, прежде чем вносить какие-либо изменения в этот файл.</b></p>
			<p>В операционных системах Windows и Linux имеется файл hosts, в котором можно установить IP адреса для любых имён — хостов и доменных имён. По умолчанию операционные системы работают так.</p>
			<ul>
				<li>Если запрашиваемое имя присутствует в файле hosts, то его IP берётся из этого файла и запрос к DNS серверу не делается.</li>
				<li>Если в файле hosts имя хоста не найдено, то выполняется запрос к DNS серверу.</li>
			</ul>
			<p>В операционной системе Linux можно поменять приоритет источников для получения IP адреса или вовсе отключить некоторые из них. Для этого используется файл &laquo;/etc/nsswitch.conf&raquo;.</p>
			<p>Строка, которая отвечает за преобразование имён хостов начинается на &laquo;hosts&raquo;.</p>
			<p class="codes">
				hosts: files dns
			</p>
			<p>В старых или более новых системах она может быть такой.</p>
			<p class="codes">
				hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns
			</p>
			<ul>
				<li><b>hosts</b> — это указание на службу, для которой предназначена строка.</li>
				<li><b>files</b> означает файл, относящийся к этой службе. У каждой службы в системе свой файл, в данном случае имеется ввиду &laquo;/etc/hosts&raquo;.</li>
				<li><b>mymachines</b> — судя по названию, означает имя машины.</li>
				<li><b>myhostname</b> - hostname, логично.</li>
				<li><b>resolve</b> — это системная служба резолва.</li>
				<li><b>Строка &laquo;[!UNAVAIL=return]&raquo;</b> - означает, что если предыдущая служба недоступна, то немедленно будет возвращён результат без запроса в следующем источнике.</li>
			</ul>
			<p>Файлы других служб.</p>
			<ul>
				<li>aliases /etc/aliases</li>
				<li>ethers /etc/ethers</li>
				<li>group /etc/group</li>
				<li>hosts /etc/hosts</li>
				<li>initgroups /etc/group</li>
				<li>netgroup /etc/netgroup</li>
				<li>networks /etc/networks</li>
				<li>passwd /etc/passwd</li>
				<li>protocols /etc/protocols</li>
				<li>publickey /etc/publickey</li>
				<li>rpc /etc/rpc</li>
				<li>services /etc/services</li>
				<li>shadow /etc/shadow</li>
			</ul>
			<p>Чтобы отключить файл &laquo;/etc/hosts&raquo; просто уберите слово &laquo;files&raquo;.</p>
			<p>Чтобы сделать приоретет dns выше файла &laquo;/etc/hosts&raquo; поставте это слово перед словом &laquo;files&raquo;.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9.2"></a></p>
			<h3>10.2. DNS-Кеш.</h3>
			<p>Иногда вам может понадобится очистить кеш dns. Например, вам в организации для вашего выделенного белого ip адреса предоставлен доступ к какой-нибудь базе данных. И частенько бывает что у кого-нибудь что-нибудь не грузится, или возникают проблемы с dns-сервером.</p>
			<p>Обычно очистка dns-кеша помогает временно решить проблему. Чтобы постоянно не чистить кеш dns стоит внести в файл &laquo;hosts&raquo; вашей системы сопоставление доменного имени и ip-адреса этой базы данных.</p>
			<p>В Linux-е очистить кеш-dns немного сложнее, чем в Windows-е.</p>
			<p>Сначала необходимо определить кто занимается кешированием. Например, посмотрим на systemd-resolved. Он бывает гораздо удобнее, чем встроеный резолвер в Network Manager.</p>
			<p class="codes">
				$ sudo systemd-resolve —statistics
			</p>
			<p>Команда вернет ошибку, если резолвер не используется.</p>
			<p>Если всё-таки используется для его очистки и перезапуска можно воспользоваться следующими командами.</p>
			<p class="codes">
				$ sudo systemd-resolve —flush-caches<br>
				$ sudo systemctl enable systemd-resolved.servic
			</p>
			<p>Не забудьте про службу кеширования запросов службы имён &laquo;nscd&raquo;.</p>
			<p class="codes">
				$ sudo systemctl restart nscd<br>
				$ nscd -K; nscd
			</p>
			<p>Для её установки и настройки в Debian выполните следующие команды</p>
			<p class="codes">
				$ sudo apt install nscd<br>
				$ sudo systemctl restart nscd<br>
				$ sudo ncsd -g<br>
				$ sudo strings /var/cache/nscd/hosts
			</p>
			<p>В Archlinux она есть только в <a href="https://vk.com/away.php?to=https%3A%2F%2Faur.archlinux.org%2Fpackages%2Funscd&cc_key=">&laquo;AUR&raquo;</a>.</p>
			<p>При использовании &laquo;Network Manager&raquo;, его просто необходимо перезапустить.</p>
			<p class="codes">
				$ sudo service networking restart</br>
				<span style="color:blue;"># или</span></br>
				$ sudo systemctl restart NetworkManager
			</p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9.3"></a></p>
			<h3>10.3. DNS-резолвер.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9.4"></a></p>
			<h3>10.4. DNS-сервер.</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part10"></a></p>
			<h2>11. Docker, docker-compose.</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part11"></a></p>
			<h2>12. Настройка wireguard.</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
