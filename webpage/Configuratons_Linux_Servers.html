<html>
<head>
	<meta charset="utf-8">
	<title>Базовые настройки серверов Linux</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/Configuratons_Linux_Servers_image/server.ico">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">	
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Базовые настройки серверов Linux</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/Configuratons_Linux_Servers_image/server.jpg" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<center>
				<h1>Хорош тот сервер, который настроен тщательно и с умом.</h1>
			</center>
			<h2>Введение.</h2>
			<p>Сервер Linux - это эффективный, мощный вариант операционной системы Linux с открытым исходным кодом (ОС). Серверы Linux созданы для удовлетворения постоянно растущих требований бизнес-приложений, таких как системное и сетевое администрирование, веб-службы и управление базами данных.</p>
			<p>Многие так привыкли к Windows, что даже слышать про Linux не хотят, я имею в виду даже пользовательские варианты Linux с красивыми и удобными рабочими столами. И на вопрос, почему Вы не хотите использовать Linux? Все отвечают: «да он какой-то корявый!», «Программы, которые я использую в Windows не устанавливаются на Linux» и так далее. Но на самом деле всем пользователям, которые так категоричны к Linux, я хочу сказать, что Linux очень дружелюбная операционная система, и стоит всего лишь немного разобраться в ней и Вам все станет понятно.</p>
			<p>Теперь я хочу перечислить некоторые преимущества Linux перед Windows, а также развеять некоторые мифы:</p>
			<ul>
				<li>Linux – абсолютно бесплатная операционная система (<i>за исключением некоторых платных дистрибутивов</i>), в отличие от Windows.</li>
				<li>В Linux практически отсутствуют вирусы. Они есть, но это скорее вопрос правильного разграничения прав доступа (между суперпользователем и пользователями - какие им выдаются права и на какое оборудование или ПО), не доверять чужому коду (сначала всё проверять, т.е. хотя бы мельком пролистывать, чтобы внутри не было зловредного влияния) и тщательности настройки безопасности вашего сервера, чтобы к нему было хотя бы сложно подобраться...</li>
				<li>Все кто говорит, что <i>«Программы, которые я использую в Windows не устанавливаются на Linux»</i>, Вы задумайтесь, а зачем они должны устанавливаться!!! Ведь это совсем другая ОС, там свои программы! Также можно сказать и про Windows, что <i>«программы которые работают в Linux не устанавливаются в Windows»</i>, для Linux существуют много своих программ не уступающим Windows-ким, также многие производители программного обеспечения выпускают свои продукты как для Windows, так и для Linux.</li>
				<li>Linux более производительней, тем более серверный вариант операционной системы. Объясняю, серверные операционные системы Linux без интерфейсные, а большую часть ресурсов (больше половины!!!) как раз занимает интерфейс ОС, т.е. визуальная оболочка (на сегодняшний день получили широкое распространение и версии Windows без графического интерфейса).</li>
				<li>ОС Linux, даже при самое корявой настройке, практически никогда не зависает (я имею в виду саму операционную систему). Например, все встречались с ситуацией, когда в Windows у Вас все замирает, Вы не можете не пошевелить мышкой, даже ctrl+alt+del нажать не можете, и Вам приходиться перезагружаться. Linux устроена таким образом что такая ситуация исключена, разве что в одном случае когда Вы сами вызываете такую ситуацию.</li>
				<li>Касаемо серверной ОС Linux она достаточно проста в конфигурирование, в отличие от аналогов Windows, в которых очень много всяких разных прибомбасов, в которых не так легко разобраться. Сама система Linux и все ее службы настраиваются путем редактирования конфигурационных файлов. Это обычные текстовые файлы, зная их расположение и формат, Вы сможете настроить любой дистрибутив, даже если у Вас под рукой нет никаких инструментов, кроме текстового редактора.</li>
			</ul>
			<p>Я не хочу популяризировать ОС Linux и каким-то образом принижать Windows, но в большинстве случаев лучшего варианта как использование одного из дистрибутивов Linux не найти.</p>
			<h2>Предисловие</h2>
			<p>В данной большой статье рассматриваются базовые настройки серверов на различных дистрибутивах <b>Linux</b>. Статья пригодится для тех не всё помнит, может что-нибудь забыть, впервые настраивает или имеет пробелы в знаниях. <u>Главное постоянно развиваться.</u></p>
			<p>Все настройки проверены годами на многих дистрибутивах <b>Linux</b>.</p>
			<p>Для всех примеров за основу берётся <b>Debian 11</b> на <b>VPS-сервере</b> в сравнении на домашней виртуальной машине в <b>Virtual Box</b>. Однако, все настройки легко подойдут хоть на <b>Archlinux</b>, хоть на свеженький <b>Ubuntu</b>. Главное заменить один менеджер пакета на другой и подправить наименования некоторых утилит или библиотек, требующихся для установки. В некоторых дистрибутивах могут также измениться расположение файлов настроек в системе, но сами параметры остануться абсолютно одинаковыми.</p>
			<p>Не обязательно следовать прямо по всем пунктам подряд, но с каждым пунктом безопасность вашего сервера будет на порядок расти. К тому же вы делаете более предсказуемое поведение любых сервисов, которые планируете установить. Если оставлять большинство параметров по умолчанию - велик шанс, что у вас что-нибудь может сразу и не заработать, т.е. с первой попытки. В этом случае вы, скорее всего, будете очень долго разбираться что и почему не работает так как вы этого хотели.</p>
			<p>Вы можете использовать только те настройки, которые нужны вам здесь и сейчас и пропустить остальные. Безопасность, стабильность и предсказуемое поведение сервисов вашего сервера зависит только от вас. В любом случае - решать только вам.</p>
			<p>Желаю вам удачи!</p>
			<p>Теперь перейдем непосредственно к основам Linux Server.</p>
			<hr>
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Настройка репозиториев в Debian и Ubuntu подобных дистрибутивах.</a></li>
				<li><a href="#part2">Права доступа.</a></li>
				<li><a href="#part3">Swap, swappiness.</a></li>
				<li><a href="#part4">Настройки сетевых соединений.</a></li>
				<li><a href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part3" target="_blank">Настройка безопасности SSH соединений.</a></li>
				<li><a href="#part6">Ловушка SSH.</a></li>
				<li><a href="#part7">Форвардинг, sysctl.</a></li>
				<li><a href="#part8">Конфликт портов или автозапуск из ниоткуда apache2.</a></li>
				<li><a href="#part9">Apparmor.</a></li>
				<li><a href="#part10">Настройка времени и локали.</a></li>
				<ol>
					<li><a href="#part10.1">Синхронизация timesyncd.</a></li>
					<li><a href="#part10.2">Синхронизация времени с помощью ntp и ntpdate.</a></li>
					<li><a href="#part10.3">Настройка локали и языка.</a></li>
				</ol>
				<li><a target="_blank" href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part4">Настройка фаервола.</a></li>
				<li><a target="_blank" href="https://maximalisimus.github.io/Articles/The-security-of-network-connections.html#part5.0">Настройка Fail2ban.</a></li>
				<li><a href="#part13">Настройка DNS.</a></li>
				<ol>
					<li><a href="#part13.1">Порядок источников имен NSSWITCH.</a></li>
					<li><a href="#part13.2">DNS-Кеш.</a></li>
					<li><a href="#part13.3">DNS-резолвер.</a></li>
					<li><a href="#part13.4">DNS-сервер.</a></li>
				</ol>
				<li><a href="#part14">Установка и настройка wireguard.</a></li>
				<li><a href="#part15">Docker, docker-compose.</a></li>
				<li><a href="#part16">Podman, Podman-Compose, Cockpit</a></li>
			</ol>
			<hr>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Настройка репозиториев в Debian и Ubuntu подобных дистрибутивах.</h2>
			<p>Обычно при запуске любого Linux сервера на Debian или Ubuntu подобных дистрибутивах Linux у вас всегда будут одинаковые настройки репозиториев.</p>
			<p>Обычно одна единственная настройка всегда мешает обновлению сервера и в принципе любой установке. А именно - это наличие ссылки на CD или DVD диск репозитория, с которого производилась установка системы, в настройках репозиториев.</p>
			<p>Чтобы её исправить нужно выполнить всего одну команду - открыть файл с настройкой и закоментировать строку с этой ссылкой, сохранить и закрыть файл.</p>
			<p class="codes">
				<span style="color:blue;"># Регистрируемся как суперпользователь, если вы входили под каким-нибудь обычным пользователем, например, когда система установлена вами самими, а не хостингом, или на вашем оборудовании</span></br>
				<b>$ su</b></br>
				<b>$ nano /etc/apt/sources.list</b></br></br>
				# deb cdrom ...</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p>Всё можно обновлять список пакетов.</p>
			<p class="codes">
				$ apt update</br>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part2"></a></p>
			<h2>2. Права доступа.</h2>
			<p>Обычно при запуске любого VPS или VDS сервера на любом дистрибутиве Linux у вас всегда будет только один суперпользователь. Если вы самостоятельно устанавливали систему, то наверняка указывали какого-нибудь пользователя.</p>
			<p>В случае же когда у вас только один суперпользователь лучше сразу разграничить права доступа с помощью создания пользователей. Позже это разграничение поможет в настройке безопасности SSH-соединений. И ваш сервер станет чуточку безопаснее.</p>
			<b>
				<p>
					<span style="color:red;">Но самое главное вот в чём:</span><br>
					Когда у вас есть некий пользователь с ограниченным набором прав доступа к вашему серверу, пусть даже если у вас будет использоваться вход только по паролю на ваш сервер через SSH-соединение, то даже если ваш пароль взламают - злоумышленникам ещё предстоит потрудится взломать пароль суперпользователя, чтобы получить полный контроль над сервером. В случае же, когда у вас только один суперпользователь - злоумышленники значительно легче забирают ваш сервер себе, сразу меняют все пароли и доступы. 
				<br>
					И вы больше ничего и никогда не сможете сделать.<br>
					Кроме, как обратиться в тех-поддержку и полностью всё переустановить, удалив и полностью потеряв всё содержимое вашего сервера, т.к. злоумышленники наверняка уже к тому времени либо скомпрометируют ваши данные, либо заразят зловредным кодом.
				</p>
			</b>
			<p><u>Поэтому обязательно настраивайте себе отдельного пользователя с ограниченным набором прав доступа, руководствуясь этим пунктом.</u></p>
			<p>Для начала необходимо установить утилиту sudo (она предназначена для того, чтобы делегировать привелегированные ресурсы пользователем с ведением протокола работы), создать группу привелегированного доступа (хотя это и не обязательно), дать группе соответствующие права доступа, создать пользователя и добавить пользователя в эту группу.</p>
			<p>Команды выполняются от имени суперпользователя: <b>&laquo;$ su&raquo;</b>.</p>
			<p class="codes">
				<span style="color:blue;"># Устанавливаем sudo</span></br>
				$ apt install sudo -y</br></br>
				<span style="color:blue;"># Добавляем группу. Там уже в принципе есть нужная группа (&laquo;sudo&raquo;), но мне, например, понятнее со своей группой, а не системной.</span></br>
				$ /usr/sbin/groupadd wheel</br></br>
				<span style="color:blue;"># Создаем пользователя и сразу добавляем в созданную группу</span></br>
				$ /usr/sbin/useradd myuser -m -g users -G wheel,users -s /bin/bash</br></br>
				<span style="color:blue;"># Меняем пароль пользователя</span></br>
				$ passwd myuser</br></br>
				<span style="color:blue;"># Добавляем группу wheel в sudo файл в самом конце</span></br>
				$ nano /etc/sudoers</br></br>
				%wheel ALL=(ALL:ALL) ALL</br></br>
				CTRL + o</br>
				CTRL + x
			</p>
			<p>Теперь, перезагрузите ваш сервер.</p>
			<p>Если вам необходимо можно добавить пользователю необходимые дополнительные полномочия. Вот список групп с описаниями полномочий. Обратите внимание, что в разных дистрибутивых могут быть разные наборы групп с соответствующими полномочиями. Т.е. каких-то групп может и не быть. Поэтому обязательно проверьте есть ли вообще в системе такая группа.</p>
			<p>Проверим существование группы, например администрирования - <b>adm</b>. Естественно, проверка выполняется от имени суперпользователя.</p>
			<p class="codes">
				$ cat /etc/group | grep -Ei "adm"
			</p>
			<p>Переходим к спискам групп и полномочий.</p>
			<table>
				<caption>Пользователь.</caption>
				<tr>
					<td><b>adm</b></td>
					<td>Администрирование</td>
				</tr>
				<tr>
					<td><b>ftp</b></td>
					<td>Доступ к файлам FTP</td>
				</tr>
				<tr>
					<td><b>games</b></td>
					<td>Доступ к игровым программам</td>
				</tr>
				<tr>
					<td><b>http</b></td>
					<td>Доступ к файлам HTTP</td>
				</tr>
				<tr>
					<td><b>log</b></td>
					<td>Доступ к лог-файлам, syslog-ng</td>
				</tr>
				<tr>
					<td><b>rfkill</b></td>
					<td>Управление питанием беспроводных устройств</td>
				</tr>
				<tr>
					<td><b>sys</b></td>
					<td>Администрирование принтеров CUPS</td>
				</tr>
				<tr>
					<td><b>systemd-journal</b></td>
					<td>Доступ к журналам systemd</td>
				</tr>
				<tr>
					<td><b>users</b></td>
					<td>Стандартная группа пользователей</td>
				</tr>
				<tr>
					<td><b>uucp</b></td>
					<td>Доступ к устройствам RS-232</td>
				</tr>
			</table>
			<br>
			<table>
				<caption>Система.</caption>
				<tr>
					<td><b>dbus</b></td>
					<td>Используется внутри dbus.</td>
				</tr>
				<tr>
					<td><b>kmem</b></td>
					<td>Доступ к виртуальной памяти ядра</td>
				</tr>
				<tr>
					<td><b>locate</b></td>
					<td>Доступ к быстрому поиску файлов по имени</td>
				</tr>
				<tr>
					<td><b>lp</b></td>
					<td>Доступ к устройствам параллельного порта</td>
				</tr>
				<tr>
					<td><b>mail</b></td>
					<td>Доступ к почтовым клиентам</td>
				</tr>
				<tr>
					<td><b>nobody</b></td>
					<td>Непривилигированная группа</td>
				</tr>
				<tr>
					<td><b>proc</b></td>
					<td>Доступ к информации о процессах</td>
				</tr>
				<tr>
					<td><b>smmsp</b></td>
					<td>sendmail группа</td>
				</tr>
				<tr>
					<td><b>tty</b></td>
					<td>Доступ к последовательным и параллельным портам</td>
				</tr>
				<tr>
					<td><b>utmp</b></td>
					<td>Полные представления о пользователях системы</td>
				</tr>
			</table>
			<br>
			<table>
				<caption>Группы, существовавшие до перехода на systemd.</caption>
				<tr>
					<td><b>audio</b></td>
					<td>Прямой доступ к звуковому оборудованию</td>
				</tr>
				<tr>
					<td><b>disk</b></td>
					<td>Доступ к блочным устройствам</td>
				</tr>
				<tr>
					<td><b>floppy</b></td>
					<td>Доступ к флоппи-дискам</td>
				</tr>
				<tr>
					<td><b>input</b></td>
					<td>Доступ к устройствам ввода</td>
				</tr>
				<tr>
					<td><b>kvm</b></td>
					<td>Доступ к виртуальным машинам KVM</td>
				</tr>
				<tr>
					<td><b>optical</b></td>
					<td>Доступ к CD, DVD, ISO</td>
				</tr>
				<tr>
					<td><b>scanner</b></td>
					<td>Доступ к сканерам</td>
				</tr>
				<tr>
					<td><b>storage</b></td>
					<td>Доступ к съемным дискам</td>
				</tr>
				<tr>
					<td><b>video</b></td>
					<td>Доступ к устройствам захвата видео</td>
				</tr>
			</table>
			<br>
			<p>Добавляем пользователя во все необходимые группы одной командой.</p>
			<p class="codes">
				$ sudo /usr/sbin/usermod -aG audio,video myuser
			</p>
			<p>Если не получается, можно добавить в каждую группу по очерди, т.е. по одной.</p>
			<p class="codes">
				$ gpasswd -a myuser audio<br>
				$ gpasswd -a myuser video
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part3"></a></p>
			<h2>3. Swap, swappiness.</h2>
			<p>SWAP – один из механизмов виртуальной памяти, при котором отдельные фрагменты памяти перемещаются из ОЗУ в так называемые области подкачки (swap area или swap space), расположенные на вторичном хранилище данных (отдельный дисковый раздел или просто файл в файловой системе), освобождая ОЗУ для загрузки других активных фрагментов памяти.</p>
			<p>У файла подкачки существуют параметры, которые сообщают ОС, как часто его нужно использовать. Это явление называется «свопингом» и может иметь значение в пределах 0 - 100. Если это значение ближе к 100, ядро будет перемещать в раздел подкачки больше информации чтобы освободить память. При значениях ближе к нулю, система будет использовать подкачку только при крайней необходимости.</p>
			<p>К примеру, в версии Ubuntu Linux для рабочего стола устанавливается параметр 60, а в серверных редакциях операционной системы - 1.</p>
			<p>Существует много споров - нужен ли swap вообще. Когда у вас большое количество оперативной памяти - то такой раздел может быть и не нужным, а если есть, то скорее всего никогда не будет использоваться.</p>
			<p><span style="color:red;"><b>НО! Обратите внимание!</b></span></p>
			<p>Если swappinses у вас стоит по умолчанию, то скорее всего при заполнении оперативной памяти всего лишь на 40% - система потребует swap раздел, если система не находит такой раздел - то создаёт его автоматически. Естественно, если у вас твердотельный накопитель - скорость не сильно упадёт и вы можете даже ничего толком и не заметить. Однако, если у вас жесткий диск - даже в Linux могут ощущаться тормоза. Да, даже в Linux. Я такое несколько раз видел.</p>
			<p><b>Самое интересное в том, что на любых VPS или VDS серверах swap раздела в принципе не существует, т.е. его никогда не создают, а swappines по умолчанию установлен на 60.</b></p>
			<p>Давайте исправлять этот момент. Посмотрим сколько у нас оперативной памяти, есть ли вообще swap, если нет, то создадим.</p>
			<p>В VPS и VDS серверах лучше хотя бы создать файл подкачки в корне системного раздела, т.к. менять структуру диска во избежании проблем с последним не рекомендуется. На своих серверах заранее продумывайте стркутукру и создавайте такой раздел, хотя бы, в 2 ГБ. О размерах такого раздела уже говорилось ранее в одной из предыдущих статей.</p>
			<p class="codes">
				<span style="color:blue;"># Смотрим на всю оперативную память</span></br>
				$ free -h</br>
				<span style="color:blue;"># Проверяем swap</span></br>
				$ sudo swapon --show</br></br>
				<span style="color:blue;"># Создаем файл подкачки, форматируем и подключаем</span></br>
				$ sudo fallocate -l 2G /swapfile</br>
				$ sudo chmod 600 /swapfile</br>
				$ sudo mkswap /swapfile</br>
				$ sudo swapon /swapfile</br></br>
				<span style="color:blue;"># Проверяем</span></br>
				$ sudo swapon --show				
			</p>
			<p>Создали и подключили. Однако после перезагрузки системы он не подключиться автоматически. Сделаем это.</p>
			<p class="codes">
				<b>$ sudo nano /etc/fstab</b></br></br>
				/swapfile none swap defaults,discard 0 0</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p>Теперь займемся настройкой swappiness.</p>
			<p>Посмотрим сколько у нас установленно на данный момент.</p>
			<p class="codes">
				$ sudo cat /proc/sys/vm/swappiness
			</p>
			<p>Установим временное значение до перезагрузки системы.</p>
			<p class="codes">
				$ sudo sysctl vm.swappiness=10
			</p>
			<p>Установим значение постоянным.</p>
			<p class="codes">
				$ sudo nano /etc/sysctl.d/00-sysctl.conf</br>
				vm.swappiness=10</br></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part4"></a></p>
			<h2>4. Настройки сетевых соединений.</h2>
			<p>Обычно в VPS или VDS серверах настраивать сетевые интерфейсы не просто не требуется, а в принципе не рекомендуется. В домашнем сервере - будь то реальный ПК или виртуальная машина, такая настройка чаще всего просто необходима, чтобы не в роутере настраивать IP адреса ваших домашних ПК, а только на сервере. В организациях же чаще всего такая настройка тоже необходима, т.к. сам сервер и раздает всем ПК в сети IP адреса из заданного диапазона.</p>
			<p>Поэтому рассмотрим только базовую настройку того, что вам точно пригодится.</p>
			<p>Если какие-то команды не выполняются просто допишите к ним следующую строку: <b>&laquo;/usr/sbin/&raquo;</b>. Дело в том, что почти во всех Debian или Ubuntu подобных дистрибутивах ссылки на многие утилиты перенесли именно в этот каталог, но не стали добавлять эти же ссылки в базовый путь по умолчанию. И также возможно, что данные утилиты просто не установлены в систему. Это вполне нормальное явление. В качестве примера - всеми любимая утилита ifconfig.</p>
			<p>Доустановим всего, что нам не хватает.</p>
			<p class="codes">
				$ sudo apt install curl gnupg wget bash-completion net-tools git -y
			</p>
			<p>Теперь все необходимые утилиты точно есть в <b>&laquo;/usr/sbin/&raquo;</b>.</p>
			<p>Далее мне понадобится ip-калькулятр. Можно было бы посчитать подсети вручную, но лично мне лень и я воспользуюсь специальным калькулятором.</p>
			<p class="codes">
				$ sudo apt install ipcalc -y</br>
				<span style="color:blue;"># Пользоваться примерно так</span></br>
				$ ipcalc 192.168.0.100/24
			</p>
			<p>Теперь посмотрю какой мне на моем VPS выдал IP адрес провайдер, а также маску, вещательный адрес и шлюз по умолчанию. Просто, чтобы не потерять доступ их же и буду вводить в ручных настройках сети. На домашнем сервере или в организации, скорее всего, такой адрес будет выбран системным администратором самостоятельно, а не выдан неким маршрутизатором, чтобы не лазить в настройки маршрутизатора или роутера. Такое необходимо когда доступа к самому роутеру или маршрутизатору нет, а вы при этом всё равно хотите установить фиксированный ip-адрес.</p>
			<p>Для примера, пусть ответ будет как на домашней виртуальной машине.</p>
			<div class="codeses">
				<pre>
<b>$ /usr/sbin/ifconfig</b>
...
enp0s3: ...
	inet 192.168.0.110 netmask 255.255.255.0 broadcast 192.168.0.255
...

<b>$ sudo route</b>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.0.1     0.0.0.0         UG    0      0        0 enp0s3
...</pre>
			</div>
			<p>Записываем.</p>
			<ul>
				<li><b>192.168.0.110</b> - ipv4.</li>
				<li><b>255.255.255.0</b> - маска.</li>
				<li><b>192.168.0.255</b> - вещательный адрес.</li>
				<li><b>192.168.0.1</b> - шлюз по умолчанию.</li>
			</ul>
			<p>Проверяем через ip-калькулятор - на всякий случай. Вдруг что-нибудь где-нибудь введёте неправильно, ошибётесь на одну единственную циферку - из-за чего можете даже потерять доступ. Такие настройки лучше лишний раз перепроверить, т.е. перепроверить самого себя и убедиться что всё сделано правильно и без ошибок.</p>
			<div class="codeses" style="background-color:black;color:white;">
				<pre>
<b>$ ipcalc 192.168.0.110/24</b>
Address:   <span style="color:blue;">192.168.0.110</span>         <span style="color:yellow;">11000000.10101000.00000000. 01101110</span>
Netmask:   <span style="color:blue;">255.255.255.0 = 24</span>    <span style="color:red;">11111111.11111111.11111111. 00000000</span>
Wildcard:  <span style="color:blue;">0.0.0.255</span>             <span style="color:yellow;">00000000.00000000.00000000. 11111111</span>
=>
Network:   <span style="color:blue;">192.168.0.0/24</span>        <span style="color:Violet;">110</span><span style="color:yellow;">00000.10101000.00000000. 00000000</span>
HostMin:   <span style="color:blue;">192.168.0.1</span>           <span style="color:yellow;">11000000.10101000.00000000. 00000001</span>
HostMax:   <span style="color:blue;">192.168.0.254</span>         <span style="color:yellow;">11000000.10101000.00000000. 11111110</span>
Broadcast: <span style="color:blue;">192.168.0.255</span>         <span style="color:yellow;">11000000.10101000.00000000. 11111111</span>
Hosts/Net: <span style="color:blue;">254</span>                   <span style="color:Violet;">Class C</span><span style="color:white;">, Private Internet</span></pre>
			</div>
			<ul>
				<li><b>HostMin</b> - шлюз. Верно.</li>
				<li><b>Broadcast</b> - вещательный адрес. Тоже верно.</li>
				<li><b>Netmask</b> - маска сети. Верно.</li>
				<li><b>Address</b> - ip адрес присвоенный провайдером, маршрутизатором или выбранный вами самими.</li>
			</ul>
			<p>В домашней сети я могу выбрать любой другой адрес в той же подсети. В организации надо смотреть на наличие свободных, т.е. не занятых, адресов в имеющейся подсети. <span style="color:red;"><b>В VPS и VDS серверах менять их ни в коем случае нельзя!</b></span> Именно поэтому и нужно было узнать все эти параметры. Теперь можно вручную указать их в настройках сетевой конфигурации.</p>
			<p>Вот теперь можно переходить к настройкам интерфесов.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/network/interfaces</b>
...
allow-hotplug enp0s3
auto enp0s3
# iface enp0s3 inet dhcp
iface eth1 inet static
	address 192.168.0.110
	netmask 255.255.255.0
	gateway 192.168.0.1
	broadcast 192.168.0.255
	# dns-nameservers 192.168.0.1 8.8.8.8
# pre-up ifconfig enp0s3 hw ether xx:xx:xx:xx:xx:xx
# pre-up ip link set enp0s3 address xx:xx:xx:xx:xx:xx
...
<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<b>$ sudo systemctl restart networking</b>
<span style="color:blue;"># Но лучше бы было просто перезагрузить сервер и снова войти по ssh</span></pre>
			</div>
			<p>Параметр &laquo;dns-nameservers&raquo; закоментирован и отвечает за настройку DNS-серверов для данного сетевого адаптера. Однако, здесь dns-сервера никогда не указывают, потому что это не совсем правильно, хотя и вполне возможно. Об этом будет подробнее рассказано <a href="#part13.3">в другой главе</a>.</p>
			<p>Настройка &laquo;pre-up&raquo; отвечает за запуск дополнительных параметров в зависимости от состояния сетевого адаптера. Например, смена мак-адреса перед запуском интерфейса. В данном случае указны 2 способа смены - утилитой из &laquo;net-tools&raquo; и встроенной. Их можно указывать несколько штук построчно, и даже одинаковые состояния в каждой из строк. Также сюда же можно вносить дополнительные iptables правила, которые должны быть вставлены при запуске того или иного интерфейса. Например, перед запуском интерфейса добавлять правила, а после отключения удалять. Или же, например записать все iptables правила добавления в один скрипт, правила удаления в другой скрипт и укаждый из этих скриптов указать в соответствующих строках перед запуском интерфейса и после отключения интерфейса.</p>
			<p>Вот список состояний, которые могут вам пригодиться.</p>
			<ul>
				<li><b>pre-up</b> - Выполнить команду перед запуском интерфейса.</li>
				<li><b>post-up</b> - Выполнить команду после запуска интерфейса.</li>
				<li><b>pre-down</b> - Команда перед отключением.</li>
				<li><b>post-down</b> - Команда после отключения.</li>
			</ul>
			<p>Если вы что-нибудь меняете вручную - вот список параметров, которые можно использовать в ручных, а не скриптовых, настройках.</p>
			<ul>
				<li><b>iface</b> -  Указывает имя интерфейса.</li>
				<li><b>up</b> - Выполнить команду при запуске интерфейса.</li>
				<li><b>auto</b> - автоматический запуск интерфейса.</li>
				<li><b>inet</b> - Указывает description такие как static, dhcp или manual.</li>
				<li><b>address</b> - Устанавливает ip адрес для статического соединения.</li>
				<li><b>netmask</b> - Установка маски сети.</li>
				<li><b>broadcast</b> - Широковещательный адрес.</li>
				<li><b>metric</b> - Приоритет для шлюза по умолчанию.</li>
				<li><b>gateway</b> - Шлюз по умолчанию.</li>
				<li><b>hwaddress</b> - Установить MAC адрес.</li>
				<li><b>mtu</b> - Размер одного пакета.</li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part6"></a></p>
			<h2>6. Ловушка SSH.</h2>
			<p>Не секрет, что интернет — очень враждебная среда. Как только вы поднимаете сервер, он мгновенно подвергается массированным атакам и множественным сканированиям. Фактически, на среднем сервере 99% трафика может быть вредоносным.</p>
			<p><b>Tarpit</b> — это порт-ловушка, который используется для замедления входящих соединений. Если сторонняя система подключается к этому порту, то быстро закрыть соединение не получится. Ей придётся тратить свои системные ресурсы и ждать, пока соединение не прервётся по таймауту, или вручную разрывать его.</p>
			<p>Чаще всего тарпиты применяют для защиты. Технику впервые разработали для защиты от компьютерных червей. А сейчас её можно использовать, чтобы испортить жизнь спамерам и исследователям, которые занимаются широким сканированием всех IP-адресов подряд.</p>
			<p>Одному из сисадминов по имени Крис Веллонс, видимо, надоело наблюдать за этим безобразием — и он написал маленькую программку <b>&laquo;Endlessh&raquo;</b>, тарпит для SSH, замедляющий входящие соединения. Программа открывает порт (по умолчанию для тестирования указан порт <b>&laquo;2222&raquo;</b>) и притворяется SSH-сервером, а на самом деле устанавливает бесконечное соединение с входящим клиентом, пока тот не сдастся. Это может продолжаться несколько дней или больше, пока клиент не отвалится.</p>
			<p>В предыдущем пункте вы настраивали ваш SSH-сервер, и надеюсь всё-таки поменяли порт по умолчанию на какой-нибудь другой. Затем в фаерволе открыли именно этот другой порт. Чтобы ловушка работала для неё надо будет в фаерволе открыть порт на котором она будет работать. Пускай на порту по умолчанию - <b>22</b>.</p>
			<p><b><span style="color:red;">Обратите внимание на один момент перед тем, как будете или не будете использовать эту утилиту!</span></b></p>
			<p>Открывать лишний порт в любом фаерволе - не слишком безопасно. Если вы добавляли отдельного обычного пользователя с ограниченными правами доступа и правильно настроили безопасность SSH-соединений только по <b>SSH-ключам</b> + обязательно использовали фаервол <b>Firewalld</b> и <b>Fail2ban</b> - то такая ловушка вам, скорее всего, будет и не нужна вообще. <b>НО</b>, если у вас используется вход по паролям - лучше, если вы откроете этот лишний порт в вашем фаерволе. Допустим, настоящий SSH-сервер, тогда будет на неком отличном от 22 порту (например, 2222) - то лучше, если ловушка при этом будет работать именно на 22 порту.</p>
			<p><b>Установка утилиты.</b></p>
			<p><u>Само собой, если вы ещё не устанавливали <b>&laquo;docker&raquo;</b> и <b>&laquo;docker-compose&raquo;</b> - пока что пропустите этот пункт и вернитесь к нему, как только установите.</u></p>
			<p>Интернет предлагает установить утилиту напрямую 2-мя способами - с помощью установки и настроки пакета, который есть в Debian репозиториях и клонировать репозиторий.</p>
			<p>Вы можете выбрать любой из этих способов, найти их в интернете и использовать. У каждого способа есть свои достоинства и недостатки. Что-то может заработать с первого раза, или наоборот не заработать вообще и вы просто промучаетесь пытаясь установить этими способами.</p>
			<p>Я же предлагаю несколько более универсальный подход - используя <b>docker-контейнер</b>. В этом случае утилита точно заработает с первого раза.</p>
			<p>Создадим для этой утилиты отдельную папку и запустим контейнер.</p>
			<div class="codeses">
				<pre><b>$ mkdir -p endlessh && cd endlessh</b>
<b>$ nano docker-compose.yml</b>

---
version: "3.4"
services:
  endlessh:
    image: harshavardhanj/endlessh:alpine
    container_name: endlessh
    ports:
      - "22:2222"
    restart: unless-stopped

<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Запускаем, ждем когда запуститься и проверяем.</span>
<b>$ sudo docker-compose up -d</b>
<b>$ sudo docker ps</b></pre>
			</div>
			<p>Разумеется, не забудьте поменять порт в вашем <b>sshd_config</b> и открыть оба порта в вашем фаерволе во входной зоне из интернета. <br>В данном конкретном примере - это <b>2222</b> и <b>22</b>.</p>
			<p>Если вам нужны подробности по установке или работе данной ловушки, то можете посмотреть о ней исчерпывающий ролик на youtube канале <a href="https://www.youtube.com/watch?v=gYjITRRHwxE"><b>&laquo;#linux life&raquo;</b></a>.</p>
			<iframe id="videoarea" width="720" height="480" src="https://www.youtube.com/embed/gYjITRRHwxE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part7"></a></p>
			<h2>7. Форвардинг, sysctl.</h2>
			<p>sysctl — в BSD и Linux — программа, предназначенная для управления отдельными параметрами ядра, безопасности, сетевой подсистемы. Позволяет определять и задавать такие параметры как размер сегмента разделяемой памяти, ограничение на число запущенных процессов, а также включать функции наподобие маршрутизации.</p>
			<p>Имеет конфигурационный файл /etc/sysctl.conf, в котором переопределяются необходимые параметры.</p>
			<p>Для начала сделаем его бэкап следующей командой:</p>
			<p class="codes">
				$ sudo cp /etc/sysctl.conf /etc/sysctl.conf.back
			</p>
			<p>Значение sysctl загружаются во время загрузки системы из файла /etc/sysctl.conf. В этом файле могут быть пустые строчки, комментарии (строки, начинающиеся на символ «#» или точку с запятой), а также строки в формате «переменная=значение». Если вы хотите применить его в любой момент времени, вы можете сделать это с помощью команды &laquo;sysctl -p&raquo;.</p>
			<p>О каждом из параметров вы можете почитать вот в этой <a target="_blank" href="https://rtfm.wiki/linux/sysctl_settings">&laquo;статье&raquo;</a>. Я же расскажу о наиболее часто применяемых.</p>
			<ul>
				<li>включить пересылку IP-пакетов (ipv4, ipv6).</li>
				<ul>
					<li><b>net.ipv4.ip_forward = 1</b></li>
					<li><b>net.ipv4.conf.all.forwarding = 1</b></li>
					<li><b>net.ipv6.conf.all.forwarding = 1</b></li>
					<li><b>net.ipv6.conf.default.forwarding = 1</b></li>
				</ul>
				<li>Позволяет осуществлять фильтрацию пакетов по адресу назначения (проверка адреса получателя).</li>
				<ul>
					<li><b>net.ipv4.conf.all.rp_filter = 1</b></li>
				</ul>
				<li>Включает/выключает проксирование arp-запросов для заданного интерфейса. ARP-прокси позволяет маршрутизатору отвечать на ARP запросы в одну сеть, в то время как запрашиваемый хост находится в другой сети. С помощью этого средства происходит обман отправителя, который отправил ARP запрос, после чего он думает, что маршрутизатор является хостом назначения, тогда как в действительности хост назначения находится на другой стороне маршрутизатора. Маршрутизатор выступает в роли уполномоченного агента хоста назначения, перекладывая пакеты от другого хоста.</li>
				<ul>
					<li><b>net.ipv4.conf.default.proxy_arp = 1</b></li>
					<li><b>net.ipv4.conf.all.proxy_arp = 1</b></li>
				</ul>
				<li>Включает/выключает выдачу ICMP Redirect другим хостам. Эта опция обязательно должна быть включена, если хост выступает в роли маршрутизатора любого рода. Как правило ICMP-сообщения о переадресации отправляются в том случае, когда необходимо сообщить хосту о том, что он должен вступить в контакт с другим сервером. Переменная может иметь два значения 0 (выключено) и 1 (включено). Значение по-умолчанию 1 (включено). Если компьютер не выступает в роли маршрутизатора, то эту переменную можно отключить.</li>
				<ul>
					<li><b>net.ipv4.conf.default.send_redirects = 1</b></li>
					<li><b>net.ipv4.conf.all.send_redirects = 0</b></li>
				</ul>
				<li>Отключения поддержки IPv6.</li>
				<ul>
					<li><b>net.ipv6.conf.all.disable_ipv6 = 1</b></li>
					<li><b>net.ipv6.conf.default.disable_ipv6 = 1</b></li>
					<li><b>net.ipv6.conf.lo.disable_ipv6 = 1</b></li>
				</ul>
			</ul>
			<p>Вот все указанные настройки. Благо у меня на VPS сервере не используется IPV6, поэтому я его отключу. При необходимости, смогу зайти через ssh, закоментировать соответствующие строки и перезагрузить правила соответствующей командой.</p>
			<p class="codes">
				<b>$ sudo nano /etc/sysctl.conf</b></br>
				net.ipv4.ip_forward=1</br>
				net.ipv4.conf.all.forwarding=1</br>
				net.ipv6.conf.all.forwarding=1</br>
				net.ipv6.conf.default.forwarding = 1</br>
				net.ipv4.conf.all.rp_filter = 1</br>
				net.ipv4.conf.default.proxy_arp = 1</br>
				net.ipv4.conf.all.proxy_arp=1</br>
				net.ipv4.conf.default.send_redirects = 1</br>
				net.ipv4.conf.all.send_redirects = 0</br></br>
				net.ipv6.conf.all.disable_ipv6 = 1</br>
				net.ipv6.conf.default.disable_ipv6 = 1</br>
				net.ipv6.conf.lo.disable_ipv6 = 1</br></br>
				
				<span style="color:blue;"># Сохраняем и выходим</span></br>
				<b>CTRL + o</b></br>
				<b>CTRL + x</b></br>
				<span style="color:blue;"># Принимаем правила без перезагрузки ОС.</span></br>
				<b>$ sudo sysctl -p</b></br>
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part8"></a></p>
			<h2>8. Конфликт портов или автозапуск из ниоткуда apache2.</h2>
			<p>Иногда, не только в <b>VPS</b> или <b>VDS</b>, но и при установке на домашний ПК или в организации при установке совершенно нового образа <b>Debian</b> или <b>Ubuntu</b> может встретиться такая ситуация - когда вы попросту не можете запустить какой-либо сервис на выбранном порту.</p>
			<p>Я встретился с ситуацией, когда на совершенно новом дистрибутиве <b>Debian 11</b> не cмог запустить только что установленный <b>nginx</b> на <b>80 порту</b>.</p>
			<p>Что делать в таком случае?</p>
			<p>Во первых отследить - сервис, который перекрывает вам доступ, а точнее порт сервиса.</p>
			<p class="codes">
				$ sudo netstat -tlnp
			</p>
			<p>Команда покажет все запущенные процессы и прослушиваемые порты. По портам сможете найти интересующий вас сервис. В последнем столбце как раз и увидете наименование сервиса, который портит вам жизнь.</p>
			<p><u>Теперь необходимо именно выключить найденый сервис</u>, а не просто убить процесс. В моём случае это был сервис <b>apache2</b>.</p>
			<p class="codes">
				$ sudo update-rc.d apache2 disable
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part9"></a></p>
			<h2>9. Apparmor.</h2>
			<p><b>AppArmor</b> - программный инструмент упреждающей защиты, основанный на политиках безопасности, которые определяют, к каким системным ресурсам и с какими привилегиями может получить доступ то или иное приложение. В AppArmor включён набор стандартных профилей, а также инструменты статического анализа и инструменты, основанные на обучении, позволяющие ускорить и упростить построение новых профилей. <br>Т.е. <b>AppArmor</b> - это реализация Модуля безопасности линукс по управлению доступом на основе имен. AppArmor ограничивает отдельные программы набором перечисленных файлов и возможностями в соответствии с правилами Posix 1003.1e. <br><b>AppArmor</b> устанавливается и загружается по умолчанию. Он использует профили приложений для определения какие файлы и права доступа требуются приложению.</p>
			<p>AppArmor является важным элементом безопасности, который по умолчанию включен в Ubuntu начиная с версии Ubuntu 7.10. Тем не менее, AppArmor работает в фоновом режиме, поэтому Вы можете не знать, что это такое и что AppArmor делает.</p>
			<p>AppArmor блокирует уязвимые процессы, ограничивая уязвимость в системе безопасности, которая может возникнуть из-за уязвимости этих процессов. AppArmor можно также использовать для того, чтобы заблокировать Mozilla Firefox для повышения безопасности, но по умолчанию это не делается.</p>
			<p>Например, одним из приложений, для которого по умолчанию в Ubuntu задано такое ограничение, является Evince — программа просмотра файлов PDF. Когда Evince работает под вашей пользовательской учетной записью, он может выполнять только вполне определенные действия. Для Evince предоставлены минимальные права доступа, необходимые только для запуска и работы с документами PDF. Если при рендеринге PDF с помощью Evince или при открытии вредоносного PDF, который хочет перехватить управление от Evince, были обнаружены уязвимости, AppArmor сможет ограничить ущерб, который может нанести Evince. В традиционной модели безопасности Linux для Evince будет разрешен доступ ко всему тому, к чему у вас есть доступ. При использовании AppArmor, доступ имеется только к тем вещам, которые требуются программе для просмотра PDF.</p>
			<p>AppArmor, в частности, полезен для ограничения работы программ, в которых могут быть экспойты, например, веб-браузера или серверного программного обеспечения.</p>
			<p>Для просмотра текущего состояния AppArmor, выполните в терминале следующую команду.</p>
			<p class="codes">
				$ sudo apparmor_status
			</p>
			<p>Вы также можете заметить, что AppArmor поставляется с профилем для Firefox - это файл usr.bin.firefox, находящийся в каталоге /etc/apparmor.d. По умолчанию он не включен, так как в нем для Firefox задано слишком много ограничений и из-за этого могут возникать проблемы. В каталоге /etc/apparmor.d/disable имеется ссылка на этот файл, что указывает, что этот профиль отключен.</p>
			<p>Чтобы включить профиль Firefox и с помощью AppArmor ограничить действия, выполняемые Firefox, выполните следующие команды.</p>
			<p class="codes">
				$ sudo rm /etc/apparmor.d/disable/usr.bin.firefox<br>
				$ cat /etc/apparmor.d/usr.bin.firefox | sudo apparmor_parser –a
			</p>
			<p>После выполнения этих команд, снова запустите команду sudo apparmor_status и вы увидите, что теперь загружены профили для Firefox.</p>
			<p>Чтобы отключить профиль Firefox в случае, если из-за него возникают проблемы, выполните следующие команды.</p>
			<p class="codes">
				$ sudo ln -s /etc/apparmor.d/usr.bin.firefox /etc/apparmor.d/disable/<br>
				$ sudo apparmor_parser -R /etc/apparmor.d/usr.bin.firefox
			</p>
			<p>Создать профиль для AppArmor не так сложно как кажется на первый взгляд. Для этого в системе существует несколько утилит. Но для начала давайте рассмотрим синтаксис файла, чтобы было понятно с чем мы имеем дело. Возьмем опять же файл от man.</p>
			<div class="codeses">
				<pre>
include &lt;tunables/global&gt;
/usr/bin/man {
#include &lt;abstractions/base&gt;
#include &lt;abstractions/nameservice&gt;
capability setgid,
capability setuid,
/usr/bin/man r,
/usr/lib/man-db/man Px,
}</pre>
			</div>
			<p>Основу профиля составляют адреса файлов, к которым программа может иметь доступ, а также разрешения для этих файлов. Синтаксис такой.</p>
			<p class="codes">
				<span style="color:blue;">/адрес/файла права</span>
			</p>
			<p>Доступны такие права.</p>
			<ul>
				<li><b>r</b> - разрешить чтение</li>
				<li><b>w</b> - разрешить запись</li>
				<li><b>a</b> - разрешить запись в конец файла</li>
				<li><b>px</b> - разрешить запуск новых процессов если для них есть профиль</li>
				<li><b>Px</b> - разрешить запуск новых процессов, если для них есть профиль и стереть переменные окружения</li>
				<li><b>ix</b> - разрешить запуск нового процесса под профилем текущего</li>
				<li><b>m</b> - разрешить загружать исполняемые файлы в память и запускать</li>
				<li><b>l</b> - разрешить создавать символические ссылки на исполняемые файлы</li>
				<li><b>k</b> - разрешить блокировать файлы</li>
				<li><b>ux</b> - не контролировать новые процессы</li>
				<li><b>Ux</b> - не контролировать новые процессы и очистить переменные окружения.</li>
			</ul>
			<p>Этих полномочий вполне достаточно, для управления правами, но кроме списка файлов и их полномочий, файл профиля содержит еще директивы include и capability.</p>
			<p>include позволяет включать другие файлы с разрешениями, они находятся в папке /etc/apparmor.d/abstractions/. Это такие же части профиля, со списком файлов и правами доступа. Они облегчают создание новых профилей.</p>
			<p>С capability все немного сложнее. Программа может обращаться к ядру с помощью системных вызовов, эти вызовы Apparmor тоже контролирует. Посмотреть все доступные вызовы вы можете командой man capabilities. В нашем случае мы разрешаем процессу задать свой uid и gid, то есть сменить пользователя и группу, от которого он запущен.</p>
			<p>Есть еще папка /etc/apparrmor.d/thunables с переменными, которые могут использоваться в каждом профиле. Но с ними разберемся по ходу. Теперь вы готовы к тому, чтобы создать профиль apparmor. Для примера будем создавать новый профиль для утилиты free. Напомню, что эта утилита показывает доступную оперативную память.</p>
			<p>Сначала выполните такую команду, чтобы инициализировать шаблон профиля.</p>
			<p class="codes">
				$ sudo aa-autodep free
			</p>
			<p>Шаблон профиля создан, можете его посмотреть, теперь нужно выполнить профилирование программы, чтобы посмотреть какие ей файлы нужны и добавить их в профиль.</p>
			<p class="codes">
				$ sudo aa-genprof free
			</p>
			<p>Программа может попросить что запустить в отдельном окне терминала, и выполнить все действия, которые она может делать, затем нажать S.</p>
			<p>Готово, теперь нажимаем F, чтобы завершить работу утилиты.</p>
			<p>Если вы меняли профиль вручную, то его необходимо перезагрузить, чтобы изменения вступили в силу, для этого используйте команду.</p>
			<p class="codes">
				$ sudo aa-parser имя_профиля -a
			</p>
			<p>Перезагрузить все профили можно командой.</p>
			<p class="codes">
				$ sudo service apparmor reload
			</p>
			<br>
			<p>Вообще, docker использует AppArmor для защиты, притом Docker Engine сам генерирует дефолтный профиль для AppArmor при запуске контейнера. Другими словами, вместо.</p>
			<p class="codes">
				$ docker run --rm -it hello-world
			</p>
			<p>запускается.</p>
			<p class="codes">
				$ docker run --rm -it --security-opt apparmor=docker-default hello-world
			</p>
			<p>Вообще, AppArmor не рекомендуется отключать, но бывает, что это необходимо - например из-за конфликта доступа, или потому что он потребляет слишком много оперативной памяти...</p>
			<p>Если вам больше не нужен Apparmor и вы не не хотите, чтобы программа тратила системные ресурсы или хотите просто отключить ее для отладки, это можно сделать следующей командой.</p>
			<p class="codes">
				$ sudo systemctl stop apparmor && sudo systemctl disable apparmor && sudo systemctl mask apparmor
			</p>
			<p>Включить обратно можно аналогичной командой.</p>
			<p class="codes">
				$ sudo systemctl unmask apparmor && sudo systemctl enable apparmor && sudo systemctl start apparmor
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part10"></a></p>
			<h2>10. Настройка времени и локали.</h2>
			<h3>Настройка и синхронизация времени.</h3>
			<p><a name="part10.1"></a></p>
			<h4>10.1. Синхронизация timesyncd.</h4>
			<p>Системное время - важный параметр в работе сервера, так как на него завязаны почти все службы. Сегодня мы рассмотрим с вами, как настроить время в сервере Debian - установить его, указать или сменить часовой пояс, а так же настроить автоматическое обновление.</p>
			<p>Во время установки Debian, сервер автоматически настраивает системное время на основе информации из bios. Инсталлятор предлагает вам выбрать только часовой пояс. При этом, если вы не правильно указали часовой пояс (timezone), его без проблем можно изменить после установки.</p>
			<p>Так же ситуация, когда необходимо изменить время или часовой пояс, может возникнуть, если вы арендуете сервер за границей и вам разворачивают систему из готового образа. В таком случае timezone может быть указана не такая, как вы хотите.</p>
			<p>Зачем, собственно, следить за точным временем на сервере, кроме непосредственно удобства восприятия этого времени? Причин может быть много.</p>
			<ul>
				<li>Для корректного логирования всех событий и последующего расследования инцидентов. Более того, одинаковое время должно быть на всех серверах, которые участвуют в работе.</li>
				<li>В доменной середе Windows для корректной работы протокола аутентификации Kerberos требуется примерно одинаковое время на всех участниках домена. Если ваш сервер Debian является членом домена, важно, чтобы его время не сильно отличалось от времени контроллера домена. Его нужно обязательно синхронизировать с ним.</li>
				<li>На сервере может располагаться какой-то сервис, который взаимодействует с пользователями. Если неправильно настроить часы или timezone, может возникнуть ситуация, когда для некоторых пользователей материалы будут отображаться со временем из будущего.</li>
				<li>Планировщик cron в своей работе использует системные часы. Если вы хотите предсказуемое поведение запланированных задач, время и часовой пояс должны быть настроены правильно.</li>
			</ul>
			<p>Сначала посмотрим на системное время.</p>
			<p class="codes">
				$ date
			</p>
			<p>Сразу видим часовой пояс, дату и время в 12-ти или 24 часовом формате. Если у вас отображается 12-ти часовой формат добавьте +%R к date.</p>
			<p class="codes">
				$ date +%R
			</p>
			<p>Подобные параметры удобно использовать в скриптах.</p>
			<p class="codes">
				$ date +%Y-%m-%d<br>
				$ date +%H-%M-%S<br>
				$ date +%Y-%m-%d_%H-%M-%S<br>
				$ date +%H-%M_%d.%m.%Y
			</p>
			<p>Чтобы увидеть более подробную информацию о состоянии воспользуемся другой командой.</p>
			<p class="codes">
				$ timedatectl status
			</p>
			<p>Для того, чтобы вручную установить дату, используем упомянутую выше команду date, только уже с дополнительными параметрами.</p>
			<p class="codes">
				$ sudo date 04220900
			</p>
			<p>Здесь 04 — месяц, 22 — число, 09 — час, 00 — минут. Таким образом, формат команды получился вот такой - date MMDDhhmm.</p>
			<p>То же самое, только через timedatectl.</p>
			<p class="codes">
				$ sudo timedatectl set-time "2023-04-22 08:45:00"
			</p>
			<p>Если вы получили ошибку - Failed to set time: Automatic time synchronization is enabled, значит у вас уже настроено автоматическое обновление времени. В таком случае timedatectl, в отличие от date, время менять не будет.</p>
			<p>В моем случае timezone установлена как MSK, то есть московский часовой пояс. Если у вас указан другой часовой пояс, а вы, к примеру, хотите установить московский, то делается это просто. Смена часового пояса выполняется через timedatectl.</p>
			<p class="codes">
				<span style="color:blue;"># Перед настройкой или изменением часового пояса, рекомендуется обновить список timezone на сервере.</span></br>
				$ sudo apt update && sudo apt upgrade tzdata</br></br>
				<span style="color:blue;"># Список всех timezоne, доступных для установки на сервере</span></br>
				$ timedatectl list-timezones</br>
				<span style="color:blue;"># Устанавливаем выбранную зону</span></br>
				$ sudo timedatectl set-timezone Europe/Moscow</br>
				<span style="color:blue;"># Включаем автообновление времени</span></br>
				$ sudo timedatectl set-ntp true
			</p>
			<p>В большинстве современных дистрибутивов с systemd служба синхронизации времени уже присутствует в дефолтной установке и реализуется через systemd-timesyncd. Эта служба призвана заменить ntpd. Со слов разработчиков, она легче и быстрее, чем ntpd, плюс интегрирована в systemd, поэтому для автоматической синхронизации времени рекомендуется использовать именно ее.</p>
			<p>Тут важно понимать, что systemd-timesyncd не может работать в качестве сервера времени. Так что, если у вас одиночный сервер, вам вполне подойдет timesyncd. Если же вы хотите использовать свой сервер времени, то надо настраивать ntp.</p>
			<p>Посмотрим на службу timesyncd.</p>
			<p class="codes">
				$ timedatectl timesync-status</br>
				<span style="color:blue;"># Для надежности, можно убедиться, что служба работает, плюс, добавим ее сразу в автозагрузку, если ее там нет.</span></br>
				$ sudo systemctl status systemd-timesyncd<br>
				$ systemctl enable systemd-timesyncd
			</p>
			<p>Список серверов для синхронизации времени в timedatectl настраивается в конфигурационном файле <b>&laquo;/etc/systemd/timesyncd.conf&raquo;</b>. В случае, когда вы используете timesyncd, а не ntp, то сервера будут браться из этого файла.</p>
			<p>Если у вас возникают ошибки при попытке синхронизировать время, возможно настройка этого файла поможет решить проблему.</p>
			<p>В этом файле нас интересуют 2 строки: <b>&laquo;NTP&raquo;</b> и <b>&laquo;FallbackNTP&raquo;</b>. Раскомментируйте их. Первая стркоа отвечает за сервера по умолчанию, вторая за сервера, если не удалось установить соединение с первыми.</p>
			<p>Итак, вот пример конфигурации, например, Российской федерации. Сервера можно посмотреть на официальном сайте: <a target="_blank" href="https://www.ntppool.org/zone/ru"><b>&laquo;ntppool.org&raquo;</b></a>. Самое интересное в том, что сервера можно выбирать как с суб-зонами, так и без суб-зон.</p>
			<p class="codes">
				NTP=0.ru.pool.ntp.org 1.ru.pool.ntp.org 2.ru.pool.ntp.org 3.ru.pool.ntp.org</br>
				FallbackNTP=0.arch.pool.ntp.org 1.pool.ntp.org 2.europe.pool.ntp.org 3.asia.pool.ntp.org
			</p>
			<p>Пробуем синхронизироваться.</p>
			<p class="codes">
				$ sudo timedatectl set-ntp true
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part10.2"></a></p>
			<h4>10.2. Синхронизация времени с помощью ntp и ntpdate.</h4>
			<p>Если вам по какой-то причине не подходит описанная выше синхронизация, либо вам нужен свой сервер времени в сети, то timesyncd можно выключить.</p>
			<p class="codes">
				$ systemctl stop systemd-timesyncd</br>
				$ systemctl disable systemd-timesyncd
			</p>
			<p>Теперь установим ntpdate.</p>
			<p class="codes">
				$ sudo apt install ntpdate</br>
				<span style="color:blue;"># Запускаем для разовой синхронизации.</span></br>
				$ sudo systemctl start ntp</br>
				$ sudo systemctl enable ntp<br>
				$ sudo ntpdate pool.ntp.org<br><br>
				<span style="color:blue;"># Проверяем.</span></br>
				$ sudo systemctl status ntp
			</p>
			<p>Если у вас ntpdate выдает ошибку — the NTP socket is in use, exiting, значит у вас уже установлена и запущена служба ntp, которая заняла udp порт 123, необходимый для работы ntpdate. </p>
			<p>При этом, для проверки статуса службы времени ntp можно использовать утилиту ntpq. Посмотрим статус синхронизации.</p>
			<p class="codes">
				$ ntpq -p
			</p>
			<p><b>Настройка своего NTP сервера синхронизации в данной статье не рассматривается.</b></p>
			<p>Рассмотрим настройку ntp чуть более подробно.</p>
			<p>Если вы хотите изменить сервера своей страны, воспользуйтесь файлом &laquo;/etc/ntp.conf&raquo;. <br>Посмотреть сервера в зависимости от страны можно на официальном сайте <a target="_blank" href="https://www.ntppool.org/zone/ru">ntppool.org</a>. <br>Соответственно вставляйте эти настройки вместо таких же строк. Или просто закоментируйте такие же строки настроек и вставляйте свои чуть ниже.</p>
			<p class="codes">
				server 0.ru.pool.ntp.org iburst<br>
				server 1.ru.pool.ntp.org iburst<br>
				server 2.ru.pool.ntp.org iburst<br>
				server 3.ru.pool.ntp.org iburst
			</p>
			<p>Опция 'iburst' рекомендуется, с ее помощью посылается шквал пакетов, если не удается установить соединение с сервером с первого раза. Напротив, опцию 'burst' не используйте никогда без особого разрешения, так как Вы можете попасть в "черный список".</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part10.3"></a></p>
			<h4>10.3. Настройка локали и языка.</h4>
			<p>Системная локаль устанавливается с помощью переменной <b>LANG</b>.</p>
			<p>Программы, использующие <b>gettext</b> для перевода, учитывают также переменную <b>LANGUAGE</b> в дополнение к стандартным переменным. Это позволяет пользователям установить список локалей, которые будут использоваться в указанном порядке для поиска перевода. Если перевод для более предпочтительной локали (которая идет первее в списке) недоступен, будет произведена попытка получить перевод для следующей, и так далее.</p>
			<p>Переменная <b>LC_TIME</b> отвечает за формат даты и времени.</p>
			<p>Переменная <b>LC_COLLATE</b> отвечает за порядок сортировки и регулярных выражений. Установка значения LC_COLLATE=C, например, приведет к тому, что команда ls будет располагать файлы, имена которых начинаются с точки, первыми, за ними последуют имена, начинающиеся с цифры, затем с заглавной и, наконец, со строчной буквы.</p>
			<p>Переменная <b>LC_ALL</b> переопределяет своим значением все LC_*-переменные, включая LANG, независимо от того, установлены они или нет.</p>
			<p>Переменная <b>LC_ALL</b> — единственная из всех LC_-переменных, которую нельзя установить в <b>&laquo;/etc/locale.conf&raquo;</b>. Она предназначена только в целях проверки при решении проблем.</p>
			<p>Посмотрим определение текущей locale в системе.</p>
			<p class="codes">
				<span style="color:blue;"># Текущая locales</span></br>
				$ locale<br><br>
				<span style="color:blue;"># Список сгенерированных locales в системе</span></br>
				$ locale -a<br><br>
				<span style="color:blue;"># Список сгенерированных locales с подробным описанием</span></br>
				$ locale -a -v
			</p>
			<p>Настраиваем <b>&laquo;/etc/default/locale&raquo;</b></p>
			<p class="codes">
				<b>$ sudo nano /etc/default/locale</b></br>
				LANG=en_US.utf-8
			</p>
			<p>Теперь записываем переменные окружения, чтобы при перезагрузке сервера настройки остались.</p>
			<p class="codes">
				<b>$ sudo nano /etc/environment</b></br>
				LANGUAGE=en_US.UTF-8</br>
				LANG=en_US.utf-8</br>
				LC_ALL=ru_RU.UTF-8</br>
				LC_COLLATE=ru_RU.UTF-8</br>
				LC_TIME=en_US.utf-8
			</p>
			<p>Чтобы не перезагружать систему, выполним ещё несколько команд.</p>
			<p class="codes">
				$ export LANGUAGE=en_US.UTF-8<br>
				$ export LANG=en_US.utf-8<br>
				$ export LC_ALL=ru_RU.UTF-8<br>
				$ export LC_COLLATE=ru_RU.UTF-8<br>
				$ export LC_TIME=en_US.utf-8<br><br>
				$ locale-gen
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part13"></a></p>
			<h2>13. Настройка DNS.</h2>
			<h3>Введение.</h3>
			<p>DNS — это система для связывания доменных имен с соответствующими им IP-адресами. DNS-серверы позволяют хранить данные IP-адресов соответствующих доменов, обеспечивать их кэширование и выдачу информации пользователю по запросу в сжатые сроки. Расположенные в разных локациях серверы повышают скорость загрузки страницы и, соответственно, лояльность пользователя к ресурсу.</p>
			<p>На самом деле весь интернет работает именно с системой IP-адресов, а привычные нам названия нужны только для удобства людей: их проще запоминать и вводить. Поэтому всё, что вам нужно, — написать в адресной строке браузера веб-адрес и нажать Enter. Дальше браузер всё сделает сам: отправит нужные запросы, разыщет IP-адрес и откроет страницу.</p>
			<p>Вообще, DNS состоит из двух частей: протокола и сети серверов. Протокол отвечает за способ передачи данных по сети, а серверы представляют собой машины, которые помогают протоколу эффективно работать. Но когда говорят о DNS, чаще всего подразумевают именно протокол.</p>
			<p>По сути DNS-сервера в более простом понимании - это адресная книга. Мы вводим в браузер адрес, но он его не знает. Поэтому отправляет запрос в адресную книгу. По умолчанию в любой системе настроен только DNS провайдера, т.е. только то, что ПК (пусть даже и виртуальный) получил по сети в виде DHCP ответа на свой запрос при подключении к локальной, в данном случае домашней, сети.</p>
			<p>В операционных системах Windows и Linux имеется файл hosts, в котором можно установить IP адреса для любых имён — хостов и доменных имён. По умолчанию операционные системы работают так.</p>
			<ul>
				<li>Если запрашиваемое имя присутствует в файле hosts, то его IP берётся из этого файла и запрос к DNS серверу не делается.</li>
				<li>Если в файле hosts имя хоста не найдено, то выполняется запрос к DNS серверу.</li>
			</ul>
			<p>В ОС Linux-ах помимо файла hosts есть ещё так называемый порядок источников имен NSSWITCH. Вот как раз он в Linux системах и определяет порядок обращения.</p>
			<p>Обычно порядок тот же, что и в Windows, описанный выше - сначала файл hosts, затем dns-сервера. Порядок обращения можно изменить. Например, установить сначала обращение к DNS серверам. Если запрашиваемое имя не было найдено на dns-серверах, то обратиться к файлу hosts.</p>
			<p>Однако, помимо NSSWITCH и файла hosts в Linux системах существует также ещё и так называемый DNS-резолвер. Когда система начинает обращаться к DNS-серверам, резолвер определяет порядок обращения к различным dns-серверам. Тут может быть настроен как один единственный DNS-сервер, например, провайдера, так и несколько различных серверов на ваше усмотрение.</p>
			<p>При запросе имени на один сервер, если он не ответил, или ответил, что не знает такого имени, то ваша система будет пытаться запрашивать ту же информацию с другого dns-сервера. И вот когда ни один из настроеных списков dns-серверов не ответит, или ответит, что такого адреса нет - то только в этом случае система сообщит пользователю или браузеру, что ничего не найдено.</p>
			<p>Бывает много случаев, когда может понадобиться свой собственный DNS-сервер. Например, при создании и использовании собственного VPN.</p>
			<p>Даже простой резолв адресов также требует правильной настройки.</p>
			<p>Один из примеров - свой собственный фильтр рекламы, например, пусть AdGuard или Pi-Hole. При неправильном резолве адресов фильтр не будет ничего фильтровать.</p>
			<p><u>Перейдём ко всем настройкам по порядку.</u></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part13.1"></a></p>
			<h3>13.1. Порядок источников имен NSSWITCH.</h3>
			<p><b>NSSWITCH</b> - это файл конфигурации Linux, который определяет, как система должна переключаться между различными поставщиками услуг имен.</p>
			<p>Этот файл можно использовать для настройки того, какие службы следует использовать для поиска имени хоста, поиска паролей и т.д.</p>
			<p>Файл /etc/nsswitch.conf считывается библиотекой Name Service Switch (NSS) при запуске системы. Затем библиотека NSS использует информацию в файле /etc/nsswitch.conf, чтобы определить, какие поставщики услуг имен должны использоваться для каждого типа поиска.</p>
			<p><b>/etc/nsswitch.conf является важной частью операционной системы Linux, и любые изменения в этом файле могут привести к серьезным проблемам. Поэтому важно понимать, как работает /etc/nsswitch.conf, прежде чем вносить какие-либо изменения в этот файл.</b></p>
			<p>В операционных системах Windows и Linux имеется файл hosts, в котором можно установить IP адреса для любых имён — хостов и доменных имён. По умолчанию операционные системы работают так.</p>
			<ul>
				<li>Если запрашиваемое имя присутствует в файле hosts, то его IP берётся из этого файла и запрос к DNS серверу не делается.</li>
				<li>Если в файле hosts имя хоста не найдено, то выполняется запрос к DNS серверу.</li>
			</ul>
			<p>В операционной системе Linux можно поменять приоритет источников для получения IP адреса или вовсе отключить некоторые из них. Для этого используется файл &laquo;/etc/nsswitch.conf&raquo;.</p>
			<p>Строка, которая отвечает за преобразование имён хостов начинается на &laquo;hosts&raquo;.</p>
			<p class="codes">
				hosts: files dns
			</p>
			<p>В старых или более новых системах она может быть такой.</p>
			<p class="codes">
				hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns
			</p>
			<ul>
				<li><b>hosts</b> — это указание на службу, для которой предназначена строка.</li>
				<li><b>files</b> означает файл, относящийся к этой службе. У каждой службы в системе свой файл, в данном случае имеется ввиду &laquo;/etc/hosts&raquo;.</li>
				<li><b>mymachines</b> — судя по названию, означает имя машины.</li>
				<li><b>myhostname</b> - hostname, логично.</li>
				<li><b>resolve</b> — это системная служба резолва.</li>
				<li><b>Строка &laquo;[!UNAVAIL=return]&raquo;</b> - означает, что если предыдущая служба недоступна, то немедленно будет возвращён результат без запроса в следующем источнике.</li>
			</ul>
			<p>Файлы других служб.</p>
			<ul>
				<li>aliases /etc/aliases</li>
				<li>ethers /etc/ethers</li>
				<li>group /etc/group</li>
				<li>hosts /etc/hosts</li>
				<li>initgroups /etc/group</li>
				<li>netgroup /etc/netgroup</li>
				<li>networks /etc/networks</li>
				<li>passwd /etc/passwd</li>
				<li>protocols /etc/protocols</li>
				<li>publickey /etc/publickey</li>
				<li>rpc /etc/rpc</li>
				<li>services /etc/services</li>
				<li>shadow /etc/shadow</li>
			</ul>
			<p>Чтобы отключить файл &laquo;/etc/hosts&raquo; просто уберите слово &laquo;files&raquo;.</p>
			<p>Чтобы сделать приоретет dns выше файла &laquo;/etc/hosts&raquo; поставте это слово перед словом &laquo;files&raquo;.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part13.2"></a></p>
			<h3>13.2. DNS-Кеш.</h3>
			<p>Иногда вам может понадобится очистить кеш dns. Например, вам в организации для вашего выделенного белого ip адреса предоставлен доступ к какой-нибудь базе данных. И частенько бывает что у кого-нибудь что-нибудь не грузится, или возникают проблемы с dns-сервером.</p>
			<p>Обычно очистка dns-кеша помогает временно решить проблему. Чтобы постоянно не чистить кеш dns стоит внести в файл &laquo;hosts&raquo; вашей системы сопоставление доменного имени и ip-адреса этой базы данных.</p>
			<p>В Linux-е очистить кеш-dns немного сложнее, чем в Windows-е.</p>
			<p>Сначала необходимо определить кто занимается кешированием. Например, посмотрим на systemd-resolved. Он бывает гораздо удобнее, чем встроеный резолвер в Network Manager.</p>
			<p class="codes">
				$ sudo systemd-resolve --statistics
			</p>
			<p>Команда вернет ошибку, если резолвер не используется.</p>
			<p>Если всё-таки используется для его очистки и перезапуска можно воспользоваться следующими командами.</p>
			<p class="codes">
				$ sudo systemd-resolve --flush-caches<br>
				$ sudo systemctl enable systemd-resolved.service
			</p>
			<p>Не забудьте про службу кеширования запросов службы имён &laquo;nscd&raquo;.</p>
			<p class="codes">
				$ sudo systemctl restart nscd<br>
				$ nscd -K; nscd
			</p>
			<p>Для её установки и настройки в Debian выполните следующие команды</p>
			<p class="codes">
				$ sudo apt install nscd<br>
				$ sudo systemctl restart nscd<br>
				$ sudo ncsd -g<br>
				$ sudo strings /var/cache/nscd/hosts
			</p>
			<p>В Archlinux она есть только в <a href="https://vk.com/away.php?to=https%3A%2F%2Faur.archlinux.org%2Fpackages%2Funscd&cc_key=">&laquo;AUR&raquo;</a>.</p>
			<p>При использовании &laquo;Network Manager&raquo;, его просто необходимо перезапустить.</p>
			<p class="codes">
				$ sudo service networking restart</br>
				<span style="color:blue;"># или</span></br>
				$ sudo systemctl restart NetworkManager
			</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part13.3"></a></p>
			<h3>13.3. DNS-резолвер.</h3>
			<p>systemd-resolved — это сервис systemd для локального резолвинга DNS запросов. По сути это локальный мини DNS-сервер с поддержкой кеширования, DNSSEC и DNSOverTLS. При включенном кешировании он позволяет ускорить резолвинг DNS запросов, особенно при включенном DNSSEC.</p>
			<p>Он полезен для уменьшения задержек резолвинга при использовании нестабильных интернет-провайдеров и при недолгих падениях DNS серверов (в пределах TTL DNS записей доменов, к которым идут запросы). Также не помешает на серверах, где идет много запросов на резолвинг имен (почтовые сервера, сервера мониторинга, сервера с большим количеством задач с запросом данных с удаленных источников).</p>
			<p>Этот сервис в Debian системах уже идет из коробки вместе с systemd. Собственно как и в Archlinux системах. Устанавливать его не нужно. И по умолчанию он обычно отключен.</p>
			<p>Для того, чтобы резолвинг DNS в Debian сервере шел через systemd-resolved, необходимо установить libnss-resolve, плагин для механизма NSS (GNU Name Service Switch). В Archlinux библиотека встроена в systemd.</p>
			<p>Также установим утилиту resolvconf которая хранит системную информацию о доступных в настоящее время серверах имен и управляет содержимым конфигурационного файла resolv.conf, который определяет параметры распознавателя системы доменных имен.</p>
			<p class="codes">
				$ sudo apt install libnss-resolve resolvconf -y
			</p>
			<p>По умолчанию резолвинг адресов настраивается в файле <b>&laquo;/etc/resolv.conf&raquo;</b>.</p>
			<p>Если вы хотите изменить порядок обращения к dns-серверам, а также задать и другие настройки DNS, необходимо сделать резервную копию этого файла и сделать его ссылкой на <b>&laquo;systemd-resolved&raquo;</b>.</p>
			<p class="codes">
				$ sudo mv /etc/resolv.conf /etc/resolv.conf.backup<br>
				$ sudo ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
			</p>
			<p>Если systemd-resolved не получает адреса DNS-серверов от сетевого менеджера и никакие сервера не были настроены вручную, то он использует специальные зарезервированные DNS-адреса. Таким образом, разрешение доменных имён работает всегда.</p>
			<p>Вообще, все глобальные настройки задаются в файле <b>&laquo;/etc/systemd/resolved.conf&raquo;</b>, но рекомендую в нём либо закоментировать всё, кроме <b>&laquo;[Resolve]&raquo;</b> строки, либо если никогда не настраивали, то не трогать этот файл вообще. Лучше перепроверьте, что все настройки закоментированы.</p>
			<p>Дело в том, что systemd-resolved сначала будет читать настройки из этого файла, и только потом, из других. Если здесь первым указан адрес, например DNS-Google, то при попытке использования на вашем сервере того же фильтра рекламы, запросы будут направляться именно на DNS-Google, а не туда куда вам нужно. Поэтому создадим отдельную конфигурацию, чтобы управлять порядком обращения стало значительно проще.</p>
			<p><span style="color:red;"><b>После всех манипуляций не забывайте обязательно перезагружать systemd-resolved.</b></span></p>
			<p class="codes">
				<b>$ sudo mkdir -p /etc/systemd/resolved.conf.d/</b><br>
				<b>$ sudo nano /etc/systemd/resolved.conf.d/dns_servers.conf</b><br><br>
				[Resolve]<br>
				DNS=8.8.8.8 8.8.4.4<br>
				FallbackDNS=77.88.8.8 77.88.8.1<br>
				Domains=~.<br>
				DNSStubListener=no<br>
				DNSSEC=true<br>
				DNSOverTLS=yes<br><br>
				<span style="color:blue;"># Обязательно перезагружаем systemd-resolved</span></br>
				$ sudo systemctl restart systemd-resolved</br></br>
				<span style="color:blue;"># И проверяем что у нас получилось.</span></br>
				$ sudo resolvectl status
			</p>
			<p>Рассмотрим каждый из пунктов поподробнее. Вся информация взята из <a href="https://man.archlinux.org/man/resolved.conf.5">&laquo;ArchMan RESOLVED.CONF(5)&raquo;</a>.</p>
			<ul>
				<li><b>DNS</b> - первичный DNS-сервер, к которому будет производиться запрос в первую очередь.</li>
				<li><b>FallbackDNS</b> - Запасные DNS-сервера.</li>
				<li><b>Domains</b> - это «домены поиска» обрабатываются строго в том порядке, в котором они указаны, до тех пор, пока не будет найдено имя с добавленным суффиксом. По соображениям совместимости, если этот параметр не указан, вместо него используются домены поиска, перечисленные в <b>&laquo;/etc/resolv.conf&raquo;</b> с ключевым словом search, если этот файл существует и в нем настроены какие-либо домены. Домены с префиксом «~» называются «домены только для маршрутизации». Все перечисленные здесь домены (и домены поиска, и домены только маршрутизации после удаления префикса «~») определяют путь поиска, который предпочтительно направляет DNS-запросы к этому интерфейсу. Этот путь поиска действует только тогда, когда известны подходящие DNS-серверы для каждой ссылки. Такие серверы могут быть определены с помощью параметра DNS= (см. выше) и динамически во время выполнения, например, из аренды DHCP. Если DNS-серверы для каждой ссылки неизвестны, домены только для маршрутов не действуют. Используйте конструкцию &laquo;~&raquo;. (который состоит из &laquo;~&raquo;, чтобы указать домен только для маршрута, и &laquo;.&raquo;, чтобы указать корневой домен DNS, который является подразумеваемым суффиксом всех доменов DNS) для использования DNS-серверов, определенных для этой ссылки, предпочтительно для всех доменов. См. &laquo;Протоколы и маршрутизация&raquo; в systemd-resolved.service(8) для получения подробной информации об использовании доменов поиска и маршрутизации.</li>
				<li><b>DNSStubListener</b> - Принимает логический аргумент или один из &laquo;udp&raquo; и &laquo;tcp&raquo;. Если указано &laquo;udp&raquo;, преобразователь заглушки DNS будет прослушивать запросы UDP по адресам 127.0.0.53 и 127.0.0.54, порт 53. Если &laquo;tcp&raquo;, то заглушка будет прослушивать запросы TCP по тем же адресам и порту. Если &laquo;yes&raquo; (по умолчанию), заглушка прослушивает как UDP-, так и TCP-запросы. Если &laquo;no&raquo;, прослушиватель-заглушка отключен. Резолвер-заглушка DNS на 127.0.0.53 предоставляет полный набор функций локального резолвера, включая разрешение LLMNR/MulticastDNS. Преобразователь заглушки DNS на 127.0.0.54 предоставляет более ограниченный преобразователь, который работает только в &laquo;прокси-режиме&raquo;, т. е. он будет передавать большинство сообщений DNS относительно неизмененными на текущие вышестоящие DNS-серверы и обратно, но не будет пытаться обрабатывать сообщения локально, и, следовательно, не проверяет DNSSEC и не предлагает LLMNR/MulticastDNS. (Однако при необходимости он будет переведен на связь DNS-over-TLS.) Обратите внимание, что прослушиватель-заглушка DNS неявно отключается, если его адрес прослушивания и порт уже используются.</li>
				<li><b>DNSSEC</b> - Принимает логический аргумент или «разрешить переход на более раннюю версию». Если установлено значение true, все поисковые запросы DNS проходят локальную проверку DNSSEC (за исключением LLMNR и многоадресной DNS). Если ответ на запрос поиска оказывается недействительным, в приложения возвращается ошибка поиска. Обратите внимание, что для этого режима требуется DNS-сервер, поддерживающий DNSSEC. Если DNS-сервер не поддерживает должным образом DNSSEC, все проверки завершатся неудачей. Если установлено значение «разрешить переход на более раннюю версию», выполняется попытка проверки DNSSEC, но если сервер не поддерживает DNSSEC должным образом, режим DNSSEC автоматически отключается. Обратите внимание, что этот режим делает проверку DNSSEC уязвимой для атак с понижением версии, когда злоумышленник может инициировать переход на режим без DNSSEC, синтезируя ответ DNS, предполагающий, что DNSSEC не поддерживается. Если установлено значение false, запросы DNS не проверяются DNSSEC. Рекомендуется установить для DNSSEC= значение true в системах, где известно, что DNS-сервер правильно поддерживает DNSSEC, и где регулярно происходят обновления программного обеспечения или якоря доверия. В других системах рекомендуется установить для DNSSEC= значение "allow-downgrade". Частные зоны DNS обычно конфликтуют с работой DNSSEC, если только для них не настроена отрицательная (если частная зона не подписана) или положительная (если частная зона подписана) якорь доверия. Если выбран режим &laquo;разрешить переход на более раннюю версию&raquo;, будет предпринята попытка обнаружить частные зоны DNS с использованием доменов верхнего уровня (TLD), которые не известны корневому серверу DNS. Эта логика не работает во всех настройках частной зоны.</li>
				<li><b>DNSOverTLS</b> - Принимает логический аргумент или «оппортунистический». Если true, все подключения к серверу будут зашифрованы. Обратите внимание, что для этого режима требуется DNS-сервер, поддерживающий DNS-over-TLS и имеющий действительный сертификат. Если имя хоста было указано в DNS= в формате «адрес#имя_сервера», оно используется для проверки его сертификата, а также для включения индикации имени сервера (SNI) при открытии соединения TLS. В противном случае сертификат сверяется с IP-адресом сервера. Если DNS-сервер не поддерживает DNS-over-TLS, все DNS-запросы завершатся ошибкой. Если установлено значение «оппортунистический», DNS-запросы пытаются отправить в зашифрованном виде с помощью DNS-over-TLS. Если DNS-сервер не поддерживает TLS, DNS-over-TLS отключен. Обратите внимание, что этот режим делает DNS-over-TLS уязвимым для атак с понижением версии, когда злоумышленник может инициировать переход к незашифрованному режиму, синтезируя ответ, который предполагает, что DNS-over-TLS не поддерживается. Если установлено значение false, запросы DNS отправляются по протоколу UDP. Обратите внимание, что DNS-over-TLS требует отправки дополнительных данных для настройки зашифрованного соединения, что приводит к небольшому увеличению времени поиска DNS. Обратите внимание, что в «оппортунистическом» режиме преобразователь не может аутентифицировать сервер, поэтому он уязвим для атак «человек посередине». В дополнение к этой глобальной настройке DNSOverTLS= systemd-networkd.service(8) также поддерживает настройки DNSOverTLS= для каждой ссылки. Для системных DNS-серверов (см. выше) действует только глобальный параметр DNSOverTLS=. Для DNS-серверов для каждой ссылки действует настройка для каждой ссылки, если только она не отключена, и в этом случае вместо нее используется глобальная настройка.</li>
			</ul>
			<p>А теперь рассмотрим сами параметры описанного конфигурационного файла. Настройки параметров взяты из <a href="https://wiki.archlinux.org/title/Systemd-resolved_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">&laquo;ArchWiki systemd-resolved&raquo;</a>.</p>
			<p><b>DNS=8.8.8.8 8.8.4.4</b><br>В случае когда у вас на сервере предполагается использование любого DNS-сервера - будь то bind9 или фильтра рекламы, вроде AdGuard - то сначала здесь по любому необходимо указать какие-либо сторонные DNS адреса. Просто чтобы система смогла вообще загрузить установочные пакеты. Затем, когда вы установите какой-либо DNS-сервер можно будет сменить все адреса этой строки одним единственным адресом вашего DNS-сервера. <br>Ну, например, вы установили самый простой вариант - bind9 и dnsutils. Тогда в этой строке ничего менять не придётся. Если конечно у вас есть собственные dns-зоны и вы их настроили - то строка будет выглядеть примерно так: &laquo;DNS=127.0.0.1&raquo;. <br>В другом примере вы установили филтр рекламы, пусть, AdGuard в docker-container. DNS оставили на 53 порту. Тогда после запуска фильтра, строка измениться следующим образом: &laquo;DNS=172.20.0.2&raquo;. Разумеется у вас будет свой IP-адрес. Но об этом будет рассказано в следующем разделе. <br>В случае использования Wireguard-а и Bind9 - то оставьте конфигурацию в описанном выше виде. <br>Если же, когда у вас Wireguard и AdGuard - &laquo;DNS=172.20.0.2&raquo;. <br>В пункте о DNS-серверах вы узнаете почему именно такие настройки.</p>
			<p><b>FallbackDNS=77.88.8.8 77.88.8.1</b><br>Запасные адреса DNS-серверов. У меня указаны yandex, но можно и другие или добавить в эту строку перед ними или даже после них. В любом случае они обязательно должны быть. Чтобы, например, при обновлении docker-контейнера с фильтром рекламы AdGuard - не потерять интернет в принципе.</p>
			<p><b>Domains=~.</b><br>Если не указать в файле resolved.conf(5) опцию Domains=~., то systemd-resolved может использовать DNS-серверы из настроек отдельных сетевых интерфейсов, если параметр Domains=~. в них есть. Данная опция не повлияет на запросы доменных имён, которые совпадают с каким-то более точным поисковым доменом из настроек интерфейса — разрешение таких имён будет выполняться посредством соответствующих "интерфейсных" DNS-серверов.</p>
			<p><b>DNSStubListener=no</b><br>Преобразователь заглушки DNS выключен.</p>
			<p><b>DNSSEC</b><br>Если ваш DNS-сервер не поддерживает DNSSEC и вы испытываете проблемы в стандартном (используется по умолчанию) allow-downgrade-режиме, попробуйте полностью отключить DNSSEC в systemd-resolved параметром DNSSEC=false. systemd-resolved может отключить DNSSEC после нескольких неудачных попыток выполнить проверку. Если задано значение DNSSEC=true, то разрешение имён вообще перестанет работать.</p>
			<p><b>DNSOverTLS=yes</b><br>DNS over TLS по умолчанию не работает. Чтобы включить проверку сертификата DNS вашего провайдера, добавьте соответствующее имя хоста в параметр DNS= в формате &laquo;ip_адрес#имя_хоста&raquo;. DNS-сервер должен тоже поддерживать DNS over TLS, иначе он просто не будет отвечать на запросы. </p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part13.4"></a></p>
			<h3>13.4. DNS-сервер.</h3>
			<p>Сегодня невозможно представить себе интернет без DNS. Однако многие администраторы не уделяют время настройке этой службы на своих серверах, поэтому не используют всю ее мощь даже на треть.</p>
			<p>Основная цель DNS — это преобразование доменных имен в IP-адреса и наоборот — IP в DNS.</p>
			<p>По моему глубокому мнению DNS-сервер - это не просто сервер имен, в котором в текстовых файлах содержится информация о тех или иных адресах, а полноценная огромная база данных, но уже не только с сопоставлением имен и ip-адресов, а база, которая также для каждого сопоставления содержит в себе ресурсные записи.</p>
			<p>Ресурсные записи DNS — это записи о соответствии имени и служебной информации в системе доменных имен, например, соответствие имени домена и IP-адреса. Редактирование ресурсных записей для доменного имени производится на стороне держателя NS-серверов (например, хостинг-провайдера, на NS-серверы которого делегировано доменное имя).</p>
			<p>Чтобы при вводе домена в поисковую строку браузера открывался сайт, а не ошибка, нужно указать для домена ресурсные записи DNS. Они «расскажут» другим DNS-серверам интернета о вашем домене. Если не настроить ресурсные записи (записи DNS-зоны), серверы не смогут передавать информацию между собой и сайт просто не будет работать.</p>
			<p>Вы вполне можете делегировать права управления своим зарегистрированным доменом на свой собственный сервер, на сервере установить и настроить как простейший (bind9), так и какой-либо более сложные DNS-сервер (например, PowerDNS). Или установить хостинг систему (BrainyCP, ISPanel, VestaCP и другие) и уже в ней настраивать DNS череp панель управления хостингом.</p>
			<p>Любой выбранный вариант можно установить как напрямую в сервер, т.е. посредством пакетного менеджера из репозиториев, так и в docker или podman контейнер.</p>
			<p>Если хотите узнать о настройке DNS сервиса в хостинг панели <b>VestaCP</b> - то вам <a href="https://www.ukraine.com.ua/wiki/vps/panels/vesta/dns-service/"><b>&laquo;Сюда&raquo;</b></a>. Однако, данные DNS настройки будут по сути одинаковыми для любой подобной панели управления. Всё что изменится - расположение настроек для разных панелей.</p>
			<p><b>В данном цикле уроков мы не будем с вами рассматривать настройку собственных DNS-зон, делегирование прав и прочих подобных настроек. Мы рассмотрим с вами более простую задачу - в случае когда, вам нужен простой DNS-сервер, спрятанный за VPN.</b></p>
			<p>Роль такого сервера достаточно проста - либо перенаправлять запросы из одного места в другое, либо перезаписывать (фильтровать) определенные виды запросов для закрытого доступа, т.е. доступа только за VPN, не ограниченного с какой-либо другой стороны или если вам необходим доступ к определенным внутренним сервисам между организациями и вы не хотите или не можете выставлять их в инернет.</p>
			<p>Зачем в принципе ставить DNS-сервер внутри VPN - вопрос одновременно и простой и сложный.</p>
			<p>Дело в том, что systemd-resolved перенаправляет запросы только для физических интерфейсов. Когда запрос приходит от виртуального интерфейса - например, wireguard-а, то резолвер по сути не знает что с этим запросом делать. Даже если у вас будут настроены все разрешения на проход трафика в обоих направлениях и указан первичный dns 127.0.0.1 - в системе всё равно запрещена обработка запросов с виртуальных интерфейсов. Когда же у вас установлен любой dns-сервер и в резолвере указан адрес этого сервера - резолвер понимает что не важно откуда пришёл запрос - даже если с виртуального интерфейса- его обязательно надо сначала отправить в этот dns-сервер. А уже DNS-сервер разрешает системе обрабатывать полученные запросы, например перенаправить на другой dns-сервер или обработать самому.</p>
			<p>Здесь мы рассмотрим с вами 2 варианта - простейший bind9 как наименее требовательный и простой в настройке, так и AdGuard фильтр рекламы, установленный в docker-контейнер.</p>
			<p>Самое забавное в том, что AdGuard по сути не совсем фильтр рекламы - это скорее навороченный малоуправляемый DNS-сервер. Почему малоуправляемый сейчас расскажу.</p>
			<p>У него есть меню, где вы можете настроить свой собственный список dns-адресов к которым AdGuard может в процессе работы обращатья. Точно также как и systemd-resolved со своим списком dns-адресов. <br>В нём также есть масса различных уже готовых фильтров рекламы и плохого контента. Вы вполне можете добавить собственные фильтры или написать свои. <br>У него ещё масса полезных настроек, но нас интересуют ресурсные записи. Да, у AdGuard-а есть такая настройка, но она весьма скудная и сильно ограниченная, т.е. много в ней не настроишь. Даже в bind9 куда больше возможностей.</p>
			<p>Но это 2 наиболее простых в использовании и настройке DNS-сервера, которые помогут значительно упростить вам жизнь.</p>
			<p>А теперь повогорим о недостатках таких dns-серверов, прежде, чем приступить к установке и настройке.</p>
			<p>Недостаток у каждого свой. У Bind9 - все ресурсные записи и настройки зон храняться в текстовых файлах, а не полноценной базе данных. У AdGuard необходимость установки и настройки веб-панели управления. Самый большой недостаток - у обоих утилит не выйдет как-либо ускорить процесс получения let'sencrypt-сертификатов. У них нет никакого API, чтобы можно было скопировать ключ доступа и вставить в сервис автоматического перезапроса сертификатов. Вам, скорее всего, придётся проделывать ручные настройки ресурсных записей для подтверждения владения тем или иным доменом - в случае если ваш DNS-сервер будет использовать некие собственные доменные зоны. Если вам доменные зоны не нужны - то это великолепные сервера, которые решат большинство ваших задач.</p>
			<p>К слову о bind9 - у него куда больше возможностей, чем есть в интернете, но настривается он куда более нудно, долго и порой сложно.</p>
			<p><span style="color:red;"><b>Обратите внимание!</b></span></p>
			<p><b>Вместе разные dns-сервера работать не будут - только один - тот который выберите.</b></p>
			<h4>AdGuard.</h4>
			<p>Начнем с AdGuard-а, как с наиболее интересного, но наиболее требовательного. Ибо съедает он немало оперативной памяти. Но, взамен практически половина контента будет у вас без мусора и мелкого вредоноса.</p>
			<p>Устанавливать будем в docker-контейнер. Можете конечно установить и напрямую, но я бы всё-таки рекомендовал ставить в docker. Так управлять им будет значительно проще, да и в случае проблем - избавиться от него будет в разы легче, чем когда вы установите его напрямую из того или иного репозитория.</p>
			<p>Итак, создадим папку, запишем в неё docker-compose.yml файлик и запустить контейнер. Обратите внимание, что контейнер будет создавать новую docker-подсеть. Поэтому если у вас запущен Firewalld и Fail2ban - рекомендую их временно выключить. После запуска, вновь включите, посмотрите на сеть, чтобы узнать новые имена интерфейсов и добавить их в зону internal вашего фаервола.</p>
			<p>Для начала давайте временно выключим фаервол, и запустим AdGuard.</p>
			<div class="codeses">
				<pre>
<b>$ sudo systemctl stop fail2ban.timer && sudo systemctl stop fail2ban</b>
<b>$ sudo systemctl stop firewalld.timer && sudo systemctl stop firewalld</b>
<b>$ mkdir adguard && cd adguard && nano docker-compose.yml</b>

version: "3"
services:

  adguardhome:
    image: adguard/adguardhome
    container_name: adguardhome
    ports:
      - "53:53/tcp" # DNS
      - "53:53/udp" # DNS
      - "853:853/tcp" # DNS
      - "853:853/udp" # DNS
      - "3123:3000/tcp" # DashBoard Setup, do not change 80
      - "5449:5443/tcp"
      - "3080:80/tcp"
      - "3443:443/tcp"
    volumes:
      - ./workdir:/opt/adguardhome/work
      - ./confdir:/opt/adguardhome/conf
    restart: unless-stopped
    networks:
      adguard_net:
        ipv4_address: 172.20.0.2

networks:
  adguard_net:
    driver: bridge
    ipam:
     config:
       - subnet: 172.20.0.0/16
         gateway: 172.20.0.1

<span style="color:blue;"># Сохраняем и выходим</span>
<b>CTRL + o</b>
<b>CTRL + x</b>
<span style="color:blue;"># Запускаем, ждем пока скачается и запуститься.</span></pre>
			</div>
			<p>Если контейнер не запускается просто перезапустите docker-сервис. сли у вас сервисов много - ждать придётся долго. Вот поэтому podman лучше. Там всё не зависит от одного сервиса.</p>
			<p class="codes">
				$ sudo systemctl restart docker
			</p>
			<p>Посмотрим на и отыщем новые появившиеся docker-сети.</p>
			<p class="codes">
				$ ip a</br>
				$ /usr/sbin/ifconfig
			</p>
			<p>Теперь можно запустить Firewalld и Fail2ban.</p>
			<div class="codeses">
				<pre>
<span style="color:blue;"># Запускаем firewalld и fail2ban</span>
<b>$ sudo systemctl start fail2ban</b>
<b>$ sudo systemctl start firewalld</b>
<span style="color:blue;"># Добавляем новые сети в зону internal фаервола</span>
<b>$ sudo firewall-cmd --permanent --zone=internal --add-interface=new-interface</b>
<span style="color:blue;"># Перезагружаем правила</span>
<b>$ sudo firewall-cmd --reload</b>
<span style="color:blue;"># и проверяем что получилось</span>
<b>$ sudo docker ps</b>
<b>$ sudo firewall-cmd --info-zone=internal</b></pre>
			</div>
			<p>Теперь рассмотрим контейнер с AdGuard подробнее.</p>
			<ol>
				<li><b>DNS расположены на стандартных портах</b> - 53/tcp, 53/udp, 853/tcp и 853/udp.</li>
				<li><b>Утилита имеет вполне статичный ip-адрес и не просто так - 172.20.0.2.</b></li>
			</ol>
			<p>Если у вас VPS сервер - подключитесь к серверу по ssh и в зону с wireguard-ом временно добавьте несколько портов - 3123 и 3080. Первый будет использован только для установки и настройки панели управления AdGuard-ом, а второй будет постояно использовать для входа в саму панель.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=mywg --add-port=3123/tcp <br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-port=3080/tcp <br>
				$ sudo firewall-cmd --reload
			</p>
			<p>После этого можете подключаться к серверу через wireguard и получить доступ к панели за VPN - в браузере, примерно так: 10.10.10.1:3123 или 10.10.10.1:3080 - зависит от того - какой пул адресов вы использовали в вашей wireguard настройке.</p>
			<p>После установки панели удалить один лишний порт можно так:</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=mywg --remove-port=3123/tcp <br>
				$ sudo firewall-cmd --reload
			</p>
			<p>Далее настроим systemd-resolved и всё готово. А именно - заменим первичный и запасные dns-адреса.</p>
			<p><u>Вот зачем нужен был статичный ip-адрес для сетевого интерфейса AdGuard. Чтобы заставить systemd-resolved прежде всего обращаться именно к AdGuard-у, и только после этого на запасные dns-адреса.</u></p>
			<p class="codes">
				<b>$ sudo nano /etc/systemd/resolved.conf.d/dns_servers.conf</b></br></br>
				...<br>
				DNS=172.20.0.2<br>
				FallbackDNS=8.8.8.8 8.8.4.4 77.88.8.8 77.88.8.1<br>
				...<br><br>
				<span style="color:blue;"># Сохраняем</span><br>
				<b>CTRL + o</b><br>
				<b>CTRL + x</b><br>
				<span style="color:blue;"># Перезагружаем systemd-resolved</span><br>
				<b>$ sudo systemctl restart systemd-resolved</b><br>
				<span style="color:blue;"># Проверяем</span><br>
				<b>$ sudo resolvectl status</b>
			</p>
			<p><b>Однако, это далеко не все настройки, которые надо сделать!</b> В данном случае используется firewalld. Но вы вполне можете использовать и ufw.</p>
			<p>Чтобы DNS-сервер заработал, ещё необходимо настроить фаервол - разрешить dns-порты в той или иной зоне, чтобы запросы могли быть разрешены на нужном вам интерфейсе и + также внести в таблицу маршрутизации <b>INPUT</b> разрешение на пропуск трафика по данным портам в вашу систему.</p>
			<p>В пункте <a href="file:///home/mikl/git-ssh/Articles/The-security-of-network-connections.html#part4.2">&laquo;по настройке firewalld&raquo;</a> мы разрешили в зоне на входном интерфейсе из интернета и в зоне на wireguard-е наименования определенных сервисов, таким образом разрешая трафику проходить в одну и в другую сторону по VPN тунелю. Т.к. это были наименования сервисов - то мы разрешили стандартные порты. Если бы у вас вдруг эти стандартные порты поменялись - то вам необходимо было бы добавлять в ваш фаервол конкретно сами порты и протоколы этих портов.</p>
			<p>В данном случае, чтобы добавить dns-порты - мы также будем использовать наименования сервисов, т.е. стандартные порты этих сервисов. Если бы я изменил любой из этих портов - я бы обязательно прописывал бы сами порты и их протоколы.</p>
			<p>Разрешим проход dns-трафика в зоне с wireguard-интерфейсом.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=dns</br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=mdns</br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=dns-over-tls</br>
				$ sudo firewall-cmd --reload
			</p>
			<p>Теперь внесем в таблицу маршрутизации <b>INPUT</b> необходимые разрешения через <b>Firewalld</b>.</p>
			<p class="codes">
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p tcp --dport 53 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p udp --dport 53 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p udp --dport 5353 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p tcp --dport 853 -j ACCEPT</br></br>
				<span style="color:blue;"># При редактировании правил машрутизации обязательно перезагружаем весь фаервол</span></br>
				$ sudo systemctl restart firewalld</br></br>
				<span style="color:blue;"># И смотрим на добавленные правила маршрутизации</span></br>
				$ sudo firewall-cmd --direct --get-all-rules
			</p>
			<p>Теперь необходимо перенастроить wireguard конфигурацию. Т.к. у нас используется firewalld - то правила фильтрации уже внесены и в конфигурации они выключены. Соответственно мы вполне можем вместо них вписать строку, чтобы wireguard отправлял все dns-запросы на определенный ip-адресс.</p>
			<p>Да вы могли бы без установки DNS-сервера просто указать такую настройку и полноценно пользоваться wireguard-ом. Однако, дело в том, что тогда ваш трафик будет не совсем полностью за VPN - он просто будет перенаправляться и тогда запросы будут видны уже провайдеру VPS сервера. Лучше если их будет обрабатывать сам сервер и решать где DNSSEC или DNSOverTLS нужны а где нет.</p>
			<p class="codes">
				<b>$ sudo chmod u=rwx,go= /etc/wireguard/wg0.conf</b></br>
				<b>$ sudo nano /etc/wireguard/wg0.conf</b><br><br>
				...<br>
				PostUp = resolvectl dns %i 10.10.10.1; resolvectl domain %i ~.<br>
				...<br><br>
				<b>CTRL + o</b><br>
				<b>CTRL + x</b><br>
				<b>$ sudo systemctl restart wg-quick@wg0</b>
			</p>
			<p>Естественно не забудьте указать свой ip-адрес, используемый wireaguard-ом.</p>
			<p>Вот теперь точно всё! Можете переподключаться к вашему серверу через wireguard, заходить в веб-интерфейс AdGuard и проверять как работает фильтрация.</p>
			<h4>Bind9.</h4>
			<p>Если у вас мало оперативной памяти - например VPS сервер, то вам может и не подойти AdGuard. Тогда можно настроить простейший Bind9 DNS-сервер Если вы не читали предыдущий пункт - сделаем повтор некоторый под-пунктов - они здесь также сильно важны.</p>
			<p>Давайте также как и при настройке AdGuard-а - сразу настроим фаервол и внесем правила маршрутизации - чтобы не просто пропустить трафик через фаервол, но и разрешить серверу обрабатывать этот трафик. А вот что с трафиком делать дальше - решать будет сам DNS-сервер.</p>
			<p class="codes">
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=dns</br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=mdns</br>
				$ sudo firewall-cmd --permanent --zone=mywg --add-service=dns-over-tls</br>
				$ sudo firewall-cmd --reload</br></br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p tcp --dport 53 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p udp --dport 53 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p udp --dport 5353 -j ACCEPT</br>
				$ sudo firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 1 -p tcp --dport 853 -j ACCEPT</br></br>
				<span style="color:blue;"># При редактировании правил машрутизации обязательно перезагружаем весь фаервол</span></br>
				$ sudo systemctl restart firewalld</br></br>
				<span style="color:blue;"># И смотрим на добавленные правила маршрутизации</span></br>
				$ sudo firewall-cmd --direct --get-all-rules
			</p>
			<p>Установим <b>bind9</b> и сделаем несколько настроек в разделе <b>&laquo;options&raquo;</b>.</p>
			<div class="codeses">
				<pre>
<b>$ sudo nano /etc/bind/named.conf.options</b>

options {
	directory "/var/cache/bind";
	...
	// allow-query     { any; };
	allow-query { 127.0.0.0/8; 10.10.10.0/24; };
	...
	listen-on-v6 { any; };
	listen-on { 127.0.0.0/8; 10.10.10.0/24; };
	// listen-on { any; };
	...

<b>CTRL + o</b>
<b>CTRL + x</b></pre>
			</div>
			<p>В данном случае мы внесли всего 4 строки:</p>
			<ul>
				<li>// allow-query     { any; };</li>
				<li>allow-query { 127.0.0.0/8; 10.10.10.0/24; };</li>
				<li>listen-on { 127.0.0.0/8; 10.10.10.0/24; };</li>
				<li>// listen-on { any; };</li>
			</ul>
			<p>Первая разрешает dns-запросы со всех адресов. С помощью 2 слешей мы закоментировали эту настройку, чтобы она не работаала. Т.е. она записана только для того, чтобы вы знали как можно разрешить все запросы и точно также сделано с последней строкой настроек. Последнаяя строка нужна, чтобы включить прослушивание по протоколу ipv4. У каждой можно указать на каких адресах слушать или указать для всех.</p>
			<p>Вторая строка разрешает запросы с определенного пула адресов.</p>
			<p>Ну а в 3-й - прослушивать запросы с определенного пула адресов. Можно указать конкретный ip-адресс и даже через точку с запятой.</p>
			<p>Не забываем перезагрузить dns-сервер.</p>
			<p class="codes">
				$ sudo systemctl restart bind9
			</p>
			<p>Чтобы проверить работает ли dns-сервер - можно спросить систему - прослушивает ли она нужный нам порт. Например, так.</p>
			<p class="codes">
				$ sudo netstat -pna | grep 53
			</p>
			<p>Также перенастроим wireguard, перезапустим и можем проверять.</p>
			<p class="codes">
				<b>$ sudo chmod u=rwx,go= /etc/wireguard/wg0.conf</b></br>
				<b>$ sudo nano /etc/wireguard/wg0.conf</b><br><br>
				...<br>
				PostUp = resolvectl dns %i 10.10.10.1; resolvectl domain %i ~.<br>
				...<br><br>
				<b>CTRL + o</b><br>
				<b>CTRL + x</b><br>
				<b>$ sudo systemctl restart wg-quick@wg0</b>
			</p>
			<p>Естественно не забудьте указать свой ip-адрес, используемый wireaguard-ом.</p>
			<p>Вот теперь точно всё! Можете переподключаться к вашему серверу через wireguard и проверять как всё работает.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part14"></a></p>
			<h2>14. Установка и wireguard.</h2>
			<p>Наступило время, когда VPN уже не является каким-то экзотическим инструментом бородатых сисадминов. Задачи у пользователей разные, но факт в том, что VPN стал нужен вообще всем.</p>
			<p>Проблема текущих VPN решений в том, что их тяжело правильно настроить, дорого обслуживать, а так же в них полно legacy кода сомнительного качества.</p>
			<p><b>WireGuard</b> — это современный протокол для организации <b>VPN</b>, написанный с нуля, бесплатный и с открытыми исходными кодами. В отличие от &laquo;мастодонтов&raquo; вроде <b>OpenVPN</b> или <b>IPSec</b>, он намного проще и легче. Это касается и скорости (пере)подключения, и производительности, и требований к ресурсам, и процесса настройки, и объёма кода. Недавно было объявлено, что <b>WireGuard</b> войдёт в состав будущих ядер <b>Linux</b>, а впоследствии попадёт и во все популярные дистрибутивы, что косвенно указывает на зрелость этого решения.</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part15"></a></p>
			<h2>15. Docker, docker-compose.</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part16"></a></p>
			<h2>16. Podman, Podman-compose, Cockpit.</h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
