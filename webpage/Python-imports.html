<html>
<head>
	<meta charset="utf-8">
	<title>Hogwarts в Python</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-favicon.png">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/img.css" type="text/css">
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Hogwarts в Python</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-logo.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h1>Python - волшебный импорт или как не споткнуться о pathlib.</h1>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Введение</a></li>
				<ol>
					<li><a href="#part1_1">Предисловие</a></li>
					<li><a href="#part1_2">Введение</a></li>
				</ol>
				<li><a href="#part2">Структура &laquo;проекта-примера&raquo;</a></li>
				<li><a href="#part3">Cодержимое файлов &laquo;проекта-примера&raquo;</a></li>
				<ol>
					<li><a href="#part3_1">Пакет: compatible</a></li>
					<li><a href="#part3_2">Под-пакет: subpackage_a</a></li>
					<li><a href="#part3_3">Под-пакет: subpackage_b</a></li>
				</ol>
				<li><a href="#part4">Импорт пакетов</a></li>
				<ol>
					<li><a href="#part4_1">Как работает импорт?</a></li>
					<li><a href="#part4_2">Абсолютные и относительные пути</a></li>
				</ol>
				<li><a href="#part5">Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></a></li>
				<li><a href="#part6">Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</a></li>
				<ol>
					<li><a href="#part6_1">Введение в pathlib.</a></li>
					<li><a href="#part6_2">Примеры использования pathlib на практике.</a></li>
					<ol>
						<li><a href="#part6_2_1">Базовое имя пути</a></li>
						<ol>
							<li><a href="#part6_2_1_1">Имя файла</a></li>
							<li><a href="#part6_2_1_2">Базовые директории</a></li>
						</ol>
						<li><a href="#part6_2_2">Расширение файла</a></li>
						<li><a href="#part6_2_3">Абсолютный и относительные пути</a></li>
						<li><a href="#part6_2_4">Соединение путей</a></li>
						<li><a href="#part6_2_5">Права доступа</a></li>
						<ol>
							<li><a href="#part6_2_5_1">Права доступа (chmod)</a></li>
							<li><a href="#part6_2_5_2">Смена владельца и/или группы (os.chown)</a></li>
							<li><a href="#part6_2_5_3">Смена владельца и/или группы (shutil.chown)</a></li>
						</ol>
						<li><a href="#part6_2_6">Создание файлов и папок</a></li>
						<ol>
							<li><a href="#part6_2_6_1">Чтение и Запись файлов</a></li>
							<li><a href="#part6_2_6_2">Создание файлов и каталогов</a></li>
							<li><a href="#part6_2_6_3">Жесткие и символьные ссылки</a></li>
						</ol>
						<li><a href="#part6_2_7">Переименование файлов и папок</a></li>
						<li><a href="#part6_2_8">Перемещение файлов и папок</a></li>
						<li><a href="#part6_2_9">Удаление файлов и папок</a></li>
						<li><a href="#part6_2_10">Рекурсивные операции</a></li>
					</ol>
				</ol>
				<li><a href="#part7">Немного <span style="color:Red;">&laquo;unittest&raquo;</span></a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h1>Введение</h1>
			<p><a name="part1_1"></a></p>
			<h2>Предисловие.</h2>
			<p>Для всех тестов и примеров для условий наиболее приближенных к реальным я буду использовать виртуальную машину с <b>Debian 10</b>, и 2 мя <b>SHELL</b>-ами: <b>Fish (Default)</b> и <b>Bash</b> и <b>Python 3.10</b>.</p>
			<p><b>Fish</b> используется только для удобства - у него прекрасное автозавершение команд, а также их цветная подсветка.</p>
			<p>Пользователь также использован временный.</p>
			<p>Виртуальное окружение для подобных тестов не требуется.</p>
			<hr class="hr_chapter">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<p><a name="part1_2"></a></p>
			<h2>Введение.</h2>
			<p>При создании любого <i>python-проекта</i> или одиночного скрипта с кодом мы часто пользуемся импортом, не совсем понимая или не помня, как именно он работает. В связи с чем, иногда могут возникать казусы и непредвиденные ситуации, которые порой сложно решить даже с использованием <i>&laquo;Google&raquo;</i> поиска.</p>
			<p>Сегодня моя задача объяснить почему возникают ошибки импорта пакетов или модулей, а также рассказать сложные темы простыми словами.
			Темы нашего сегодняшнего разговора очень простые, не смотря на то, что кажутся жутко сложными на первый взгляд. Однако, даже не углубляясь глубоко в дебри языка можно легко прийти к выводу - что любая задача решается очень легко.</p>
			<p>Даже если мы не знаем какая библиотека сможет решить ту или иную задачу, мы всегда должны понимать что способов решений может быть много, а может быть ни одного. В любом случае каждый раз вам придётся не только искать то или иное решение, но и искать его самостоятельно. Порою вы сможете найти сразу готовое решение и оно вам подойдет. <b>Однако, так будет не всегда.</b></p>
			<p>В любом случае вам нужно опираться на несколько базовых понятий:</p>
			<ol>
				<li>Какой нужен результат ?</li>
				<li>Решается ли задача, хотя бы на бумаге ?</li>
				<li>Алгоритмизация решения.</li>
			</ol>
			<p><b>Допустим</b>, вы уже решили ту или иную объемную задачу на бумаге, создали не только алгоритм решения, но и создали собственный python-пакет для обработки подобных задач в будущем.</p>
			<p>После этого вам наверняка понадобится протестировать свой пакет не только на ошибки, но и на избыточность кода, а также соблюдение отступов, синтаксиса и многого другого.</p>
			<p>Вы конечно можете создать отдельный файл скрипта, например &laquo;test.py&raquo; в конкретной директории вашего пакета и протестировать модуль или метод модуля отдельно, так сказать, вручную. <b>Однако, это мягко говоря неудобно!</b></p>
			<p>Для каждого модуля вам придётся мучиться не только с отдельными скриптами-тестами, но с импортом своих модулей в этих скриптах. Мало того, эти файлы-тесты будут включены в ваш пакет и мешать вам отлаживать его работу.</p>
			<p>Не говоря уже про попытку теста всего пакета в целом, ведь в этом случае - относительный импорт не работает и вам придется переместить ваш тест-скрипт на директорию выше, а может и вообще перед директорией вашего пакета. И так будет с каждым скриптом-тестом.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.1.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №1" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.2.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №2" />
			</div>
			<p>В результате вам всё-таки придётся создать отдельную директорию для тестирования своего кода, в которой вы и будете хранить все <b>скрипты-тесты</b> вашего кода.</p>
			<p><b><span style="color:Green;">Это как раз правильный подход!</span> Однако, есть нюансы.</b></p>
			<p>Вот тут то и начинается вся магия <b>&laquo;Абры-Кадабры&raquo;</b> с импортом, т.к. в этом случае <span style="color:Red;">относительный импорт - не работает!</span></p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.3.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №3" />
			</div>
			<p>Что же тогда делать и как решить такую задачу?</p>
			<p><span style="color:Green;">Всё решается буквально 1...2 строчками кода </span> <b>-</b> <span style="color:Red;">но их необходимо понимать, чтобы применять правильно.</span></p>
			<p><b>Но - обо всём по порядку!</b></p>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h1>Структура &laquo;проекта-примера&raquo;</h1>
			<h2>Общая структура.</h2>
			<p>Для примера пусть будет следующая структура проекта.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-1.png" class="fz__minimized" alt="клик для увеличения" title="Strukture Project" />
			</div>
			<div class="codeses">
				<pre>
.
└── pkg
    ├── compatible
    │   ├── functions.py
    │   ├── __init__.py
    │   ├── subpackage_a
    │   │   ├── a.py
    │   │   └── __init__.py
    │   ├── subpackage_b
    │   │   ├── b.py
    │   │   ├── __init__.py
    │   │   └── test-pathlib-1.py
    │   └── test.py
    ├── test.py
    └── tests
        ├── __init__.py
        ├── test-abs-path.py
        ├── test-pathlib-1.py
        ├── test-pathlib-2.py
        ├── test-pkg-simple.py
        ├── test.py
        └── tmp.txt</pre>
			</div>
			<br>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h1>Cодержимое файлов &laquo;проекта-примера&raquo;</h1>
			<p>Определим содержимое всех указанных файлов-проекта. Для примера, пусть будет следующим.</p>
			<p><a name="part3_1"></a></p>
			<p>Пакет: <b>compatible</b></p>
			<p>Файл: <b>pkg/compatible/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .functions <span style="color:#069;"><b>import *</b></span></br>
				<span style="color:#069;"><b>from</b></span> .subpackage_a <span style="color:#069;"><b>import *</b></span></br>
				<span style="color:#069;"><b>from</b></span> .subpackage_b <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл: <b>pkg/compatible/functions.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getDateTimeStr'</span>]

<span style="color:#069;"><b>from</b></span> datetime <span style="color:#069;"><b>import</b></span> datetime

<span style="color:#069;"><b>def</b></span> getDateTimeStr(strFormat = <span style="color:Blue;">"%d.%m.%Y-%H:%M:%S"</span>) -> <span style="color:#ff1493;">str</span>:
	dateTime = datetime.now()
	outDateTime = dateTime.strftime(strFormat)
	<span style="color:#069;"><b>return</b></span> outDateTime</pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part3_2"></a></p>
			<p>Под-пакет: <b>subpackage_a</b></p>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .a <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/a.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getPackageA'</span>]

<span style="color:#069;"><b>from</b></span> ..functions <span style="color:#069;"><b>import *</b></span>

<span style="color:#069;"><b>def</b></span> getPackageA():
	<span style="color:#069;"><b>return</b></span> <span style="color:Blue;">'Package A:'</span> + getDateTimeStr()</pre>
			</div>
			<hr class="hr_chapter">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part3_3"></a></p>
			<p>Под-пакет: <b>subpackage_b</b></p>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/__init__.py</b></p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> .b <span style="color:#069;"><b>import *</b></span>
			</p>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/b.py</b></p>
			<div class="codeses">
				<pre>
__all__ = [<span style="color:Blue;">'getPackageB'</span>]

<span style="color:#069;"><b>from</b></span> ..functions <span style="color:#069;"><b>import *</b></span>

<span style="color:#069;"><b>def</b></span> getPackageB():
	<span style="color:#069;"><b>return</b></span> <span style="color:Blue;">'Package B:'</span> + getDateTimeStr()</pre>
			</div>
			<hr class="hr_main">
			<p><a href="#part3">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
		</div>
		<div class="content">
			<p><a name="part4"></a></p>
			<h1>Импорт пакетов</h1>
			<p><a name="part4_1"></a></p>
			<h2>Как работает импорт?</h2>
			<p>При относительном импорте в пакете мы обращаемся к заданному каталогу относительно текущего. Тогда почему при запуске скрипта мы всё равно не можем импортировать пакет или модуль пакета на уровень выше?</p>
			<p><b>Это немного ошибочное мнение.</b></p>
			<p>Дело в том, что модуль внутри пакета - по команде <i>import</i> или <i>from</i> обращается относительно себя. Между модулями или между пакетами такое относительное обращение вполне нормальное явление.</p>
			<p>Например, находясь в одном из подкаталогов пакета <i>compatible</i>: <b>from ..compatible.functions import getDateTimeStr</b></p>
			<p>При простом запуске скрипта, т.е. исполняемого файла, по команде <i>import</i> или <i>from</i> Python ищет пакеты по заданному наименованию в каталогах, которые заданны в <b>sys.path</b>. Относительного импорта при запуске python-скрипта нет. Поэтому при попытке относительного импорта в запускаемом скрипте мы видим различные ошибки.</p>
			<p><span style="color:Red;">Т.е. в запускаемом файле при импорте необходимо указывать именно наименование модуля, в то время как внутри пакета в модулях при импорте необходимо соблюдать относительность путей.</span></p>
			<p>Например: <b>import pathlib</b>, или <b>from pathlib import Path</b>.</p>
			<p>Оказывается, просто, необходимо добавить директорию родителя в данную переменную среды.</p>
			<p><b>Однако, остаётся ещё один вопрос:</b> <span style="color:Blue;">А какой именно каталог необходимо добавить: ../, ./ или абсолютный путь ?</span></p>
			<p>Давайте узнаем всё это на практике.</p>
			<p>Сначала добавим относительный путь и посмотрим - появился ли он в <b>sys.path</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> sys</br>
				sys.path.append(<span style="color:Blue;">'../'</span>)
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.4.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №4" />
			</div>
			<p>Есть.</p>
			<p>Теперь попробуем импортировать наш модуль.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.5.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №5" />
			</div>
			<p>Хм, ошибка. Может неправильно указали относительную директорию? Давайте попробуем с помощью модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.6.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №6" />
			</div>
			<p>Опять ошибка. Может опять относительность импорта указали не верно? Попробуем ещё раз.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.7.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №7" />
			</div>
			<p>Хм, снова ошибка.</p>
			<p><u>Однако, здесь не всё так просто, как показалось на первый взгляд.</u></p>
			<p><b>Давайте разбираться!</b></p>
			<hr class="hr_chapter">
			<p><a href="#part4">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part4_2"></a></p>
			<h2>Абсолютные и относительные пути.</h2>
			<p>Давайте сначала посмотрим как получить полную директорию из относительной при помощи того же модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-3.png" class="fz__minimized" alt="клик для увеличения" title="Относительные и абсолютные пути" />
			</div>
			<p>Хорошо. С директориями разобрались.</p>
			<p>Есть такая встроенная переменная как &laquo;<b>__file__</b>&raquo;. Она указавает на текущий скрипт.</p>
			<p>Добавим новый путь поиска пакетов и попробуем импортировать наш пакет. Заодно посмотрим на пространстфо имен запускаемого скрипта, а также пространство имен импортируемого модуля. Если всё получится в консоль будут выведены все указанные значения.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>import</b></span> pathlib
<span style="color:#069;"><b>import</b></span> sys

sys.path.append(<span style="color:#ff1493;">str</span>(pathlib.Path(__file__).resolve().parent.parent))

<span style="color:#069;"><b>def</b></span> main():
	<span style="color:#069;"><b>for</b></span> i <span style="color:#069;"><b>in</b></span> sys.path:
		<span style="color:#ff1493;">print</span>(i)
	<span style="color:#069;"><b>import</b></span> compatible
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(sys.modules[__name__]))
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(compatible), <span style="color:Blue;">'\n'</span>)
	<span style="color:#ff1493;">print</span>(compatible.getPackageA())
	<span style="color:#ff1493;">print</span>(compatible.getPackageB())

if __name__ == <span style="color:Blue;">'__main__'</span>:
	main()</pre>
			</div>
			<p>Смотрим на результат.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-7.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.append" />
			</div>
			<p><span style="color:Green;">Ура! Заработало!</span></p>
			<p><span style="color:Brown;">Однако, такой способ добавления не совсем правильный!</span> Однако, вполне рабочий.</p>
			<p>Обратите внимание на то, что необходимый путь поиска добавился в последнюю строку в &laquo;<b>sys.path</b>&raquo;.</p>
			<p>Таким образом, <b>Python</b> сначала переберет все остальные пути поиска, и только в последнюю очередь будет обращаться к вашей заданной директории.</p>
			<p>Лучшим решением, будет - добавление вашей директории на первое место. С этим как раз и поможет метод <b>insert</b>.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>import</b></span> pathlib
<span style="color:#069;"><b>import</b></span> sys

sys.path.insert(<span style="color:Green;">0</span>, <span style="color:#ff1493;">str</span>(pathlib.Path(__file__).resolve().parent.parent))

<span style="color:#069;"><b>def</b></span> main():
	<span style="color:#069;"><b>for</b></span> i <span style="color:#069;"><b>in</b></span> sys.path:
		<span style="color:#ff1493;">print</span>(i)
	<span style="color:#069;"><b>import</b></span> compatible
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(sys.modules[__name__]))
	<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">dir</span>(compatible), <span style="color:Blue;">'\n'</span>)
	<span style="color:#ff1493;">print</span>(compatible.getPackageA())
	<span style="color:#ff1493;">print</span>(compatible.getPackageB())

if __name__ == <span style="color:Blue;">'__main__'</span>:
	main()
				</pre>
			</div>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-8.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.insert" />
			</div>
			<br>
			<hr class="hr_main">
			<p><a href="#part4">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
		</div>
		<div class="content">
			<p><a name="part5"></a></p>
			<h1>Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></h1>
			<p>Не все пары функций/методов ниже эквивалентны. Некоторые из них частично совпадают, некоторые имеют разную семантику. К ним относятся <i>os.path.abspath()</i> и <i>Path.resolve()</i>, <i>os.path.relpath()</i> и <i>Path.relative_to()</i>.</p>
			<p>Функция <i>os.path.abspath()</i> не разрешает символические ссылки, в то время как <i>Path.resolve()</i> это делает.</p>
			<p>Метод <i>Path.relative_to()</i> требует, чтобы путь <i>pathlib.Path</i> был подпутем аргумента, однако, <i>os.path.relpath()</i> этого не требует.</p>
			<p>Подробные примеры использования разберем в следующей главе.</p>
			<table>
				<caption>Эквивалентные функции модулей.</caption>
				<tr>
					<th>Функции модулей os и os.path</th>
					<th>Функции модуля pathlib</th>
				</tr>
				<tr>
					<td>os.path.abspath()</td>
					<td>Path.resolve()</td>
				</tr>
				<tr>
					<td>os.chmod()</td>
					<td>Path.chmod()</td>
				</tr>
				<tr>
					<td>os.mkdir()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.makedirs()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.rename()</td>
					<td>Path.rename()</td>
				</tr>
				<tr>
					<td>os.replace()</td>
					<td>Path.replace()</td>
				</tr>
				<tr>
					<td>os.rmdir()</td>
					<td>Path.rmdir()</td>
				</tr>
				<tr>
					<td>os.remove(), os.unlink()</td>
					<td>Path.unlink()</td>
				</tr>
				<tr>
					<td>os.getcwd()</td>
					<td>Path.cwd()</td>
				</tr>
			    <tr>
			        <td>os.path.exists()</td>
			        <td>Path.exists()</td>
			    </tr>
				<tr>
					<td>os.path.expanduser()</td>
					<td>Path.expanduser() и Path.home()</td>
				</tr>
				<tr>
					<td>os.listdir()</td>
					<td>Path.iterdir()</td>
				</tr>
				<tr>
					<td>os.path.isdir()</td>
					<td>Path.is_dir()</td>
				</tr>
				<tr>
					<td>os.path.isfile()</td>
					<td>Path.is_file()</td>
				</tr>
				<tr>
					<td>os.path.islink()</td>
					<td>Path.is_symlink()</td>
				</tr>
				<tr>
					<td>os.link()</td>
					<td>Path.hardlink_to()</td>
				</tr>
				<tr>
					<td>os.symlink()</td>
					<td>Path.symlink_to()</td>
				</tr>
				<tr>
					<td>os.readlink()</td>
					<td>Path.readlink()</td>
				</tr>
				<tr>
					<td>os.path.relpath()</td>
					<td>Path.relative_to()</td>
				</tr>
				<tr>
					<td>os.stat()</td>
					<td>Path.stat(), Path.owner(), Path.group()</td>
				</tr>
				<tr>
					<td>os.path.isabs()</td>
					<td>PurePath.is_absolute()</td>
				</tr>
				<tr>
					<td>os.path.join()</td>
					<td>PurePath.joinpath()</td>
				</tr>
				<tr>
					<td>os.path.basename()</td>
					<td>PurePath.name</td>
				</tr>
				<tr>
					<td>os.path.dirname()</td>
					<td>PurePath.parent</td>
				</tr>
				<tr>
					<td>os.path.samefile()</td>
					<td>Path.samefile()</td>
				</tr>
				<tr>
					<td>os.path.splitext()</td>
					<td>PurePath.suffix</td>
				</tr>
			</table>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part6"></a></p>
			<h1>Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</h1>
			<p><a name="part6_1"></a></p>
			<h2>Введение в pathlib.</h2>
			<p>Каждая операционная система имеет разные правила построения путей к файлам. Например, Linux использует прямые косые черты для путей, в то время как Windows использует обратную косую черту.</p>
			<p>Это небольшое различие может вызвать проблемы, если вы работаете над проектом и хотите, чтобы другие разработчики из разных операционных систем расширили ваш код.</p>
			<p>К счастью, если вы пишете на Python, модуль Pathlib выполняет тяжелую работу, позволяя вам убедиться, что ваши пути к файлам работают одинаково в разных операционных системах. Кроме того, он предоставляет функциональные возможности и операции, которые помогут вам сэкономить время при обработке и манипулировании путями.</p>
			<p>Откройте файл, например main.py и введите следующее содержимое:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>
				p = pathlib.Path(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(p), <span style="color:Blue;">':'</span>, p)
			</p>
			<p>Сохраните и запустите. У меня вывод получился следующий:</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'pathlib.PosixPath'&#8250; : /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p>Как показано выше, Pathlib создает путь к этому файлу, помещая этот конкретный скрипт в объект Path. Pathlib разделяет пути файловой системы на два разных класса, которые представляют два типа объектов path: чистый путь и конкретный путь.</p>
			<div class="imageClear">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/pathlib-diagram.png" width="512px" />
			</div>
			<p>Чистый путь предоставляет утилиты для обработки и управления вашим путем к файлу без выполнения операций записи, в то время как конкретный путь позволяет вам манипулировать и выполнять операции записи в вашем пути к файлу.</p>
			<p>Другими словами, конкретный путь является подклассом чистого пути. Он наследует манипуляции от родительского класса и добавляет операции ввода / вывода, которые выполняют системные вызовы.</p>
			<p>Чистые пути манипулируют путем к файлу на вашем компьютере, даже если он принадлежит другой операционной системе. Например, допустим, вы работаете в Linux и хотите использовать путь к файлу Windows. Здесь объекты класса PurePath помогут вам заставить путь работать на вашем компьютере с некоторыми базовыми операциями, такими как создание дочерних путей или доступ к отдельным частям пути.</p>
			<p><b>Но чистые пути не смогут имитировать некоторые другие операции, такие как создание каталога или файла, потому что вы на самом деле не в этой операционной системе.</b></p>
			<p>Модифицируем код представленный выше и одной командой получим на выходе прежний str:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>
				p = <span style="color:#ff1493;">str</span>(pathlib.Path(__file__))<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(p), <span style="color:Blue;">':'</span>, p)
			</p>
			<p>Сохраните и запустите:</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p>Как видите преобразовать объекты типа <b>Path</b> в строку не так уж и сложно.</p>
			<hr class="hr_main">
			<p><a href="#part6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2"></a></p>
			<h2>Примеры использования pathlib на практике.</h2>
			<p>А теперь давайте сравним &laquo;pathlib&raquo; с &laquo;os&raquo; и &laquo;os.path&raquo; на практике на наиболее часто используемых методах.</p>
			<p><a name="part6_2_1"></a></p>
			<h3>Базовое имя пути</h3>
			<p><a name="part6_2_1_1"></a></p>
			<h4>Имя файла</h4>
			<p><i>Добавим в вывод дополнительную информацию, чтобы понимать какой объект мы получаем и выводем содержимое на экран.</i></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				names = os.path.basename(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(names), <span style="color:Blue;">':'</span>, names)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : main.py
				</span>
			</p>
			<p><b>А теперь тоже самое в pathlib.</b></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				filename = pathlib.Path('/path/to/somefile.txt').name<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(filename), <span style="color:Blue;">':'</span>, filename)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : somefile.txt
				</span>
			</p>
			<p>Пока неясно какой модуль лучше. Результат у обоих абсолютно одинкавый.</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_1_2"></a></p>
			<h4>Базовые директории</h4>
			<p>Как получить пути к основным директориям системы? Например, к текущей, из которой запущен скрипт и к домашнему каталогу.</p>
			<p>Рассмотрим пример 3 библиотек: <b>os</b>, <b>os.path</b> и <b>pathlib</b>.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> os.path<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br><br>

				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib:'</span>)<br>
				<span style="color:#ff1493;">print</span>(pathlib.Path.cwd())<br>
				<span style="color:#ff1493;">print</span>(pathlib.Path.home())<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os and os.path:'</span>)<br><br>

				<span style="color:#ff1493;">print</span>(os.getcwd())<br>
				<span style="color:#ff1493;">print</span>(os.path.expanduser(<span style="color:Blue;">"~"</span>))<br><br>

				<b>mikl ~/003/Primer $</b> python main.py<br><span style="color:Blue;">
				pathlib:<br>
				/home/mikl/003/Primer<br>
				/home/mikl<br>
				os and os.path:<br>
				/home/mikl/003/Primer<br>
				/home/mikl</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_2"></a></p>
			<h3>Расширение файла</h3>
			<p><b>Получаем расширение файла.</b></p>
			<p class="codes">
				<b>$</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				filename, file_extension = os.path.splitext(<span style="color:Blue;">'/path/to/somefile.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(file_extension), <span style="color:Blue;">':'</span>, file_extension)<br>
				<span style="color:Green;"># pathlib</span><br>
				file_extension = pathlib.Path(<span style="color:Blue;">'/path/to/somefile.txt'</span>).suffix<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(file_extension), <span style="color:Blue;">':'</span>, file_extension)<br><br>
				<b>$</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; : .txt<br>
					&#8249;class 'str'&#8250; : .txt
				</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_3"></a></p>
			<h3>Абсолютный и относительные пути</h3>
			<p>А теперь рассмотрим следующие методы библиотек: <b>полный путь, получение родительской директории и соединение путей.</b></p>
			<p><b>Полный путь, т.е. абсолютный путь.</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				realdir = os.path.abspath(__file__)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(realdir), realdir)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				pathdir = pathlib.Path(__file__).resolve()<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff1493;">type</span>(pathdir), pathdir)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
					&#8249;class 'str'&#8250; /home/mikl/003/Primer/main.py<br>
					&#8249;class 'pathlib.PosixPath'&#8250; /home/mikl/003/Primer/main.py
				</span>
			</p>
			<p><b>Получение родительской директории, например, на 2 уровня вверх.</b> Т.е. наименование директории, в которой находится файл, а также получить директорию на уровень вверх.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				two_up = os.path.dirname(os.path.dirname(__file__))<br>
				<span style="color:#ff1493;">print</span>(two_up)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				two_up = pathlib.Path(__file__).parent.parent<br>
				<span style="color:#ff1493;">print</span>(two_up)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				/home/mikl/003<br>
				/home/mikl/003</span>
			</p>
			<p>В <b>os.path</b> без вложенных вызовов самой библиотеки не бойтись. А вот в <b>pathlib.Path</b> такой последовательный вызов команд вполне нормальное явление.</p>
			<p><span style="color:Green;">Согласитесь - с <b>pathlib</b> код становится красивым, менее громоздким и более читабельным.</span></p>
			<p><b>Канонический путь в os.path</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				src = <span style="color:Blue;">'./pkg/test.py'</span><br>
				dst = <span style="color:Blue;">'./test.py'</span><br>
				<span style="color:Green;"># При наличии имеющейся символической ссылки на файл, необходимо её удалить</span><br>
				<span style="color:Green;"># Чтобы создание символической ссылки не вызывало исключение</span> <span style="color:#ff9933;">FileExistsError</span><br>
				os.remove(dst)<br>
				os.symlink(src, dst)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.symlink:'</span>, os.readlink(dst))<br>
				link = os.path.realpath(dst)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path.realpath:'</span>, link)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				os.symlink: ./pkg/test.py<br>
				os.path.realpath: /home/mikl/003/Primer/pkg/test.py<br></span>
			</p>
			<p><b>Вычисление относительных путей в pathlib</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				shark = pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>, <span style="color:Blue;">"fish"</span>, <span style="color:Blue;">"shark.txt"</span>)<br>
				below_ocean = shark.relative_to(pathlib.Path(<span style="color:Blue;">"ocean"</span>))<br>
				below_animals = shark.relative_to(pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>))<br>
				<span style="color:#ff1493;">print</span>(shark)<br>
				<span style="color:#ff1493;">print</span>(below_ocean)<br>
				<span style="color:#ff1493;">print</span>(below_animals)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				ocean/animals/fish/shark.txt<br>
				animals/fish/shark.txt<br>
				fish/shark.txt<br></span>
			</p>
			<p>Метод relative_to возвращает новый объект Path, относящийся к данному аргументу.</p>
			<p><b>Если relative_to не сможет вычислить ответ, он выдаст ValueError.</b></p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				shark = pathlib.Path(<span style="color:Blue;">"ocean"</span>, <span style="color:Blue;">"animals"</span>, <span style="color:Blue;">"fish"</span>, <span style="color:Blue;">"shark.txt"</span>)<br>
				shark.relative_to(pathlib.Path(<span style="color:Blue;">"unrelated"</span>, <span style="color:Blue;">"path"</span>))<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				Traceback (most recent call last):<br>
				  File "/home/mikl/003/Primer/main.py", line 4, in &#8249;module&#8250;<br>
				    shark.relative_to(pathlib.Path("unrelated", "path"))<br>
				  File "/usr/lib/python3.10/pathlib.py", line 816, in relative_to<br>
				    raise ValueError("{!r} is not in the subpath of {!r}"<br>
				<b>ValueError</b>: 'ocean/animals/fish/shark.txt' is not in the subpath of 'unrelated/path' OR one path is relative and the other is absolute.</span>
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-4.2.png" class="fz__minimized" alt="клик для увеличения" title="pathlib.Path().relative_to()" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_4"></a></p>
			<h3>Соединение путей</h3>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:Green;"># os.path</span><br>
				one = os.path.join(<span style="color:Blue;">'home'</span>, <span style="color:Blue;">'User'</span>, <span style="color:Blue;">'Desktop'</span>, <span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path'</span>, one)<br>
				<span style="color:Green;"># os.path для абсолютного пути</span><br>
				asb_one = os.path.abspath(one)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'os.path'</span>, asb_one)<br>
				<span style="color:Green;"># pathlib.Path</span><br>
				<span style="color:Green;"># Можно так</span><br>
				two = pathlib.Path(<span style="color:Blue;">'home'</span>, <span style="color:Blue;">'User'</span>, <span style="color:Blue;">'Desktop'</span>, <span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, two)<br>
				<span style="color:Green;"># Можно и так</span><br>
				troyka = pathlib.Path(<span style="color:Blue;">'home'</span>).joinpath(<span style="color:Blue;">'User'</span>).joinpath(<span style="color:Blue;">'Desktop'</span>).joinpath(<span style="color:Blue;">'file.txt'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, troyka)<br>
				<span style="color:Green;"># В pathlib для абсолюнтого пути не требуются вложенные вызовы</span><br>
				four = troyka.resolve()<br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">'pathlib'</span>, four)<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				os.path home/User/Desktop/file.txt<br>
				os.path /home/mikl/003/Primer/home/User/Desktop/file.txt<br>
				pathlib home/User/Desktop/file.txt<br>
				pathlib home/User/Desktop/file.txt<br>
				pathlib /home/mikl/003/Primer/home/User/Desktop/file.txt<br></span>
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-4.png" class="fz__minimized" alt="клик для увеличения" title="Код name, suffix, resolve, joinpath" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-5.png" class="fz__minimized" alt="клик для увеличения" title="Выполнение кода name, suffix, resolve, joinpath" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_5"></a></p>
			<h3>Права доступа</h3>
			<p><a name="part6_2_5_1"></a></p>
			<h4>Права доступа (chmod)</h4>
			<p>Представьте себе ситуацию, в которой вам срочно понадобилось програмно создать папку, дать её определённые права доступа, а по окончании работы удалить её. Такое может понадобится при создании некой программы с уникальным шифрованием, или программы с шифрованием <b>GPG</b> для неких целей защиты того или иного доступа. Например, пакет <b>python-gnupg</b> поддерживает такой функционал.</p>
			<p>Прежде, чем мы рассмотрим как раздавать права доступа, давайте посмотрим как их получить, а также как вывести на экран.</p>
			<p>Для преобразования в нормальный и понятный для нас вид воспользуемся библиотекой <b>stat</b>, а именно, методами <b>filemode</b> и <b>S_IMODE</b>.</p>
			<p>Я заранее создал каталог <b>gpgtest</b> и дал ему права <b>700</b> вручную, т.е. полный доступ только владельцу каталога. Дело в том, что утилита <b>GNUPG</b> требует для рабочей директории именно такие права доступа.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-10.png" class="fz__minimized" alt="клик для увеличения" title="Title" />
			</div>
			<p>Посмотрим как получить права доступа при помощи библиотек <b>os</b> и <b>pathlib</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:#069;"><b>from</b></span> stat <span style="color:#069;"><b>import</b></span> S_IMODE, filemode<br>
				<span style="color:Green;"># Pathlib.Path.stat</span><br>
				p = pathlib.Path(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.stat().st_mode, filemode(p.stat().st_mode), <span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br>
				<span style="color:Green;"># os.stat</span><br>
				statinfo = os.stat(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(statinfo.st_mode, filemode(statinfo.st_mode), <span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
				16832 drwx------ 0o700<br>
				16832 drwx------ 0o700</span>
			</p>
			<p><b>Всё работает!</b></p>
			<p>Оставим только <b>pathlib.Path.stat</b>, и <b>oct</b> вывод прав доступа для одного из следующих примеров.</p>
			<p>У нас имеется строка в виде последовательно записанных <b>нуля</b> и английской буквы <b>'o'</b>. Попробуем преобразовать заданные из ввода права доступа в правильный формат и обратно.</p>
			<p>Введём, например 755 и посмотрим что получится.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				mode = <span style="color:Blue;">'0o'</span> + <span style="color:#ff1493;">str</span>(<span style="color:#ff1493;">int</span>(<span style="color:#ff9933;">input</span>(<span style="color:Blue;">'Введите права доступа: '</span>)))<br>
				real_mode = int(mode, 8)<br>
				<span style="color:#ff1493;">print</span>(mode, real_mode, <span style="color:#ff9933;">oct</span>(real_mode))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
				Введите права доступа: 755<br>
				0o755 493 0o755<br></span>
			</p>
			<p>Работает. Попробуем изменить права доступа к каталогу <b>gpgtest</b> и файлу <b>strukture.txt</b> разными библиотеками и посмотрим чем они отличаются.</p>
			<p><b>pathlib.Path.chmod</b>. Поменяем права с <b>700</b> на <b>755</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> pathlib<br>
				<span style="color:#069;"><b>from</b></span> stat <span style="color:#069;"><b>import</b></span> S_IMODE<br><br>
				p = pathlib.Path(<span style="color:Blue;">'./gpgtest'</span>)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br>
				mode = <span style="color:Blue;">'0o755'</span><br>
				real_mode = int(mode, 8)<br>
				pathlib.Path(p).chmod(real_mode)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(p.stat().st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
					0o700<br>
					0o755
				</span>
			</p>
			<p>У <b>pathlib</b> есть ещё один метод - <b>Path.lchmod(mode)</b>.</p>
			<p><b>Path.lchmod()</b> не следует символическим ссылкам. Т.е. если путь <b>Path</b> указывает на символическую ссылку, изменяется режим <b>chmod</b> символической ссылки, а не целевого объекта, на который она указывает.</p>
			<p><b>os.chmod</b>. Поменяем права обратно на <b>700</b>.</p>
			<p class="codes">
				<b>mikl@mikl ~/0/Primer></b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>from</b></span> stat import S_IMODE<br><br>

				my_dir = <span style="color:Blue;">'./gpgtest'</span><br>
				statinfo = os.stat(my_dir)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br>
				mode = <span style="color:Blue;">'0o700'</span><br>
				real_mode = int(mode, 8)<br>
				os.chmod(my_dir, real_mode)<br>
				<u>statinfo = os.stat(my_dir)</u><br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(statinfo.st_mode)))<br><br>
				<b>mikl@mikl ~/0/Primer></b> python main.py<br>
				<span style="color:Blue;">
					0o755<br>
					0o700
				</span>
			</p>
			<p>
				<b>Обратите внимание на подчеркнутую строку.</b> Для получения статуса в <b>OS</b> необходимо повторно запрашивать права доступа к файлу или папке. В <b>pathlib</b> запрос прав доступа происходит автоматически во время обращения к команде статуса файла или папки.
			</p>
			<p>Можно немного уменьшить количество кода вложенными запросами.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				<span style="color:#069;"><b>from</b></span> stat import S_IMODE<br><br>

				my_dir = <span style="color:Blue;">'./gpgtest'</span><br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(os.stat(my_dir).st_mode)))<br>
				mode = <span style="color:Blue;">'0o700'</span><br>
				real_mode = int(mode, 8)<br>
				os.chmod(my_dir, real_mode)<br>
				<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">oct</span>(S_IMODE(os.stat(my_dir).st_mode)))
			</p>
			<p><b>Однако, помните, что для библиотеки OS запрашивать права доступа, т.е. обращаться к статусу состояния файла или папки необходимо повторно.</b></p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-6.png" class="fz__minimized" alt="клик для увеличения" title="Status" />
			</div>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_5_2"></a></p>
			<h4>Смена владельца и/или группы (os.chown)</h4>
			<p>У <b>pathlib</b> нет методов chown. Поэтому здесь всё-таки придётся использовать библиотеку <b>os</b>.</p>
			<p>Вообще у <b>os</b> есть два метода: <b>os.chown()</b> и <b>os.lchown()</b>.</p>
			<p>Синтаксис у них следующий:</p>
			<ul>
				<li>os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)</li>
				<li>os.lchown(path, uid, gid)</li>
			</ul>
			<p>Параметры означают следующее:</p>
			<ul>
				<li><b>path</b> - <span style="color:#069;">str</span> путь в файловой системе.</li>
				<li><b>uid</b> - <span style="color:#069;">числовой</span> идентификатор пользователя</li>
				<li><b>gid</b> - <span style="color:#069;">числовой</span> идентификатор группы</li>
				<li><b>dir_fd</b> - <span style="color:#069;">дескрипторов каталога</span></li>
				<li><b>follow_symlinks</b> - <span style="color:#069;">bool</span>, переходить ли по ссылкам.</li>
			</ul>
			<p><b>Данный метод не возвращает никаких значений!</b></p>
			<p>Чтобы оставить один из идентификаторов без изменений, установите его на -1.</p>
			<p>Функция <i>os.lchown()</i> эквивалентна вызову функции <i>os.chown()</i> с установленным аргументом <i>follow_symlinks=False</i>, например, <i>os.chown(path, uid, gid, follow_symlinks=False)</i>.</p>
			<p>Аргумент <i>path</i> в обоих функциях можно вставить как <i>pathlib.PurePath</i>.</p>
			<p>Пример использования.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				f = <span style="color:Blue;">'strukture.txt'</span><br>
				os.stat(f).st_gid<br>
				# 1000<br>
				os.stat(f).st_uid<br>
				# 1000<br><br>

				os.chown(f, -1, 1001)<br>
				os.stat(f).st_gid<br>
				# 1001<br>
				os.stat(f).st_uid<br><br>

				<b>mikl ~/003/Primer $</b> sudo python main.py<br>
				<b>[sudo] пароль для mikl:</b><br>
				<span style="color:Blue;">
				985<br>
				1000<br>
				1001<br>
				1000<br></span>
				<b>mikl ~/003/Primer $</b> ls -lha<br>
				<span style="color:Blue;">
				итого 32K<br>
				drwxr-xr-x 3 mikl users 4,0K июл 24 09:12 .<br>
				drwxr-xr-x 3 mikl users  16K июл 22 17:35 ..<br>
				-rw-r--r-- 1 mikl users  234 июл 24 09:12 main.py<br>
				drwxr-xr-x 4 mikl users 4,0K июл 22 00:04 pkg<br>
				-rwxr-xr-x 1 mikl  1001   73 июл 24 00:28 strukture.txt</span>
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_5_3"></a></p>
			<h4>Смена владельца и/или группы (shutil.chown)</h4>
			<p>На самом деле это не столько правильный, сколько более понятный метод.</p>
			<p>Синтаксис у него следующий:</p>
			<ul>
				<li>shutil.chown(path, user=None, group=None)</li>
			</ul>
			<p>Где параметры:</p>
			<ul>
				<li><b>path</b> - путь к файлу/каталогу</li>
				<li><b>user</b> - пользователь</li>
				<li><b>group</b> - группа</li>
			</ul>
			<p>Этот метод тоже не возвращает никаких значений.</p>
			<p>Функция <i>chown()</i> модуля <i>shutil</i> меняет владельца пользователя и/или группы по указанному пути.</p>
			<p>Рассмотрим пример.</p>
			<div class="codeses">
				<pre>
<b>mikl@mikl ~/0/Primer></b> nano main.py
<span style="color:#069;"><b>import</b></span> os
<span style="color:#069;"><b>import</b></span> shutil, pathlib
<span style="color:#069;"><b>import</b></span> pwd

username = os.getlogin()
on_uid = pwd.getpwnam(username).pw_uid
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f"username: {<span style="color:Black;">username</span>}, uid: {<span style="color:Black;">on_uid</span>}"</span>)

my_dir = <span style="color:Blue;">'test_dir'</span>
on_dir = pathlib.Path(my_dir)
if not on_dir.exists():
	on_dir.mkdir(parents=True, exist_ok=True)
<span style="color:Green;"># пользователь с id 1000 и группа 'games' должны существовать
#  а учетная запись должна иметь право на изменение прав  
# доступа, иначе будет ошибка <span style="color:#ff9933;">'PermissionError'</span></span>

<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f" Изменение прав доступа на папку: &#8249;{<span style="color:Black;">on_dir.resolve()</span>}&#8250;,\n \
Папка создана:\n \
	Владелец: {<span style="color:Black;">on_dir.owner()</span>},\n \
	Группа: {<span style="color:Black;">on_dir.group()</span>}"</span>)

shutil.chown(<span style="color:Blue;">'test_dir'</span>, user=on_uid, group=<span style="color:Blue;">'games'</span>)
<span style="color:#ff1493;">print</span>(<span style="color:#ff9933;">f" Папка: &#8249;{<span style="color:Black;">on_dir.resolve()</span>}&#8250;,\n \
Изменение владельца:\n \
	Владелец: '{<span style="color:Black;">on_dir.owner()</span>}',\n \
	Группа: '{<span style="color:Black;">on_dir.group()</span>}'"</span>)

<b>mikl@mikl ~/0/Primer></b> python main.py<span style="color:Blue;">
username: mikl, uid: 1000
 Изменение прав доступа на папку: &#8249;/home/mikl/003/Primer/test_dir&#8250;,
 Папка создана:
 	Владелец: mikl,
 	Группа: users
 Папка: &#8249;/home/mikl/003/Primer/test_dir&#8250;,
 Изменение владельца:
 	Владелец: 'mikl',
 	Группа: 'games'</span></pre>
			</div>
			<p>Здесь, чтобы не искать и не думать о пресловутом <i>id</i> пользователя, мы сначала получаем имя пользователя запустившего терминал, а затем запрашиваем его <i>id</i> (<i>username = os.getlogin()</i> и <i>on_uid = pwd.getpwnam(username).pw_uid</i>). А затем выводим эти значения на экран, с помощью <i>f-строки</i>.</p>
			<p>Далее вводим каталог, который нам необходимо создать. Перед созданием - на всякий случай проверяем - не создан ли он уже. Если нет  - создаем его, включая все вложенные директории.</p>
			<p>Проверяем, точнее перед изменения выводим группу и пользователя этого каталога на экран. И только после этого меняем группу. Владелец остаётся прежним. Потому что при создании директорий владелец будет всегда тот, кто запустил терминал. А мы его запросили в самом начале. <b>Это была не обязательная операция.</b> Просто, чтобы вы знали как это можно сделать.</p>
			<p>Далее строкой <b>shutil.chown</b> меняем группу, и затем выводим изменения на экран, также с помощью <i>f-строки</i>.</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_5">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<p><a name="part6_2_6"></a></p>
			<h3>Создание файлов и папок</h3>
			<p><a name="part6_2_6_1"></a></p>
			<h4>Чтение и Запись файлов</h4>
			<p>Прежде всего необходимо понять, что в библиотеке <b>OS</b> нет команды для создания файла. А в библиотеке <b>pathlib</b> есть.</p>
			<p>При попытке прочитать или записать файла мы всегда путаемся - как правильно это сделать. Первым делом вы скорее всего будете обращаться к команде <b>open</b> - что-то вроде следующего:</p>
			<p class="codes">
				handle = open(<span style="color:Blue;">"test.txt"</span>, <span style="color:Blue;">"r"</span>)<br>
				data = handle.readline() <span style="color:Green;"># read just one line</span><br>
				<span style="color:#ff1493;">print</span>(data)<br>
				handle.close()
			</p>
			<p><b>Обратите внимание!</b></p>
			<p>Дело в том, что при таком обращении в случае возникновения какой-либо ошибки при работе с файлом (ошибка доступа, невозможно открыть файл, нет такого файла и многие другие) вы не сможете закрыть этот файл. Он так и останется висеть в памяти ПК. Try excpet в этом случае хоть и обрабатывают исключения, однако, опять таки не закрывают сам файл.</p>
			<p>Как же правильно это сделать? Через оператор <b>with</b>. Например, так.</p>
			<div class="codeses">
				<pre><span style="color:#069;">with</span> open(<span style="color:Blue;">"strukture.txt"</span>, <span style="color:Blue;">"r"</span>) <span style="color:#069;">as</span> file_handler:
	<span style="color:#069;">for</span> line <span style="color:#069;">in</span> file_handler:
		<span style="color:#ff1493;">print</span>(line)</pre>
			</div>
			<p>Если необходимо сохранить данные в переменную, можно сделать так.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;">with</span> open(<span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">"r"</span>) <span style="color:#069;">as</span> f:
	<span style="color:Green;">#lines = f.readlines()</span>
	lines = f.read()

<span style="color:#ff1493;">print</span>(lines)<span style="color:Green;">
#for item in lines:
#	print(item, end = ' ')</span>
				</pre>
			</div>
			<p><b>Обратите внимание на комментарии!</b> Комментариями отмечен вариант построчного получения данных и соответственно построчный вывод, т.к. в этом случае у вас будет список строк, а не одна большая строка.</p>
			<p>Вот у нас есть комманда: <b>with open ("data.txt", "r") as myfile</b>. А что это за параметр <b>"r"</b>?</p>
			<p>Если не указывать этот параметр, то файл будет открыть только для чтения. Этот параметр указывает на режим доступа к файлу.</p>
			<p>Текстовые файлы можно использовать в следующих режимах:</p>
			<ul>
				<li><b>r</b> - Только для чтения.</li>
				<li><b>w</b> - Только для записи. Создаст новый файл, если не найдет с указанным именем.</li>
				<li><b>rb</b> - Только для чтения (бинарный).</li>
				<li><b>wb</b> - Только для записи (бинарный). Создаст новый файл, если не найдет с указанным именем.</li>
				<li><b>r+</b> - Для чтения и записи.</li>
				<li><b>rb+</b> - Для чтения и записи (бинарный).</li>
				<li><b>w+</b> - Для чтения и записи. Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>wb+</b> - Для чтения и записи (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>a</b> - Откроет для добавления нового содержимого. Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>a+</b> - Откроет для добавления нового содержимого. Создаст новый файл для чтения записи, если не найдет с указанным именем.</li>
				<li><b>ab</b> - Откроет для добавления нового содержимого (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.</li>
				<li><b>ab+</b> - Откроет для добавления нового содержимого (бинарный). Создаст новый файл для чтения записи, если не найдет с указанным именем.</li>
			</ul>
			<p>Скорее всего вам понадобится пользоваться только 4 режимами: <b>r</b>, <b>r+</b>, <b>rb</b> и <b>rb+</b>.</p>
			<p>В режимах <b>'w'</b> и <b>wb'</b> происходит перезапись файла. В режимах <b>'w+'</b> и <b>'wb+'</b> файл в любом случае будет перезаписан. Однако, он также ведь открывается и для чтения. Поэтому для того, чтобы хоть что-то прочитать, сначала необходимо хоть что-то в него записать, иначе вы получите на выходе пустые данные!</p>
			<p><b>Необходимо понимать, что в режимах 'w' и 'w+' добавление в файл данных не будет, будет происходить именно перезапись файла! Для добавления необходимо использовать другой режим.</b> Например, <b>'r+'</b>, <b>'a'</b>, <b>'a+'</b>.</p>
			<p>Дело в том, что в режимах <b>'r+'</b> и <b>'a+'</b> вы можете как прочитать данные, так и дозаписать в файл какие-нибудь данные. Необходимо лишь устанавливать курсор в начало или конец файла <b>file.seek()</b>. А вот в режимах без плюса <b>'+'</b> вы можете либо только прочитать данные, либо только записать. Тоже самое, насчет использования плюса, касается всех режимов.</p>
			<p>Во всех режимах добавления данных <b>'a'</b>, с плюсом и без, бинарный или нет - устанавливать курсор <b>file.seek()</b> в конец файла не обязательно. При старте, он сразу автоматически будет находится в конце файла для дозаписи. А вот во всех режимах <b>'r'</b> с плюсом - обязательно контролируйте где находится курсор, ну или принудительно ставьте его в начало или конец файла. Иначе, при записи данных, вы рискуете потерять предыдущие данные.</p>
			<p><b>Чтобы понимать как пользоваться всеми этими режимами, вам необходимо ознакомится ещё с несколькими важными понятиями.</b></p>
			<p>И первое это метод <b>file.seek(offset, whence)</b> и переменная <b>file.tell()</b>.</p>
			<p><b>file.tell()</b> получает текущую позицию указателя чтения/записи файла.</p>
			<p class="codes">
				>>> text = <span style="color:Blue;">'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'</span><br>
				>>> fp = <span style="color:Green;">open</span>(<span style="color:Blue;">'foo.txt'</span>, <span style="color:Blue;">'w+'</span>)<br>
				>>> fp.write(text)<br>
				# 51<br>
				>>> fp.tell()<br>
				# 51<br>
				>>> fp.seek(0)<br>
				# 0<br>
				>>> fp.read(10)<br>
				# 'This is 1s'<br>
				>>> fp.tell()<br>
				# 10<br>
				>>> fp.read(15)<br>
				# 't line\nThis is '<br>
				>>> fp.tell()<br>
				# 25<br>
				>>> fp.close()
			</p>
			<p><b>file.seek</b>(<span style="color:Green;">offset</span>, <span style="color:#069;">whence</span>) перемещает указатель чтения/записи в файле.</p>
			<ul>
				<li><b>offset</b> - смещение указателя чтения/записи файла на <span style="color:#069;">int</span> байтов.</li>
				<li><b>whence</b> - абсолютное позиционирование указателя в формате <span style="color:#069;">int</span>.</li>
			</ul>
			<p>Аргумент <b>whence</b> является необязательным и по умолчанию равен 0.</p>
			<ul>
				<li>0 - смещает указатель на <b>offset</b> относительно начала файла.</li>
				<li>1 - смещает указатель на <b>offset</b> относительно относительно текущей позиции.</li>
				<li>2 - смещает указатель на <b>offset</b> относительно конца файла.</li>
			</ul>
			<p><b>Использование whence имеет одну важную особенность. Значение 1 можно использовать только для бинарных файлов. Также и file.seek() использовать в обычных текстовых (не бинарных) файлах можно только следующими способами:</b></p>
			<ul>
				<li>file.seek(N, 0) - Где N &ge; 0.</li>
				<li>file.seek(0, 2).</li>
			</ul>
			<p>Иначе вы рискуете получить 2 вида исключений: <b><span style="color:#ff9933;">io.UnsupportedOperation</span></b> и <b><span style="color:#ff9933;">ValueError</span></b>.</p>
			<p><b>Ещё несколько важных моментов.</b></p>
			<ul>
				<li>Если файл открыт для добавления с помощью <b>'a'</b> или <b>'a+'</b>, все операции <b>file.seek()</b> будут отменены при следующей записи.</li>
				<li>Если файл открыт только для записи в режиме добавления с использованием <b>'a'</b>, Этот метод по существу используется, но он остается полезным для файлов, открытых в режиме добавления с включенным чтением - режим <b>'a+'</b>.</li>
				<li>Если файл открыт в текстовом режиме с помощью <b>'t'</b>, то допустимы только смещения, возвращаемые функцией <b>file.tell()</b>. Использование других смещений вызывает неопределенное поведение.</li>
			</ul>
			<p class="codes">
				>>> text = b<span style="color:Blue;">'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'</span><br>
				>>> fp = <span style="color:Green;">open</span>(<span style="color:Blue;">'foo.txt'</span>, <span style="color:Blue;">'bw+'</span>)<br>
				>>> fp.write(text)<br>
				# 51<br>
				>>> fp.seek(20, 0)<br>
				# 20<br>
				>>> fp.read(10)<br>
				# b's is 2nd l'<br>
				>>> fp.seek(10, 1)<br>
				# 40<br>
				>>> fp.read(10)<br>
				# b's 3rd line'<br>
				>>> fp.seek(-11, 2)<br>
				# 40<br>
				>>> fp.read(10)<br>
				# b's 3rd line'<br>
				>>> fp.close()
			</p>
			<p>Рассмотрим пример и чтения и дозаписи файла.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
str2 = <span style="color:Blue;">'Многие думают о Lorem Ipsum.\n'</span>
lines = <span style="color:Blue;">''</span>
<span style="color:#069;"><b>with</b></span> open(<span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'r+'</span>) <span style="color:#069;"><b>as</b></span> my_file:
	my_file.seek(0,0) <span style="color:Green;"># курсор может быть и не в начале, на всякий случай</span>
	lines = my_file.read()
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	print(<span style="color:Blue;">'Прочитанная информация:'</span>, lines)
	my_file.seek(0,2)
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	my_file.write(str2)
	my_file.seek(0,0)
	lines = my_file.read()
	print(<span style="color:Blue;">'Позиция:'</span>, my_file.tell())
	print(<span style="color:Blue;">'Файл был дозаписан:'</span>, lines)
<b>mikl ~/003/Primer $</b> python main.py
<span style="color:Blue;">Позиция: 31
Прочитанная информация: It is a long established fact.

Позиция: 31
Позиция: 73
Файл был дозаписан: It is a long established fact.
Многие думают о Lorem Ipsum.</span></pre>
			</div>
			<p><b>Не забывайте, что  в строках, которые вы записываете в файлы, нужны переносы строк. Иначе у вас все строки будут слитыми вместе!</b><br> Ну или можете вручную после каждой записи строки делать ещё одну запись одного переноса.</p>
			<p><b>Чтение и запись файлов средствами pathlib.</b></p>
			<p>Иногда бывает полезно быстро записать и считать некую техническую информацию о тех или иных объектах на английском языке. Для этого и предназначены методы чтения и записи данных данной библиотеки.</p>
			<p>Метод <b>Path.open()</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</p>
			<p>Метод открывает файл, на который указывает путь path, как это делает встроенная функция <span style="color:Blue;">open()</span>.</p>
			<p>В моём файле <b>strukture.txt</b> с прошлых тестов остался некоторый текст. Часть на английском, часть на русском.</p>
			<div class="codeses">
				<pre>
<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path

p = Path(<span style="color:Blue;">'strukture.txt'</span>)
<span style="color:#069;"><b>with</b></span> p.open(encoding=<span style="color:Blue;">'utf-8'</span>) <span style="color:#069;"><b>as</b></span> f:
	<span style="color:#ff1493;">print</span>(f.readline())
				</pre>
			</div>
			<p>Обратите внимание на то, что <b>pathlib</b> может некорректно или вообще не читать русский текст. Однако, файл читать будет!</p>
			<p><b>Path.read_bytes()</b> - возвращает содержимое бинарного файла. Файл при этом открывается и тут же закрывается.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>
				p = Path(<span style="color:Blue;">'test_binary_file'</span>)<br>
				p.write_bytes(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_bytes())
			</p>
			<p>Метод <b>Path.read_text</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.read_text(encoding=None, errors=None)</p>
			<p>Возвращает декодированное содержимое файла в виде строки.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>
				p = Path(<span style="color:Blue;">'test_file'</span>)<br>
				p.write_text(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_text())
			</p>
			<p>Метод <b>Path.write_bytes()</b> открывает файл, записывает байтовые данные и тут же закрывает его.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.write_bytes(data)</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test_binary_file'</span>)<br>
				p.write_bytes(b<span style="color:Blue;">'Binary file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_bytes())
			</p>
			<p>Метод <b>Path.write_text</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.write_text(data, encoding=None, errors=None, newline=None)</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test_file'</span>)<br>
				p.write_text(<span style="color:Blue;">'Text file contents'</span>)<br>
				<span style="color:#ff1493;">print</span>(p.read_text())
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_6_2"></a></p>
			<h4>Создание файлов и каталогов</h4>
			<p><b>Библиотека OS</b></p>
			<p><b>Создание каталогов</b></p>
			<p>Синтаксис команды <b>os.mkdir</b>:</p>
			<p style="margin-left:20px;">os.mkdir(path, mode=0o777, *, dir_fd=None)</p>
			<ul>
				<li><b>path</b> - имя каталога</li>
				<li><b>mode</b> - режимом доступа к каталогу</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Например:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				a = <span style="color:Blue;">'test'</span><br>
				os.mkdir(a, 0o755)<br>
			</p>
			<p><b>При создании нового каталога с помощью os.mkdir() все родительские каталоги должны уже существовать.</b></p>
			<p>создать пустой каталог (папку)</p>
			<div class="codeses">
				<pre>os.mkdir(<span style="color:Blue;">"folder"</span>)<span style="color:Green;">
# повторный запуск mkdir с тем же именем вызывает FileExistsError,
# вместо этого запустите:</span>
<span style="color:#069;"><b>if</b></span> <span style="color:#ff9933;">not</span> os.path.isdir(<span style="color:Blue;">"folder"</span>):
	os.mkdir(<span style="color:Blue;">"folder"</span>)</pre>
			</div>
			<p>Функция <i>os.path.isdir()</i> вернет <i>True</i>, если переданное имя ссылается на существующий каталог.</p>
			<p>Изменение текущего каталога на 'folder'.</p>
			<p class="codes">
				<b>mikl ~/003/Primer $</b> nano main.py<br>
				<span style="color:#069;"><b>import</b></span> os<br>
				os.chdir(<span style="color:Blue;">"folder"</span>)<br>
				<span style="color:Green;"># вывод текущей папки</span><br>
				<span style="color:#ff1493;">print</span>(<span style="color:Blue;">"Текущая директория изменилась на folder:"</span>, os.getcwd())<br><br>
				<b>mikl ~/003/Primer $</b> python main.py<br>
				<span style="color:Blue;">
				Текущая директория изменилась на folder: /home/mikl/003/Primer/folder</span>
			</p>		
			<p>Предположим, вы хотите создать не только одну папку, но и несколько вложенных.</p>
			<div class="codeses">
				<pre>
<b>mikl ~/003/Primer $</b> nano main.py
<span style="color:#069;"><b>import</b></span> os
<span style="color:Green;"># вернуться в предыдущую директорию</span>
os.chdir(<span style="color:Blue;">".."</span>)<br>
<span style="color:Green;"># сделать несколько вложенных папок</span>
os.makedirs(<span style="color:Blue;">"nested1/nested2/nested3"</span>)

<b>mikl ~/003/Primer $</b> python main.py
<b>mikl ~/003/Primer $</b> ls -lha | grep -Ei nested1
<span style="color:Blue;">drwxr-xr-x 3 mikl users 4,0K июл 24 15:19 nested1</span>
<b>mikl ~/003/Primer $</b> tree ./nested1
<span style="color:Blue;">./nested1
└── nested2
    └── nested3

2 directories, 0 files</span>
				</pre>
			</div>
			<p><b>Библиотека pathlib</b></p>
			<p>Синтаксис команды <b>Path.mkdir</b>:</p>
			<p style="margin-left:20px;">Path.mkdir(mode=0o777, parents=False, exist_ok=False)</p>
			<p>Если указан режим <b>mode</b>, он объединяется со значением <b>umask</b>, для определения режима файла и флагов доступа. Если путь уже существует, вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</p>
			<ul>
				<li><b>parents=True</b> - создание всех отсутствующих подкаталогов, без учета указанного режима <b>mode</b>, имитируя команду <i>POSIX</i> <b>mkdir -p</b>.</li>
				<li><b>parents=False</b> - Отсутствующие каталоги будут вызывать исключение <span style="color:#ff9933;">FileNotFoundError</span>.</li>
				<li><b>exist_ok=False</b> - Если такой каталог уже существует вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</li>
				<li><b>exist_ok=True</b> - исключения <span style="color:#ff9933;">FileExistsError</span> будут игнорироваться, команду <b>mkdir -p</b>, если предложенный путь не является существующим файлом.</li>
			</ul>
			<p>Пример команды <b>Path.mkdir</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'folder1/folder2/folder3'</span>)<br>
				p.mkdir(parents=True)<br>
			</p>
			<p>Синтаксис команды <b>Path.touch</b>:</p>
			<p style="margin-left:20px;">Path.touch(mode=0o666, exist_ok=True)</p>
			<ul>
				<li>Если указан режим <b>mode</b>, он объединяется со значением umask процесса для определения режима файла и флагов доступа.</li>
				<li>Если файл уже существует, функция завершается успешно.</li>
				<li>Если аргумент <b>exist_ok</b> имеет значение <b>True</b>, то его время модификации обновляется до текущего времени, в противном случае вызывается исключение <span style="color:#ff9933;">FileExistsError</span>.</li>
			</ul>
			<p>Пример команды <b>Path.touch</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'test.txt'</span>)<br>
				p.touch(mode=0o644)
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_6_3"></a></p>
			<h4>Жесткие и символьные ссылки</h4>
			<p>Символьные ссылки <b>os.symlink</b>.</p>
			<p>Синтаксис команды <b>os.symlink</b>:</p>
			<p style="margin-left:20px;">os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)</p>
			<ul>
				<li><b>src</b> - путь в файловой системе на который указывает ссылка</li>
				<li><b>dst</b> - имя ссылки</li>
				<li><b>target_is_directory</b> - в Windows ссылка как каталог</li>
				<li><b>dir_fd</b> - дескрипторов каталогов</li>
			</ul>
			<p>Пример каманды <b>os.symlink</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				src = <span style="color:Blue;">'./strukture.txt'</span><br>
				dst = <span style="color:Blue;">'./test.txt'</span><br>
				os.symlink(src, dst)<br>
				<span style="color:Green;"># Очистим</span><br>
				os.unlink(dst)
			</p>
			<p>Жесткая ссылка <b>os.link</b>.</p>
			<p>Синтаксис команды <b>os.link</b>:</p>
			<p style="margin-left:20px;">os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)</p>
			<ul>
				<li><b>src</b> - путь в файловой системе на который указывает ссылка</li>
				<li><b>dst</b> - имя ссылки</li>
				<li><b>src_dir_fd</b> - дескрипторов каталогов на который указывает ссылка</li>
				<li><b>dst_dir_fd</b> - имя ссылки, дескрипторов каталогов</li>
				<li><b>follow_symlinks</b> - переходить ли по ссылкам</li>
			</ul>
			<p>Пример использования <b>os.link</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				scr = <span style="color:Blue;">'test.txt'</span><br>
				dst = <span style="color:Blue;">'new.txt'</span><br>
				os.link(scr, dst)
			</p>
			<p>Жесткая ссылка <b>pathlib.Path.hardlink_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.hardlink_to(target)</p>
			<ul>
				<li><b>target</b> - путь в файловой системе на который указывает ссылка. При этом путь куда сохранять ссылку вместе с именем ссылки берется из самого <b>Path</b>.</li>
			</ul>
			<p>Пример использования <b>pathlib.Path.hardlink_to</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				<span style="color:Green;"># Путь куда сохранить ссылку + название ссылки</span><br>
				<span style="color:Green;"># Ссылка сохранятеся в текущий каталог</span><br>
				p = Path(<span style="color:Blue;">'mylink'</span>)<br>
				<span style="color:Green;"># То, на что ссылается эта ссылка</span><br>
				p.hardlink_to(<span style="color:Blue;">'./strukture.txt'</span>)
			</p>
			<p>Жесткая ссылка <b>Path.link_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.link_to(target)</p>
			<ul>
				<li><b>target</b> - название и место сохранения ссылки. При этом объект, на который должна ссылаться ссылка берется из самого <b>Path</b>.</li>
			</ul>
			<p>Пример использования команды <b>Path.link_to</b>:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'./strukture.txt'</span>)<br>
				p.link_to(<span style="color:Blue;">'mylink'</span>)
			</p>
			<p>Символьные ссылки <b>Path.symlink_to</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left:20px;">Path.symlink_to(target, target_is_directory=False)</p>
			<ul>
				<li><b>target</b> - путь в файловой системе на который указывает ссылка. При этом путь куда сохранять ссылку вместе с именем ссылки берется из самого <b>Path</b>.</li>
			</ul>
			<p><b>В Windows target_is_directory должен быть True (по умолчанию False), если целью ссылки является каталог. В POSIX значение target_is_directory игнорируется.</b></p>
			<p>Пример использования команды:</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				p = Path(<span style="color:Blue;">'./mylink'</span>)<br>
				p.symlink_to(<span style="color:Blue;">'./strukture.txt'</span>)
			</p>
			<p>Удаление символических ссылок <b>os.unlink</b>.</p>
			<p style="margin-left: 20px">os.unlink(path, *, dir_fd = None)</p>
			<ul>
				<li><b>path</b> - путь к ссылке</li>
				<li><b>dir_fd</b> - дескриптор каталога</li>
			</ul>
			<p>Пример использования <b>os.unlink</b>. Создадим ссылку и тут же удалим её.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br>
				scr = <span style="color:Blue;">'test.txt'</span><br>
				dst = <span style="color:Blue;">'new.txt'</span><br>
				<span style="color:Green;"># Создаём ссылку</span><br>
				os.link(scr, dst)<br>
				<span style="color:Green;"># Тут же удаляем эту ссылку</span><br>
				os.unlink(dst)
			</p>
			<p>Удаление символический ссылок <b>pathlib.Path.unlink</b>.</p>
			<p style="margin-left: 20px">Path.unlink(missing_ok=False)</p>
			<ul>
				<li><b>missing_ok</b> - игнорирование ошибок при обнаружении существования пути.</li>
			</ul>
			<p>Если <i>missing_ok</i> = <i>False (по умолчанию)</i> и <u>путь не существует</u>, то вызывается исключение <span style="color:#ff9933;">FileNotFoundError</span>.</p>
			<p>Если <i>missing_ok</i> = <i>True</i>, то исключение <span style="color:#ff9933;">FileNotFoundError</span> будет игнорироваться аналогично команде <b>POSIX rm -f</b>.</p>
			<p>Пример использования <b>pathlib.Path.unlink</b>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br>
				<span style="color:Green;"># Путь к ссылке с указанием её имени</span><br>
				p = Path(<span style="color:Blue;">'./mylink'</span>)<br>
				<span style="color:Green;"># Создаём ссылку</span><br>
				p.symlink_to(<span style="color:Blue;">'./strukture.txt'</span>)<br>
				<span style="color:Green;"># И тут же удаляем эту ссылку</span><br>
				p.unlink(missing_ok=True)
			</p>
			<hr class="hr_chapter">
			<p><a href="#part6_2_6">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_7"></a></p>
			<h3>Переименование файлов и папок</h3>
			<p>Переименование файлов <b>os.rename</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)</p>
			<ul>
				<li><b>src</b> - исходное имя файла или каталога</li>
				<li><b>dst</b> - новое имя файла или каталога</li>
				<li><b>src_dir_fd</b> - исходный дескриптор каталога</li>
				<li><b>dst_dir_fd</b> - новый дескриптор каталога</li>
			</ul>
			<p>В <i>Windows</i>, если <i>dst</i> уже существует, всегда возникает ошибка <span style="color:#ff9933;">FileExistsError</span>.</p>
			<p>Если имя <b>dst</b> уже существует, то операция может завершится с подклассом исключения <span style="color:#ff9933;">OSError</span>.</p>
			<p>В Unix, если <b>src</b> - это файл, а <b>dst</b> - это каталог или наоборот, то поднимаются исключения <span style="color:#ff9933;">IsADirectoryError</span> или <span style="color:#ff9933;">NotADirectoryError</span> соответственно.</p>
			<p>Если оба являются каталогами и <i>dst</i> пуст, то <i>dst</i> будет заменен без уведомления. Если <i>dst</i> является непустым каталогом, возникает <span style="color:#ff9933;">OSError</span>. Если оба являются файлами, то <i>dst</i> будет заменен без уведомления.</p>
			<p>Операция может завершиться с ошибкой на некоторых разновидностях <b>Unix</b>, если <b>src</b> и <b>dst</b> находятся на разных файловых системах.</p>
			<p>Пример использования.</p>
			<p class="codes">
				<span style="color:#069;"><b>import</b></span> os<br><br>

				<span style="color:Green;"># Задаём исходный файл и тот, в который хотим переименовать</span><br>
				src, dst = <span style="color:Blue;">'strukture.txt'</span>, <span style="color:Blue;">'test.txt'</span><br>
				<span style="color:Green;"># Переименовываем</span><br>
				os.rename(src, dst)<br><br>

				<span style="color:Green;"># Присваиваем исходное имя и будущее переименованное</span><br>
				srcdir, dstdir = <span style="color:Blue;">'src_dir'</span>, <span style="color:Blue;">'dst_dir'</span><br>
				<span style="color:Green;"># Создаем исходный каталог</span><br>
				os.mkdir(srcdir)<br>
				<span style="color:Green;"># Переименовываем</span><br>
				os.rename(srcdir, dstdir)<br>
				<span style="color:Green;"># Удаляем, если не нужен</span><br>
				os.rmdir(dstdir)			
			</p>
			<p>Метод <b>Path.rename</b>.</p>
			<p>Синтаксис команды:</p>
			<p style="margin-left: 20px">Path.rename(target)</p>
			<p>Метод <i>Path.rename()</i> переименует файл или каталог пути <i>path</i> в указанную цель <b>target</b>. Значение <i>target</i> может быть либо строкой, либо другим объектом пути.</p>
			<p>Пример использования. С прошлого примера остался файл <i>test.txt</i>. Переименуем его обратно в <i>strukture.txt</i>.</p>
			<p class="codes">
				<span style="color:#069;"><b>from</b></span> pathlib <span style="color:#069;"><b>import</b></span> Path<br><br>

				p = Path(<span style="color:Blue;">'test.txt'</span>)<br>
				p.rename(<span style="color:Blue;">'strukture.txt'</span>)
			</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_8"></a></p>
			<h3>Перемещение файлов и папок</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_9"></a></p>
			<h3>Удаление файлов и папок</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr class="hr_chapter">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a></p>
			<hr class="hr_chapter">
			<p><a name="part6_2_10"></a></p>
			<h3>Рекурсивные операции</h3>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p>Т.е. выходит, что pathlib объединяет в себе часто используемые функции двух стандартных модулей os и os.path, а так же стандартную функцию open() для чтения файла и записи в файл какой либо информации.</p>
			<hr class="hr_main">
			<p><a href="#part6_2">Перейти к Главе</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>			
		</div>
		<div class="content">
			<p><a name="part7"></a></p>
			<h2>Немного <span style="color:Red;">&laquo;unittest&raquo;</span></h2>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="partN"></a></p>
			<h1>Part-1 H1</h1>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p class="codes">
				
			</p>
			<div class="codeses">
				<pre>

				</pre>
			</div>
			<div class="codeses">
				<pre>
<span style="color:blue;">#!/bin/bash</span>
...
script
...
<span style="color:blue;"># echo "result"</span>
				</pre>
			</div>
			<ul>
				<li><span style="color:Blue;">Blue</span></li>
				<li>Black</li>
				<li><span style="color:Red;">Reed</span></li>
				<li><span style="color:Yellow;">Yellow</span></li>
				<li><span style="color:Green;">Green</span></li>
			</ul>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr class="hr_main">
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/image-0.jpg" class="fz__minimized" alt="клик для увеличения" title="Title" />
			</div>
			<hr class="hr_main">
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
