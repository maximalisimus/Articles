<html>
<head>
	<meta charset="utf-8">
	<title>Hogwarts в Python</title>
	<link rel="icon" href="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-favicon.png">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/main.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/zoom.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/table.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/frame.css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/ol-li.css" type="text/css">
	<link rel="stylesheet" href="https://maximalisimus.github.io/Articles/html/img.css" type="text/css">
	<script src="https://maximalisimus.github.io/Articles/html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="https://maximalisimus.github.io/Articles/html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Hogwarts в Python</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-logo.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h1>Python - волшебный импорт или как не споткнуться о pathlib.</h1>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Введение</a></li>
				<li><a href="#part2">Структура &laquo;проекта-примера&raquo;</a></li>
				<li><a href="#part3">Cодержимое файлов &laquo;проекта-примера&raquo;</a></li>
				<li><a href="#part4">Импорт пакетов</a></li>
				<li><a href="#part5">Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></a></li>
				<li><a href="#part6">Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</a></li>
				<li><a href="#part7">Немного <span style="color:Red;">&laquo;unittest&raquo;</span></a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h1>Введение</h1>
			<p>При создании любого <i>python-проекта</i> или одиночного скрипта с кодом мы часто пользуемся импортом, не совсем понимая или не помня, как именно он работает. В связи с чем, иногда могут возникать казусы и непредвиденные ситуации, которые порой сложно решить даже с использованием <i>&laquo;Google&raquo;</i> поиска.</p>
			<p>Сегодня моя задача объяснить почему возникают ошибки импорта пакетов или модулей, а также рассказать сложные темы простыми словами.
			Темы нашего сегодняшнего разговора очень простые, не смотря на то, что кажутся жутко сложными на первый взгляд. Однако, даже не углубляясь глубоко в дебри языка можно легко прийти к выводу - что любая задача решается очень легко.</p>
			<p>Даже если мы не знаем какая библиотека сможет решить ту или иную задачу, мы всегда должны понимать что способов решений может быть много, а может быть ни одного. В любом случае каждый раз вам придётся не только искать то или иное решение, но и искать его самостоятельно. Порою вы сможете найти сразу готовое решение и оно вам подойдет. <b>Однако, так будет не всегда.</b></p>
			<p>В любом случае вам нужно опираться на несколько базовых понятий:</p>
			<ol>
				<li>Какой нужен результат ?</li>
				<li>Решается ли задача, хотя бы на бумаге ?</li>
				<li>Алгоритмизация решения.</li>
			</ol>
			<p><b>Допустим</b>, вы уже решили ту или иную объемную задачу на бумаге, создали не только алгоритм решения, но и создали собственный python-пакет для обработки подобных задач в будущем.</p>
			<p>После этого вам наверняка понадобится протестировать свой пакет не только на ошибки, но и на избыточность кода, а также соблюдение отступов, синтаксиса и многого другого.</p>
			<p>Вы конечно можете создать отдельный файл скрипта, например &laquo;test.py&raquo; в конкретной директории вашего пакета и протестировать модуль или метод модуля отдельно, так сказать, вручную. <b>Однако, это мягко говоря неудобно!</b></p>
			<p>Для каждого модуля вам придётся мучиться не только с отдельными скриптами-тестами, но с импортом своих модулей в этих скриптах. Мало того, эти файлы-тесты будут включены в ваш пакет и мешать вам отлаживать его работу.</p>
			<p>Не говоря уже про попытку теста всего пакета в целом, ведь в этом случае - относительный импорт не работает и вам придется переместить ваш тест-скрипт на директорию выше, а может и вообще перед директорией вашего пакета. И так будет с каждым скриптом-тестом.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.1.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №1" />
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.2.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №2" />
			</div>
			<p>В результате вам всё-таки придётся создать отдельную директорию для тестирования своего кода, в которой вы и будете хранить все <b>скрипты-тесты</b> вашего кода.</p>
			<p><b><span style="color:Green;">Это как раз правильный подход!</span> Однако, есть нюансы.</b></p>
			<p>Вот тут то и начинается вся магия <b>&laquo;Абры-Кадабры&raquo;</b> с импортом, т.к. в этом случае <span style="color:Red;">относительный импорт - не работает!</span></p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.3.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №3" />
			</div>
			<p>Что же тогда делать и как решить такую задачу?</p>
			<p><span style="color:Green;">Всё решается буквально 1...2 строчками кода </span> <b>-</b> <span style="color:Red;">но их необходимо понимать, чтобы применять правильно.</span></p>
			<p><b>Но - обо всём по порядку!</b></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h1>Структура &laquo;проекта-примера&raquo;</h1>
			<h2>Общая структура.</h2>
			<p>Для примера пусть будет следующая структура проекта.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-1.png" class="fz__minimized" alt="клик для увеличения" title="Strukture Project" />
			</div>
			<div class="codeses">
				<pre>
.
└── pkg
    ├── compatible
    │   ├── functions.py
    │   ├── __init__.py
    │   ├── subpackage_a
    │   │   ├── a.py
    │   │   └── __init__.py
    │   ├── subpackage_b
    │   │   ├── b.py
    │   │   ├── __init__.py
    │   │   └── test-pathlib-1.py
    │   └── test.py
    ├── test.py
    └── tests
        ├── __init__.py
        ├── test-abs-path.py
        ├── test-pathlib-1.py
        ├── test-pathlib-2.py
        ├── test-pkg-simple.py
        ├── test.py
        └── tmp.txt</pre>
			</div>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h1>Cодержимое файлов &laquo;проекта-примера&raquo;</h1>
			<p>Определим содержимое всех указанных файлов-проекта. Для примера, пусть будет следующим.</p>
			<p>Пакет: <b>compatible</b></p>
			<p>Файл: <b>pkg/compatible/__init__.py</b></p>
			<p class="codes">
				from .functions import *</br>
				from .subpackage_a import *</br>
				from .subpackage_b import *
			</p>
			<p>Файл: <b>pkg/compatible/functions.py</b></p>
			<div class="codeses">
				<pre>
__all__ = ['getDateTimeStr']

from datetime import datetime

def getDateTimeStr(strFormat = "%d.%m.%Y-%H:%M:%S") -> str:
	dateTime = datetime.now()
	outDateTime = dateTime.strftime(strFormat)
	return outDateTime</pre>
			</div>
			<br>
			<hr>
			<br>
			<p>Под-пакет: <b>subpackage_a</b></p>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/__init__.py</b></p>
			<p class="codes">
				from .a import *
			</p>
			<p>Файл пакета <i>subpackage_a</i>: <b>pkg/compatible/subpackage_a/a.py</b></p>
			<div class="codeses">
				<pre>
__all__ = ['getPackageA']

from ..functions import *

def getPackageA():
	return 'Package A:' + getDateTimeStr()</pre>
			</div>
			<br>
			<hr>
			<br>
			<p>Под-пакет: <b>subpackage_b</b></p>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/__init__.py</b></p>
			<p class="codes">
				from .b import *
			</p>
			<p>Файл пакета <i>subpackage_b</i>: <b>pkg/compatible/subpackage_b/b.py</b></p>
			<div class="codeses">
				<pre>
__all__ = ['getPackageB']

from ..functions import *

def getPackageB():
	return 'Package B:' + getDateTimeStr()</pre>
			</div>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part4"></a></p>
			<h1>Импорт пакетов</h1>
			<h2>Простой импорт.</h2>
			<p>При относительном импорте в пакете мы обращаемся к заданному каталогу относительно текущего. Тогда почему при запуске скрипта мы всё равно не можем импортировать пакет или модуль пакета на уровень выше?</p>
			<p><b>Это немного ошибочное мнение.</b></p>
			<p>Дело в том, что модуль внутри пакета - по команде <i>import</i> или <i>from</i> обращается относительно себя. Между модулями или между пакетами такое относительное обращение вполне нормальное явление.</p>
			<p>Например, находясь в одном из подкаталогов пакета <i>compatible</i>: <b>from ..compatible.functions import getDateTimeStr</b></p>
			<p>При простом запуске скрипта, т.е. исполняемого файла, по команде <i>import</i> или <i>from</i> Python ищет пакеты по заданному наименованию в каталогах, которые заданны в <b>sys.path</b>. Относительного импорта при запуске python-скрипта нет. Поэтому при попытке относительного импорта в запускаемом скрипте мы видим различные ошибки.</p>
			<p><span style="color:Red;">Т.е. в запускаемом файле при импорте необходимо указывать именно наименование модуля, в то время как внутри пакета в модулях при импорте необходимо соблюдать относительность путей.</span></p>
			<p>Например: <b>import pathlib</b>, или <b>from pathlib import Path</b>.</p>
			<p>Оказывается, просто, необходимо добавить директорию родителя в данную переменную среды.</p>
			<p><b>Однако, остаётся ещё один вопрос:</b> <span style="color:Blue;">А какой именно каталог необходимо добавить: ../, ./ или абсолютный путь ?</span></p>
			<p>Давайте узнаем всё это на практике.</p>
			<p>Сначала добавим относительный путь и посмотрим - появился ли он в <b>sys.path</b>.</p>
			<p class="codes">
				import sys</br>
				sys.path.append('../')
			</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.4.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №4" />
			</div>
			<p>Есть.</p>
			<p>Теперь попробуем импортировать наш модуль.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.5.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №5" />
			</div>
			<p>Хм, ошибка. Может неправильно указали относительную директорию? Давайте попробуем с помощью модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.6.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №6" />
			</div>
			<p>Опять ошибка. Может опять относительность импорта указали не верно? Попробуем ещё раз.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-2.7.png" class="fz__minimized" alt="клик для увеличения" title="Import attempt №7" />
			</div>
			<p>Хм, снова ошибка.</p>
			<p><u>Однако, здесь не всё так просто, как показалось на первый взгляд.</u></p>
			<p><b>Давайте разбираться!</b></p>
			<hr>
			<h2>Абсолютные и относительные пути.</h2>
			<p>Давайте сначала посмотрим как получить полную директорию из относительной при помощи того же модуля <b>pathlib</b>.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-3.png" class="fz__minimized" alt="клик для увеличения" title="Относительные и абсолютные пути" />
			</div>
			<p>Хорошо. С директориями разобрались.</p>
			<p>Есть такая встроенная переменная как &laquo;<b>__file__</b>&raquo;. Она указавает на текущий скрипт.</p>
			<p>Добавим новый путь поиска пакетов и попробуем импортировать наш пакет. Заодно посмотрим на пространстфо имен запускаемого скрипта, а также пространство имен импортируемого модуля. Если всё получится в консоль будут выведены все указанные значения.</p>
			<div class="codeses">
				<pre>
import pathlib
import sys

sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

def main():
	for i in sys.path:
		print(i)
	import compatible
	print(dir(sys.modules[__name__]))
	print(dir(compatible), '\n')
	print(compatible.getPackageA())
	print(compatible.getPackageB())

if __name__ == '__main__':
	main()</pre>
			</div>
			<p>Смотрим на результат.</p>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-7.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.append" />
			</div>
			<p><span style="color:Green;">Ура! Заработало!</span></p>
			<p><span style="color:Brown;">Однако, такой способ добавления не совсем правильный!</span> Однако, вполне рабочий.</p>
			<p>Обратите внимание на то, что необходимый путь поиска добавился в последнюю строку в &laquo;<b>sys.path</b>&raquo;.</p>
			<p>Таким образом, <b>Python</b> сначала переберет все остальные пути поиска, и только в последнюю очередь будет обращаться к вашей заданной директории.</p>
			<p>Лучшим решением, будет - добавление вашей директории на первое место. С этим как раз и поможет метод <b>insert</b>.</p>
			<div class="codeses">
				<pre>
import pathlib
import sys

sys.path.insert(0, str(pathlib.Path(__file__).resolve().parent.parent))

def main():
	for i in sys.path:
		print(i)
	import compatible
	print(dir(sys.modules[__name__]))
	print(dir(compatible), '\n')
	print(compatible.getPackageA())
	print(compatible.getPackageB())

if __name__ == '__main__':
	main()

				</pre>
			</div>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/py-imports-8.png" class="fz__minimized" alt="клик для увеличения" title="sys.path.insert" />
			</div>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part5"></a></p>
			<h1>Сравнение <span style="color:Red;">&laquo;pathlib&raquo;</span> с модулями <span style="color:Red;">&laquo;os&raquo;</span> и <span style="color:Red;">&laquo;os.path&raquo;</span></h1>
			<p>Не все пары функций/методов ниже эквивалентны. Некоторые из них частично совпадают, некоторые имеют разную семантику. К ним относятся <i>os.path.abspath()</i> и <i>Path.resolve()</i>, <i>os.path.relpath()</i> и <i>Path.relative_to()</i>.</p>
			<p>Функция <i>os.path.abspath()</i> не разрешает символические ссылки, в то время как <i>Path.resolve()</i> это делает.</p>
			<p>Метод <i>Path.relative_to()</i> требует, чтобы путь <i>pathlib.Path</i> был подпутем аргумента, однако, <i>os.path.relpath()</i> этого не требует.</p>
			<p>Подробные примеры использования разберем в следующей главе.</p>
			<table>
				<caption>Эквивалентные функции модулей.</caption>
				<tr>
					<th>Функции модулей os и os.path</th>
					<th>Функции модуля pathlib</th>
				</tr>
				<tr>
					<td>os.path.abspath()</td>
					<td>Path.resolve()</td>
				</tr>
				<tr>
					<td>os.chmod()</td>
					<td>Path.chmod()</td>
				</tr>
				<tr>
					<td>os.mkdir()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.makedirs()</td>
					<td>Path.mkdir()</td>
				</tr>
				<tr>
					<td>os.rename()</td>
					<td>Path.rename()</td>
				</tr>
				<tr>
					<td>os.replace()</td>
					<td>Path.replace()</td>
				</tr>
				<tr>
					<td>os.rmdir()</td>
					<td>Path.rmdir()</td>
				</tr>
				<tr>
					<td>os.remove(), os.unlink()</td>
					<td>Path.unlink()</td>
				</tr>
				<tr>
					<td>os.getcwd()</td>
					<td>Path.cwd()</td>
				</tr>
			    <tr>
			        <td>os.path.exists()</td>
			        <td>Path.exists()</td>
			    </tr>
				<tr>
					<td>os.path.expanduser()</td>
					<td>Path.expanduser() и Path.home()</td>
				</tr>
				<tr>
					<td>os.listdir()</td>
					<td>Path.iterdir()</td>
				</tr>
				<tr>
					<td>os.path.isdir()</td>
					<td>Path.is_dir()</td>
				</tr>
				<tr>
					<td>os.path.isfile()</td>
					<td>Path.is_file()</td>
				</tr>
				<tr>
					<td>os.path.islink()</td>
					<td>Path.is_symlink()</td>
				</tr>
				<tr>
					<td>os.link()</td>
					<td>Path.hardlink_to()</td>
				</tr>
				<tr>
					<td>os.symlink()</td>
					<td>Path.symlink_to()</td>
				</tr>
				<tr>
					<td>os.readlink()</td>
					<td>Path.readlink()</td>
				</tr>
				<tr>
					<td>os.path.relpath()</td>
					<td>Path.relative_to()</td>
				</tr>
				<tr>
					<td>os.stat()</td>
					<td>Path.stat(), Path.owner(), Path.group()</td>
				</tr>
				<tr>
					<td>os.path.isabs()</td>
					<td>PurePath.is_absolute()</td>
				</tr>
				<tr>
					<td>os.path.join()</td>
					<td>PurePath.joinpath()</td>
				</tr>
				<tr>
					<td>os.path.basename()</td>
					<td>PurePath.name</td>
				</tr>
				<tr>
					<td>os.path.dirname()</td>
					<td>PurePath.parent</td>
				</tr>
				<tr>
					<td>os.path.samefile()</td>
					<td>Path.samefile()</td>
				</tr>
				<tr>
					<td>os.path.splitext()</td>
					<td>PurePath.suffix</td>
				</tr>
			</table>
			<br>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part6"></a></p>
			<h1>Библиотека <span style="color:Red;">&laquo;pathlib&raquo;</span>. Примеры использования на практике</h1>
			<p>Каждая операционная система имеет разные правила построения путей к файлам. Например, Linux использует прямые косые черты для путей, в то время как Windows использует обратную косую черту.</p>
			<p>Это небольшое различие может вызвать проблемы, если вы работаете над проектом и хотите, чтобы другие разработчики из разных операционных систем расширили ваш код.</p>
			<p>К счастью, если вы пишете на Python, модуль Pathlib выполняет тяжелую работу, позволяя вам убедиться, что ваши пути к файлам работают одинаково в разных операционных системах. Кроме того, он предоставляет функциональные возможности и операции, которые помогут вам сэкономить время при обработке и манипулировании путями.</p>
			<p>Откройте файл и введите следующее содержимое:</p>
			<p class="codes">
				import pathlib<br><br>
				p = pathlib.Path(__file__)<br>
				print(type(p), ':', p)
			</p>
			<p>Сохраните и запустите. У меня вывод получился следующий:</p>
			<p class="codes">
				mikl ~/003/Primer $ python main.py<br>
				&#8249;class 'pathlib.PosixPath'&#8250; : /home/mikl/003/Primer/main.py
			</p>
			<p>Как показано выше, Pathlib создает путь к этому файлу, помещая этот конкретный скрипт в объект Path. Pathlib разделяет пути файловой системы на два разных класса, которые представляют два типа объектов path: чистый путь и конкретный путь.</p>
			<div class="imageClear">
				<img src="https://maximalisimus.github.io/Articles/image/Python-Imports_image/pathlib-diagram.png" width="512px" />
			</div>
			<p>Чистый путь предоставляет утилиты для обработки и управления вашим путем к файлу без выполнения операций записи, в то время как конкретный путь позволяет вам манипулировать и выполнять операции записи в вашем пути к файлу.</p>
			<p>Другими словами, конкретный путь является подклассом чистого пути. Он наследует манипуляции от родительского класса и добавляет операции ввода / вывода, которые выполняют системные вызовы.</p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p>Python 3 включает модуль pathlib для манипуляции путями файловых систем независимо от операционной системы. pathlib похож на модуль os.path, но pathlib предлагает более развитый и удобный интерфейс по сравнению с os.path. Т.е. этот модуль объединяет в себе часто используемые функции двух стандартных модулей os и os.path, а так же стандартную функцию open() для чтения файла и записи в файл какой либо информации.</p>
			<p>Модуль pathlib предлагает классы, представляющие пути файловой системы подходящей для различных операционных систем. </p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="partN"></a></p>
			<h1>Part-1 H1</h1>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="partN"></a></p>
			<h1>Part-1 H1</h1>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p class="codes">
				
			</p>
			<div class="codeses">
				<pre>

				</pre>
			</div>
			<div class="codeses">
				<pre>
<span style="color:blue;">#!/bin/bash</span>
...
script
...
<span style="color:blue;"># echo "result"</span>
				</pre>
			</div>
			<ul>
				<li><span style="color:Blue;">Blue</span></li>
				<li>Black</li>
				<li><span style="color:Red;">Reed</span></li>
				<li><span style="color:Yellow;">Yellow</span></li>
				<li><span style="color:Green;">Green</span></li>
			</ul>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<div id="page" class="clearfix">
				<img src="https://maximalisimus.github.io/Articles/image/image-0.jpg" class="fz__minimized" alt="клик для увеличения" title="Title" />
			</div>
			<hr>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
