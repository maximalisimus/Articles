<html>
<head>
	<meta charset="utf-8">
	<title>Мультизагрузка</title>
	<link rel="icon" href="../image/Multiboot/multiboot-icon.png">
	<!--
		<link rel="icon" href="image/favicon.png">
		<link rel="shortcut icon" href="js-css/404-2.ico" Type="image/x-icon">
		type="image/png"
		<link rel="shortcut icon" href="favicon.png" type="image/png">
		<link rel="icon" href="image/favicon.svg" type=" image/svg+xml">
	-->
	<link rel="stylesheet" href="../html/main.css" type="text/css">	
	<link rel="stylesheet" href="../html/zoom.css" type="text/css">
	<link rel="stylesheet" href="../html/table.css" type="text/css">
	<link rel="stylesheet" href="../html/frame.css">
	<link rel="stylesheet" href="../html/ol-li.css" type="text/css">
	<!-- <link rel="stylesheet" href="html/ol-li.css" type="text/css"> -->
	<script src="../html/jquery.2.2.0.min.js"></script>
	<script type="text/javascript" src="../html/litezoom.js"></script>
</head>
<body>
	<div class="site">
		<div class="header">
			<div id="logo">
				<p style="margin:10px; padding:0px;">Мультизагрузка</p>
			</div>
		</div>
		<div class="content">
			<center>
				<div class="images">
					<img src="../image/Multiboot/mbr-vs-gpt.png" width="500px"/>
				</div>
				<div style="clear:both"></div>
			</center>
		</div>
		<div class="content">
			<p><a name="oglavlenie"></a></p>
			<h2>Оглавление</h2>
			<ol>
				<li><a href="#part1">Теория</a></li>
				<ol>
					<li><a href="#part1.1">Загрузчики</a></li>
					<li><a href="#part1.2">Таблица разделов</a></li>
					<li><a href="#part1.3">MBR / PBR</a></li>
					<li><a href="#part1.4">UEFI</a></li>
					<li><a href="#part1.5">GRUB4DOS, SYSLINUX, GRUB2</a></li>
					<li><a href="#part1.6">rEFInd</a></li>
					<li><a href="#part1.7">BCD (Boot Configuration Data)</a></li>
					<li><a href="#part1.8">Файлы</a></li>
					<ol>
						<li><a href="#part1.8.1">Различные типы файлов</a></li>
						<li><a href="#part1.8.2">Содержимое файлов</a></li>
						<li><a href="#part1.8.3">Различия между Windows и Linux</a></li>
						<li><a href="#part1.8.4">Команда source в Linux</a></li>
						<li><a href="#part1.8.5">BAT/CMD файлы в Windows</a></li>
					</ol>
					<li><a href="#part1.9">Текстовые файлы</a></li>
				</ol>
				<li><a href="#part2">Програмное обеспечение</a></li>
				<li><a href="#part3">Практика</a></li>
			</ol>
		</div>
		<div class="content">
			<p><a name="part1"></a></p>
			<h2>1. Теория</h2>
			<p><a name="part1.1"></a></p>
			<h3>1.1. Загрузчики</h3>
			<p>В основе работы загрузчиков лежит выполнение специального кода, который указывает, откуда и что загружать.</p>
			<p>Важно понимать несколько ключевых моментов:</p>
			<ol>
				<li><b>MBR и PBR — это места на носителе, где хранится загрузочный код.</b></li>
				<ul>
					<li><b>MBR (Master Boot Record)</b> — первый сектор диска (512 байт), содержит таблицу разделов и первичный загрузчик, который запускается первым при старте системы. Он либо сам загружает ОС, либо передаёт управление загрузчику, расположенному в PBR активного раздела.</li>
					<li><b>PBR (Partition Boot Record)</b> — первый сектор конкретного раздела, содержит вторичный загрузчик, который уже загружает ядро ОС или следующий этап загрузки.</li>
				</ul>
				<li><b>Сам файл загрузчика — это исполняемый код, который может находиться в MBR, PBR или в файловой системе (например, EFI-загрузчик в ESP разделе).</b></li>
				<li><b>Загрузчик указывает, откуда грузить — с MBR, PBR или EFI-раздела — и какой именно загрузчик или ядро запускать.</b></li>
				<li><b>Разные загрузчики могут использовать разные подходы, но суть одна — они обеспечивают цепочку передачи управления от прошивки или BIOS к операционной системе.</b></li>
			</ol>
			<p>Все загрузчики работают по схожему принципу: выполняется код загрузчика, который указывает, откуда и что загружать дальше — с MBR, PBR или EFI-раздела.</p>
			<p>Важно не только сам файл загрузчика, но и место его расположения (MBR, PBR, ESP), а также способ взаимодействия с прошивкой (BIOS или UEFI).</p>
			<p>Загрузчик — это связующее звено, которое управляет процессом загрузки, передавая управление от начального кода к ядру ОС или другому загрузчику.</p>
			<p>Например, первичный загрузчик в MBR может передать управление загрузчику в PBR активного раздела, а тот уже загрузит ОС. В UEFI-системах загрузчик находится в специальном разделе ESP и запускается напрямую прошивкой.</p>
			<p>Этот файл содержит инструкции, как и откуда загружать операционную систему или следующий загрузчик. Например, GRUB2, SYSLINUX, rEFInd — это разные загрузчики, которые могут запускаться с разных мест и по-разному управлять процессом загрузки.</p>
			<p><u><i>Любой носитель информации — будь то SSD (SATA или NVMe), HDD, USB-флешка, microSD, встроенная память смартфона или планшета — устроены примерно одинаково с точки зрения хранения данных: это набор ячеек памяти, организованных в блоки и разделы, на которых записываются файлы и системные данные.</i></u></p>
			<p><u><b>Для загрузки операционной системы важен именно загрузчик — специальный код, который запускается при включении устройства и указывает, откуда и как загружать ОС.</b></u></p>
			<p>В ПК это может быть код в MBR, PBR или EFI System Partition (ESP) для UEFI-систем. В смартфонах и планшетах тоже есть свои загрузчики (bootloader), которые запускают ОС, но архитектура и способы загрузки могут отличаться.</p>
			<p>Загрузочный файл или код — это ключевой элемент, который определяет процесс загрузки, независимо от типа носителя или устройства. Он указывает, где искать ядро ОС, как передать управление и какие параметры использовать.</p>
			<p>Однако устройства могут иметь разные архитектуры, прошивки и способы загрузки:</p>
			<ul>
				<li>ПК обычно используют BIOS/UEFI с MBR/PBR или ESP.</li>
				<li>Смартфоны и планшеты на базе ARM используют свои загрузчики (например, U-Boot, Little Kernel и др.), которые работают иначе, но тоже выполняют функцию запуска ОС с определённого места памяти.</li>
			</ul>
			<p><b>Итог.</b></p>
			<ul>
				<li><b>Все носители устроены примерно одинаково с точки зрения хранения данных, но важен именно загрузчик — код, который запускается первым и управляет процессом загрузки ОС.</b></li>
				<li><b>Загрузочный файл (или код) определяет, откуда и как загружать систему, будь то ПК, смартфон или планшет.</b></li>
				<li><b>Различия в устройствах и архитектурах влияют на конкретные реализации загрузчиков, но общая идея — наличие загрузчика, указывающего путь загрузки — универсальна.</b></li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.2"></a></p>
			<h3>1.2. Таблица разделов</h3>
			<p><b>Что такое таблица разделов, где она хранится и зачем нужна?</b></p>
			<p><b>Таблица разделов</b> — это специальная структура данных на физическом накопителе (жестком диске, SSD, флешке и т.п.), которая содержит информацию обо всех разделах диска: где они начинаются, где заканчиваются, какого типа и как называются. Она нужна, чтобы операционная система и загрузчик понимали, как организовано пространство на диске и где искать данные или операционные системы.</p>
			<p>Таблица разделов хранится в определённой области диска, в зависимости от типа таблицы:</p>
			<ul>
				<li>В <b>MBR</b> таблица разделов находится в первом секторе диска (512 байт), вместе с загрузочным кодом.</li>
				<li>В <b>GPT</b> таблица разделов занимает несколько секторов в начале диска и имеет резервную копию в конце диска для повышения надёжности.</li>
			</ul>
			<p><b>Что такое MBR и GPT?</b></p>
			<p><b>MBR (Master Boot Record)</b> — это традиционный формат таблицы разделов, который хранится в первом секторе диска. В MBR содержится:</p>
			<ul>
				<li>Загрузочный код (первичный загрузчик).</li>
				<li>Таблица разделов с максимум 4 основными разделами.</li>
			</ul>
			<p>Ограничения MBR:</p>
			<ul>
				<li>Максимальный размер диска — около 2,2 ТБ.</li>
				<li>Максимум 4 основных раздела (для большего количества нужно использовать расширенные разделы).</li>
				<li>Отсутствие резервных копий таблицы разделов, что снижает надёжность.</li>
			</ul>
			<p><b>GPT (GUID Partition Table)</b> — современный стандарт таблицы разделов, разработанный для замены MBR. Особенности GPT:</p>
			<ul>
				<li>Использует уникальные идентификаторы (GUID) для каждого раздела.</li>
				<li>Поддерживает до 128 разделов без необходимости расширенных разделов.</li>
				<li>Поддерживает диски размером до 9,4 зеттабайт (гораздо больше, чем MBR).</li>
				<li>Хранит несколько копий таблицы разделов (в начале и в конце диска) для повышения надёжности и возможности восстановления.</li>
				<li>Является частью стандарта UEFI, который заменяет BIOS в современных компьютерах.</li>
			</ul>
			<p><b>Итог</b></p>
			<ul>
				<li><b>Таблица разделов</b> — это карта диска, которая показывает, как разделено пространство на носителе.</li>
				<li><b>MBR</b> — старый формат таблицы разделов с ограничениями по размеру и количеству разделов, хранится в первом секторе диска.</li>
				<li><b>GPT</b> — современный, более надёжный и гибкий формат, поддерживающий большие диски и большее число разделов, с резервными копиями таблицы.</li>
				<li>Выбор между MBR и GPT зависит от типа системы (BIOS или UEFI), размера диска и требований к надёжности и функционалу.</li>
			</ul>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.3"></a></p>
			<h3>1.3. MBR / PBR</h3>
			<p><b>Что такое первичный и вторичный загрузчики MBR и PBR?</b></p>
			<p><b>MBR (Master Boot Record)</b> — это специальный первый сектор на физическом носителе (обычно на жестком диске, но может быть и любая флешка, microSD, любой SSD), который содержит код загрузчика и таблицу разделов диска. В MBR записывается первичный загрузчик, который запускается при включении компьютера. Его задача — начать процесс загрузки операционной системы.</p>
			<ul>
				<li><b>Первичный загрузчик в MBR</b> — это небольшой код, записанный в первый сектор диска (512 байт). Он выполняет минимальные действия: обычно проверяет таблицу разделов и передает управление вторичному загрузчику, который находится в одном из разделов диска. Этот первичный загрузчик работает в реальном режиме процессора и очень ограничен по размеру и функционалу.</li>
			</ul>
			<p><b>PBR (Partition Boot Record)</b> — это загрузочный сектор конкретного раздела диска. В нем находится вторичный загрузчик, который более сложный и отвечает за загрузку операционной системы из конкретного раздела.</p>
			<ul>
				<li><b>Вторичный загрузчик в PBR</b> загружается после первичного загрузчика MBR. Он располагается в первом секторе раздела и может содержать более развернутый код, который уже умеет работать с файловой системой, загружать ядро ОС и выполнять другие задачи. Вторичный загрузчик загружает и запускает операционную систему или следующий этап загрузки.</li>
			</ul>
			<p>Кратко о процессе загрузки.</p>
			<ol>
				<li>При включении питания BIOS/UEFI ищет MBR на первом секторе диска.</li>
				<li>Выполняется <b>первичный загрузчик MBR</b> — он анализирует таблицу разделов и выбирает активный раздел.</li>
				<li>Управление передается <b>вторичному загрузчику PBR</b> этого раздела.</li>
				<li>Вторичный загрузчик загружает операционную систему.</li>
			</ol>
			<p><b>Итог.</b></p>
			<ul>
				<li><b>Первичный загрузчик</b> — код в MBR, запускается первым, минимален и отвечает за выбор раздела.</li>
				<li><b>Вторичный загрузчик</b> — код в PBR, более функционален, загружает ОС из выбранного раздела.</li>
			</ul>
			<p><b><u>Так устроена классическая схема загрузки с использованием MBR и PBR на любом носителе с разделами. Причем, на любом носителе при любой таблице разделов всегда есть хотя бы 1 раздел.</u></b></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.4"></a></p>
			<h3>1.4. UEFI</h3>
			<p><b>Что такое EFI загрузка?</b></p>
			<p><b>EFI (Extensible Firmware Interface)</b> или точнее <b>UEFI (Unified EFI)</b> — это современный интерфейс между прошивкой компьютера и операционной системой, который заменяет традиционный BIOS. В отличие от BIOS, UEFI поддерживает более гибкую и мощную систему загрузки.</p>
			<p>При загрузке с UEFI:</p>
			<ul>
				<li>Прошивка UEFI ищет специальный раздел на диске — EFI System Partition (ESP).</li>
				<li>Этот раздел содержит загрузочные файлы в формате .efi — исполняемые программы, которые запускают загрузку операционной системы.</li>
				<li>UEFI загружает и выполняет эти файлы напрямую, минуя ограниченный код BIOS/MBR.</li>
			</ul>
			<p><b>Почему носитель должен быть отформатирован в FAT32?</b></p>
			<p>Стандарт UEFI требует, чтобы EFI System Partition была отформатирована в файловой системе FAT32 (для сменных носителей допускается FAT16 или FAT12, но FAT32 — самый распространённый вариант).</p>
			<p>Причина в том, что UEFI прошивка содержит встроенную поддержку чтения FAT32, но не поддерживает другие файловые системы, например NTFS или exFAT, на этапе загрузки.</p>
			<p>Если носитель отформатирован в NTFS, UEFI не сможет прочитать загрузочные файлы, и загрузка не произойдет без дополнительных ухищрений (например, специальных драйверов или загрузчиков).</p>
			<p><b>FAT32 — это универсальная, простая и широко поддерживаемая файловая система, которая гарантирует совместимость с UEFI.</b></p>
			<p>Пример структуры загрузочного носителя для UEFI:</p>
			<ul>
				<li>На USB-флешке или разделе диска создаётся раздел EFI System Partition, отформатированный в FAT32.</li>
				<li>В корне этого раздела создаётся папка <b>&laquo;EFI/BOOT&raquo;</b>.</li>
				<li>В эту папку помещается загрузочный файл, например <b>&laquo;BOOTx64.EFI&raquo;</b> — стандартное имя для 64-битных систем.</li>
				<li>При загрузке UEFI ищет этот файл и запускает его, начиная процесс загрузки ОС.</li>
			</ul>
			<p>В 32 битных системах UEFI ищет в той же самой папке файл <b>&laquo;BOOTia32.EFI&raquo;</b></p>	
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.5"></a></p>
			<h3>1.5. GRUB4DOS, SYSLINUX, GRUB2</h3>
			<p><b>Что такое GRUB4DOS, SYSLINUX и GRUB2?</b></p>
			<p>Мультизагрузочные флешки создаются для того, чтобы с одного USB-носителя можно было загружать разные операционные системы, утилиты восстановления, установщики и т.п.</p>
			<p>Для этого на флешку устанавливают загрузчик (GRUB4DOS, SYSLINUX или GRUB2), который при старте показывает меню с выбором, что именно загрузить.</p>
			<p>GRUB4DOS часто используют из-за его гибкости и возможности загружать ISO-образы напрямую, а также из-за поддержки старых BIOS-систем.</p>
			<p>SYSLINUX применяют для простых загрузочных флешек с Linux, где не требуется сложное меню или поддержка UEFI.</p>
			<p>GRUB2 выбирают для более сложных задач, особенно если нужна поддержка UEFI, работа с разными файловыми системами и расширенные возможности меню загрузки.</p>
			<p>Иногда на одной флешке комбинируют несколько загрузчиков, например, GRUB4DOS и SYSLINUX, чтобы расширить совместимость и функционал.</p>
			<ul>
				<li><b>GRUB4DOS</b> — это загрузчик, основанный на GNU GRUB, который умеет загружать операционные системы и ISO-образы с флешек и других носителей. Он поддерживает работу в режиме BIOS и позволяет создавать удобные меню загрузки с множеством вариантов. GRUB4DOS часто используется для мультизагрузочных флешек, так как умеет "притворяться" дисководом и загружать разные образы напрямую.</li>
				<li><b>SYSLINUX</b> — это простой и легковесный загрузчик, который часто применяется для загрузки с FAT-разделов, например, с USB-флешек. Он хорошо подходит для создания загрузочных флешек с Linux-дистрибутивами и другими утилитами. SYSLINUX умеет создавать простые меню и быстро загружать ядро ОС.</li>
				<li><b>GRUB2</b> — это современный и мощный загрузчик, преемник оригинального GRUB. Он поддерживает как BIOS, так и UEFI загрузку, умеет работать с разными файловыми системами, загружать ядра Linux, Windows и другие ОС, а также монтировать ISO-образы. GRUB2 часто используется для создания мультизагрузочных флешек с большим количеством вариантов загрузки и гибкой настройкой меню.</li>
			</ul>		
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.6"></a></p>
			<h3>1.6. rEFInd</h3>
			<p><b>Что такое rEFInd и зачем он нужен?</b></p>
			<p><b>rEFInd</b> — это современный загрузочный менеджер для систем с UEFI/EFI, который позволяет удобно выбирать между несколькими установленными операционными системами на одном устройстве. Он является форком более старого проекта rEFIt и отличается простотой, красивым графическим интерфейсом и автоматическим обнаружением ОС без сложной настройки.</p>
			<p>Основные преимущества rEFInd:</p>
			<ul>
				<li>Автоматически находит все установленные ОС и их загрузчики.</li>
				<li>Поддерживает запуск UEFI-приложений.</li>
				<li>Имеет удобное и настраиваемое графическое меню.</li>
				<li>Легко устанавливается и обновляется.</li>
				<li>Более современный и легкий по сравнению с GRUB2, особенно в UEFI-среде.</li>
			</ul>
			<p>Почему и как комбинируют rEFInd, GRUB2, GRUB4DOS и SYSLINUX?</p>
			<p>В реальных мультизагрузочных сценариях часто используют комбинацию нескольких загрузчиков, чтобы обеспечить максимальную совместимость и гибкость:</p>
			<ul>
				<li>rEFInd выступает как первичный загрузочный менеджер в UEFI-системах. Он автоматически находит и запускает загрузчики других ОС, включая GRUB2, Windows Boot Manager и даже SYSLINUX или GRUB4DOS, если они установлены на разных разделах или флешках.</li>
				<li>GRUB2 часто используется как загрузчик внутри Linux-систем, который умеет загружать ядро, initrd и другие ОС. rEFInd может запускать GRUB2, который в свою очередь может загружать разные ядра и конфигурации.</li>
				<li>GRUB4DOS и SYSLINUX обычно применяются для загрузки с флешек или в BIOS-режиме, особенно для мультизагрузочных USB-носителей с утилитами и установщиками. rEFInd может запускать их через цепочку загрузки, обеспечивая удобный выбор между UEFI и BIOS-загрузкой.</li>
			</ul>
			<p>Такая комбинация позволяет:</p>
			<ul>
				<li>Использовать преимущества UEFI и rEFInd для удобного графического меню и автоматического обнаружения ОС.</li>
				<li>Поддерживать загрузку старых систем и утилит, которые требуют BIOS-режима или специфичных загрузчиков (GRUB4DOS, SYSLINUX).</li>
				<li>Создавать универсальные флешки и диски, которые работают на разных компьютерах с разными прошивками и режимами загрузки.</li>
			</ul>
			<p><b>Почему rEFInd не всегда удобен и почему от него часто отказываются на флешках в пользу комбинации GRUB2 + GRUB4DOS + SYSLINUX?</b></p>
			<p>Хотя rEFInd — современный и красивый загрузчик для UEFI, на практике он не всегда оказывается удобным и надежным для использования на мультизагрузочных флешках. Вот основные причины:</p>
			<ol>
				<li><b>Ограничение только UEFI</b></li>
				<p>rEFInd работает только в UEFI-режиме и не поддерживает BIOS (Legacy) загрузку. Многие флешки и компьютеры требуют поддержки обоих режимов, чтобы быть универсальными. В то время как GRUB4DOS и SYSLINUX отлично работают в BIOS-режиме, rEFInd не может заменить их полностью.</p>
				<li><b>rEFInd часто просто запускает GRUB</b></li>
				<p>На практике rEFInd часто используется как &laquo;первичный&raquo; загрузчик, который просто запускает GRUB2, а уже GRUB2 выполняет основную работу по загрузке ОС и управлению меню. То есть rEFInd не всегда выполняет всю работу самостоятельно, а служит лишь &laquo;переходником&raquo;.</p>
				<li><b>Сложности с настройкой и совместимостью</b></li>
				<p>Настройка rEFInd может быть сложной, особенно если нужно управлять загрузкой с разных носителей, флешек и разделов. Иногда он не всегда корректно распознает все загрузочные образы или не позволяет гибко настраивать меню, что неудобно для мультизагрузочных флешек.</p>
				<li><b>Проблемы с порядком загрузки и приоритетами</b></li>
				<p>rEFInd может "навязывать" себя первым в списке загрузки UEFI, что не всегда удобно, особенно если флешка используется на разных компьютерах с разными настройками прошивки. Это требует дополнительной настройки, чтобы rEFInd не мешал загрузке с других устройств.</p>
				<li><b>Отсутствие поддержки BIOS и ограниченная поддержка файловых систем</b></li>
				<p>SYSLINUX и GRUB4DOS обеспечивают отличную поддержку BIOS-режима и работу с FAT32 и другими файловыми системами, что важно для загрузочных флешек с утилитами и старыми ОС. rEFInd же ориентирован на UEFI и FAT32 ESP-разделы, что ограничивает его универсальность.</p>
			</ol>
			<p><b>Почему выбирают комбинацию GRUB2 + GRUB4DOS + SYSLINUX на флешках?</b></p>
			<ul>
				<li><b>Максимальная совместимость</b> — комбинация этих загрузчиков позволяет работать и в BIOS, и в UEFI режимах, что делает флешку универсальной для разных компьютеров.</li>
				<li><b>Гибкость и функциональность</b> — GRUB2 обеспечивает мощные возможности загрузки и меню, GRUB4DOS позволяет загружать ISO-образы и работать с BIOS, SYSLINUX — простой и быстрый загрузчик для Linux-образов.</li>
				<li><b>Надежность и проверенность</b> — эти загрузчики давно используются и хорошо документированы, их проще настроить под конкретные задачи мультизагрузки.</li>
				<li><b>Возможность цепочки загрузки</b> — например, SYSLINUX или GRUB4DOS могут запускаться из GRUB2, обеспечивая удобное меню и поддержку разных форматов.</li>
			</ul>
			<p><b>rEFInd</b> — отличный загрузчик для UEFI с красивым интерфейсом, но он ограничен только UEFI, сложен в настройке и часто просто запускает GRUB, не заменяя его полностью. Поэтому на мультизагрузочных флешках часто отказываются от rEFInd в пользу комбинации <b>GRUB2 + GRUB4DOS + SYSLINUX</b>, которая обеспечивает поддержку и BIOS, и UEFI, гибкость, надежность и удобство работы с разными ОС и утилитами.</p>	
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.7"></a></p>
			<h3>1.7. BCD (Boot Configuration Data)</h3>
			<p><b>Что такое BCD в Windows?</b></p>
			<p><b>BCD (Boot Configuration Data)</b> — это специальный файл конфигурации загрузчика Windows, который содержит информацию о доступных операционных системах, параметрах их загрузки и порядке выбора. По сути, это современный аналог старого файла boot.ini, но с более гибкой структурой и возможностями.</p>
			<ul>
				<li>В системах с UEFI загрузчик Windows (BOOTMGR) находится в папке EFI\BOOT на скрытом разделе ESP, а сам файл BCD лежит в EFI\MICROSOFT\BOOT.</li>
				<li>BCD управляет тем, какие записи загрузки отображаются в меню при старте, какие параметры передаются ОС, и как происходит выбор между несколькими системами.</li>
			</ul>
			<p>Почему BOOTICE удобен для редактирования BCD, особенно на мультизагрузочных флешках?</p>
			<p><b>BOOTICE</b> — это мощный и компактный инструмент для работы с загрузочными записями и разделами, который особенно популярен среди специалистов и энтузиастов, создающих мультизагрузочные флешки.</p>
			<ul>
				<li>В простом режиме BOOTICE позволяет быстро и удобно редактировать файл BCD без сложных команд и глубоких знаний структуры файла.</li>
				<li>Программа умеет работать как с BIOS-загрузкой (MBR/PBR), так и с UEFI-загрузкой (раздел ESP и BCD), что делает её универсальной для флешек, которые должны работать на разных системах.</li>
				<li>BOOTICE позволяет легко переключаться между разными меню загрузки, которые могут находиться в разных местах флешки — например, BIOS-меню в MBR/PBR и UEFI-меню в разделе ESP с BCD.</li>
				<li>Утилита также поддерживает резервное копирование и восстановление MBR/PBR, что важно для сохранения работоспособности загрузчика при экспериментах с мультизагрузкой.</li>
				<li>Благодаря графическому интерфейсу и простоте использования, BOOTICE часто выбирают для быстрой настройки и правки загрузочных записей без необходимости использовать сложные консольные команды или сторонние программы.</li>
			</ul>
			<p><b>BCD</b> — ключевой файл конфигурации загрузчика Windows, управляющий меню и параметрами загрузки ОС.</p>
			<p><b>BOOTICE</b> удобен тем, что позволяет легко и быстро редактировать BCD и другие загрузочные записи как для BIOS (MBR/PBR), так и для UEFI (ESP-раздел), что особенно важно для мультизагрузочных флешек.</p>
			<p>Возможность работать с обоими режимами загрузки и редактировать меню из разных мест на флешке делает BOOTICE незаменимым инструментом для создания универсальных загрузочных USB-носителей.</p>	
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.8"></a></p>
			<h3>1.8. Файлы</h3>
			<p><a name="part1.8.1"></a></p>
			<h4>1.8.1. Различные типы файлов</h4>
			<p><b>Что такое бинарный файл?</b></p>
			<p><b>Бинарный файл</b> — это файл, который содержит данные в виде последовательности байтов, не обязательно интерпретируемых как текст. Эти байты могут представлять любую информацию: текст, изображение, звук, видео или исполняемую программу. В отличие от текстовых файлов, бинарные файлы могут содержать любые значения байтов, включая нулевые, которые в текстовых файлах обычно отсутствуют.</p>
			<p><b>Что такое шестнадцатеричный код выполнения и ассемблерный код?</b></p>
			<ul>
				<li>Шестнадцатеричный код выполнения — это представление бинарных данных файла в шестнадцатеричной системе счисления. Это удобный способ просмотра и редактирования содержимого бинарных файлов, так как каждый байт отображается как два шестнадцатеричных символа (от 00 до FF). Такой код часто используется в хекс-редакторах для анализа и модификации файлов.</li>
				<li>Ассемблерный код — это низкоуровневый программный код, который близок к машинным инструкциям процессора, но более читаем для человека. Ассемблерный код обычно получается из бинарного файла (например, исполняемого) с помощью дизассемблера. Он показывает, какие именно инструкции выполняет процессор.</li>
			</ul>
			<p>Зачем нужны ResHacker и Restorator?</p>
			<p>ResHacker (Resource Hacker) и Restorator — это инструменты для просмотра и редактирования ресурсов внутри исполняемых файлов Windows (например, иконок, меню, диалогов, строк и т.п.). Они позволяют изменять интерфейс программ без перекомпиляции исходного кода, что полезно для локализации, кастомизации или создания патчей.</p>
			<p><b>Можно ли любой файл просматривать как текстовый и писать в файл изображения любой текст?</b></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.8.2"></a></p>
			<h4>1.8.2. Содержимое файлов</h4>
			<p><b>Можно ли любой файл просматривать как текстовый и писать в файл изображения любой текст?</b></p>
			<p>Технически любой файл можно открыть и просмотреть как текст, но содержимое бинарного файла в текстовом виде будет выглядеть как набор непонятных символов, так как многие байты не соответствуют печатным символам.</p>
			<p>Аналогично, Можно ли дописывать текст в конец файла изображения?</p>
			<p>Да, технически в любой файл, включая изображение (например, JPG), можно дописать произвольные данные в конец файла.</p>
			<p>Форматы изображений, как правило, при чтении ориентируются на заголовок и структуру данных внутри файла, поэтому дополнительные данные в конце часто игнорируются программами просмотра изображений и не влияют на отображение картинки.Это свойство используется в различных задачах, например:</p>
			<ul>
				<li>Скрытие информации (стеганография) — прятать текст или другие данные внутри изображения.</li>
				<li>Данные проще спрятать — есть игры, где нужно найти &laquo;ключ&raquo; или подсказку, спрятанную в конце JPG или PNG файла, чтобы перейти к следующему уровню.</li>
			</ul>
			<p><b>Почему это работает?</b></p>
			<p>Форматы изображений, например JPEG, имеют чётко определённую структуру и маркеры конца файла.</p>
			<p>Дополнительные данные после конца файла обычно игнорируются стандартными программами.</p>
			<p>Поэтому можно &laquo;дописать&raquo; текст в конец файла, и при этом изображение останется корректно отображаться.</p>
			<p>В Linux системах в любой файл в самый конец можно дописать что угодно в виде комментария через решетку &laquo;#&raquo;, что строка не воспринималась никаким кодом.</p>
			<p>Патчи и кряки часто создаются путем изменения бинарного содержимого файлов  — например, с помощью хекс-редакторов или специализированных инструментов (дизассемблеров, редакторов ресурсов). Вносятся изменения в машинный код или ресурсы программы, чтобы изменить её поведение, убрать защиту или добавить новые функции. Это требует понимания структуры файла и кода, а не просто записи текста в файл.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.8.3"></a></p>
			<h4>1.8.3. Различия между Windows и Linux</h4>
			<p><b>Типы файлов и их обработка.</b></p>
			<p>В Windows действительно существует множество форматов файлов (например, .exe, .dll, .docx, .jpg и т.д.), и для каждого формата обычно используется своё программное обеспечение. Windows ориентирована на ассоциации файлов с программами, и расширение файла играет важную роль в определении, как его открыть.</p>
			<p>В Linux ситуация другая: файловая система рассматривает практически всё как файл — включая устройства, процессы и т.д. Однако не все файлы текстовые. В Linux есть как текстовые файлы (например, скрипты, конфигурации), так и бинарные (исполняемые программы, библиотеки). Важным критерием для исполнения файла является флаг &laquo;исполняемый&raquo; (execute permission) в правах доступа, а не расширение файла. То есть, чтобы файл можно было запустить, он должен иметь соответствующие права, а не обязательно иметь определённое расширение.</p>
			<p><b>Файловая система и структура.</b></p>
			<p>В Linux используется единая иерархия каталогов, где всё начинается с корня /. Устройства и ресурсы представлены как файлы в этой структуре.</p>
			<p>В Windows файловая система построена на буквах дисков (C:, D: и т.д.), и устройства обычно не представлены как файлы.</p>
			<p><b>Исполняемые файлы.</b></p>
			<p>В Windows исполняемые файлы обычно имеют расширение .exe или .dll, и система ориентируется на расширение для запуска.</p>
			<p>В Linux исполняемый файл — это файл с установленным флагом исполнения, независимо от расширения. Например, скрипт без расширения может быть исполняемым, если у него есть соответствующие права.</p>
			<p><b>Итог.</b></p>
			<ul>
				<li>Не все файлы в Linux текстовые, там есть и бинарные файлы, и важна не текстовость, а права доступа, особенно флаг исполнения.</li>
				<li>В Windows тип файла и расширение играют ключевую роль в определении, как с ним работать.</li>
			</ul>
			<p>Таким образом, разница в подходах к файловой системе и обработке файлов существенна, но не сводится к тому, что в Linux &laquo;все файлы текстовые&raquo;.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.8.4"></a></p>
			<h4>1.8.4. Команда source в Linux</h4>
			<p><b>Использование команды source и файлов начальных данных в Linux.</b></p>
			<p>В Linux команда source (или точка .) используется для выполнения команд из файла в текущем сеансе оболочки. Например, source .bashrc или source myscript.sh загружает и выполняет содержимое этих файлов, не создавая нового процесса. Это позволяет, например, задавать переменные окружения, функции и алиасы, которые будут доступны в текущей сессии.</p>
			<p>Такие файлы, как .bashrc, .profile, .bash_profile и другие, служат локальными файлами начальных данных (инициализации) для настройки среды пользователя. Они позволяют задавать переменные окружения, пути к библиотекам, алиасы и прочие настройки, которые применяются только для конкретного пользователя или сессии.</p>
			<p>В Windows такого подхода нет?</p>
			<p>В Windows нет прямого аналога команды source в командной строке cmd.exe, но в PowerShell есть похожие механизмы (например, . для dot-sourcing скриптов). Однако в классическом cmd.exe обычно переменные окружения задаются через системные настройки или через запуск отдельных скриптов, которые не влияют на текущую сессию так гибко, как в Linux.</p>
			<p><b>Зачем использовать локальные файлы начальных данных?</b></p>
			<ul>
				<li>Использование локальных файлов инициализации позволяет изолировать настройки среды, чтобы не переплетать множество библиотек и переменных между разными проектами или пользователями.</li>
				<li>Это помогает избежать конфликтов между версиями библиотек, путями и переменными окружения, делая систему более управляемой и предсказуемой.</li>
			</ul>
			<p>Таким образом, в Linux использование source и локальных файлов конфигурации — это мощный и гибкий способ управлять средой, которая действительно отличается от подходов в Windows.</p>	
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.8.5"></a></p>
			<h4>1.8.5. BAT/CMD файлы в Windows</h4>
			<p><b>BAT/CMD файлы в Windows как аналог локальных файлов инициализации в Linux.</b></p>
			<p>В Windows батники (.bat, .cmd) часто используются для задания переменных окружения, изменения путей (PATH) и запуска программ с нужными настройками. Это позволяет изолировать конфигурацию для конкретного приложения или проекта, не влияя на глобальные системные переменные.</p>
			<p>Пример с настройкой путей для Portable Python и виртуальных окружений — классический способ сделать запуск более управляемым и избежать конфликтов между разными версиями библиотек и интерпретаторов.</p>
			<p>Например, файл <b>&laquo;Python-portable-3.10.5-x64.bat&raquo;</b>.</p>
			<div class="codeses">
				<pre>@cd/d "%~dp0"
@echo off
SET PATH=%CD%\Portable-Python-3.10.5-x64\;%PATH%
SET PATH=%CD%\Portable-Python-3.10.5-x64\Scripts\;%PATH%
SET WORKON_HOME=%CD%\env-x64\
DOSKEY clear=cls
cmd.exe</pre>
			</div>
			<p>Здесь %~dp0 — путь к каталогу, где находится батник, что позволяет делать скрипт переносимым.</p>
			<p>Такой подход действительно похож на использование локальных файлов инициализации в Linux (.bashrc, source), где вы задаёте локальные переменные и пути, чтобы не "засорять" глобальную среду и избежать конфликтов.</p>
			<p><b>Отличия и особенности.</b></p>
			<ul>
				<li>В Windows переменные, заданные в батнике, действуют только в рамках запущенной сессии командной строки или дочерних процессов, если не экспортированы в системные переменные.</li>
				<li>В Linux локальные файлы инициализации влияют на текущую оболочку и дочерние процессы, что позволяет гибко управлять средой.</li>
			</ul>
			<p>Использование батников для локальной настройки среды — это действительно удобный и распространённый способ в Windows, аналогичный по идее локальным файлам инициализации и source в Linux. Это помогает сделать программы более управляемыми, изолированными и стабильными.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
			<hr>
			<p><a name="part1.9"></a></p>
			<h3>1.9. Текстовые файлы</h3>
			<p><b>Почему важно сохранять текстовые файлы в разных кодировках между Linux и Windows?</b></p>
			<p><b>Основная причина</b> — разные операционные системы традиционно используют разные кодировки для текстовых файлов, и это влияет на корректное отображение и обработку текста.</p>
			<ul>
				<li><b>Windows</b> часто использует кодировку ANSI, которая в русскоязычной среде обычно соответствует CP-1251. Эта кодировка ограничена и не поддерживает все символы Unicode, но исторически широко применялась в Windows-приложениях.</li>
				<li><b>Linux</b> и современные системы в целом предпочитают использовать кодировку UTF-8, которая является универсальной и поддерживает практически все символы всех языков мира.</li>
			</ul>
			<p>Если файл, сохранённый в Windows в ANSI (CP-1251), открыть в Linux, который ожидает UTF-8, то кириллические символы могут отображаться некорректно (абракадабра). Аналогично, если файл сохранён в UTF-8, а Windows-программа ожидает ANSI, то тоже возможны проблемы с отображением текста.</p>
			<p><b>Практические моменты.</b></p>
			<ul>
				<li>При сохранении файла в UTF-8 в Windows нужно учитывать, что консоль (cmd) по умолчанию не всегда понимает UTF-8, и для корректного отображения нужно менять кодовую страницу (chcp 65001).</li>
				<li>При сохранении в ANSI (CP-1251) для Windows-консоли обычно используется chcp 1251.</li>
				<li>Для совместимости между системами часто приходится сохранять файлы в обеих кодировках или конвертировать их, чтобы избежать проблем с отображением и обработкой текста.</li>
			</ul>
			<p><b>Важно сохранять текстовые файлы в обеих кодировках (ANSI и UTF-8), чтобы обеспечить корректное чтение и отображение текста как в Windows, так и в Linux.</b></p>
			<p>Это связано с историческими и техническими особенностями кодировок, используемых в этих ОС. UTF-8 — более универсальная и современная кодировка, но Windows-программы и консоли иногда требуют ANSI (CP-1251) для правильной работы с русским текстом. Если вы работаете в смешанной среде, лучше использовать UTF-8 и при необходимости настраивать окружение Windows для поддержки UTF-8, либо конвертировать файлы в нужную кодировку.</p>
			<p><b><u>В идеале сохранять по 2 файла в 2 разных кодировках для полной совместимости - и &laquo;ansi&raquo;, и &laquo;utf-8&raquo;.</u></b></p>
			<p><b>Почему браузеры показывают UTF-8 корректно через интернет, а локальные текстовые файлы — ANSI?</b></p>
			<p>Основная причина связана с тем, как браузеры определяют и обрабатывают кодировку текста в разных ситуациях:</p>
			<ol>
				<li>При работе через интернет (HTTP/HTTPS)</li>
				<li>При открытии локального текстового файла</li>
			</ol>
			<p>Через интернет браузеры ориентируются на явные указания кодировки (обычно UTF-8) и показывают текст правильно.</p>
			<p>При открытии локальных файлов браузер полагается на системные настройки и &laquo;угадывает&raquo; кодировку, поэтому ANSI-файлы Windows отображаются нормально, а UTF-8 без BOM — могут отображаться некорректно.</p>
			<p>Чтобы избежать проблем с локальными файлами, рекомендуется сохранять их в UTF-8 с BOM или явно указывать кодировку в HTML-файлах.</p>
			<p>Поэтому локальные файлы в ANSI часто отображаются корректно, а UTF-8 без BOM — нет.</p>
			<p>В Windows локальные текстовые файлы часто сохраняются в ANSI (например, CP-1251 для русского языка). Браузер, открывая такой файл локально, может по умолчанию использовать системную локаль или ANSI-кодировку, чтобы правильно отобразить текст. Если файл сохранён в UTF-8 без BOM (специального маркера начала файла), браузер может не распознать кодировку и показать &laquo;кракозябры&raquo;.</p>
			<p>Когда вы открываете простой текстовый файл напрямую (например, через file://), браузер не всегда получает явную информацию о кодировке. В этом случае он пытается угадать кодировку или использует системные настройки.</p>
			<p>Таким образом, при загрузке страницы из интернета браузер &laquo;знает&raquo;, что текст в UTF-8, и отображает его адекватно.</p>
			<p>Веб-серверы обычно указывают в заголовках ответа или в метатегах HTML, что содержимое страницы закодировано в UTF-8. Это стало стандартом для веба, так как UTF-8 поддерживает все языки и символы. Браузеры, получая такую информацию, корректно интерпретируют и отображают текст в UTF-8.</p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part2"></a></p>
			<h2>2. Програмное обеспечение</h2>
			<p><b>Нюансы выбора ПО.</b></p>
			<p>Есть несколько важных нюансов выбора ПО для создания действительно хороших мультизагрузочных флешек.</p>
			<ol>
				<li>Старая версия ПО.</li>
				<li>Портативная версия ПО.</li>
				<li>Создание из любой Windows.</li>
			</ol>
			<p>Дело не в том, что мне нравятся или не нравятся старые или портативные версии, а в том, что новые или свежие версии программ скорее всего не совместимы со старыми ОС - такими как Windows 7 или даже XP, если вдруг однажды понадобится. А иногда даже требуют неких дополнительных каких-то библиотек или драйверов.</p>
			<p>Создание таких флешек преимущественно отдается именно Windows, начиная с 7-ки. Но это не значит, что тоже самое вы не сможете сделать из любой другой ОС - будь то хоть Linux, хоть MacOS или буквально считай почти MSDos.</p>
			<p>Единственным исключением является только сам загрузчик Windows, начиная с 7-ки и выше - под названием <a href="#part1.7">&laquo;BCD (Boot Configuration Data)&raquo;</a>. Для него качественных альтернатив редакторов, к большому сожалению, просто нет.</p>
			<hr>
			<p><b>Програмное обеспечение.</b></p>
			<p><b>1. Первое что нам понадобится - это текстовый редактор Geany</b> (<a href="https://geany.ru/download/releases">оф. сайт</a>, <a href="https://github.com/maximalisimus/Archivers-Configs-Linux/releases/download/v3.0/Geany-Portable-1.37.1-x86-sfx.exe">Портативная версия 1.37.1 x86</a>), но не простой.</p>
			<p>В одной из глав выше я писал, что в каждой ОС и всех текстовых файлах важна кодировка. <b>В каждом загрузчике есть конфигурационные файлы</b>, которые по сути <b>являются текстовыми в определнных кодировках</b>. И чтобы их не нарушать кодировку конфигурационных файлов, лучше редактировать их сразу правильно. <u>А значит обычные встроенные в любую ОС текстовые редакторы не подойдут, именно потому что они могут испортить кодировку конфигурационных файлов загрузчиков и в итоге флешка просто не сможет загрузится</u>.</p>
			<p>Предлагаемый мною текстовый редактор не только адекватно воспринимает и сразу правильно работает с любой кодировкой, но ещё и отображает коды программирования разными цветами не зависимо от языка программирования просто для вашего удобства.</p>
			<p>Он есть как для Windows. так и для Linux и других ОС. Свежая версия для ОС от 10-ки и старше. Портативная должна работать хоть на 7-ке, хоть даже на XP, вроде бы.</p>
			<p>Если не сможете им воспользоваться, есть альтернативный текстовый редактор, но только для Windows - &laquo;Notepad ++&raquo;. Для Linux подойдут такие как: &laquo;Leafpad&raquo; и &laquo;Gedit&raquo; В консольном варианте Linux скорее всего только один редактор &laquo;Nano&raquo;, но с осторожностью.</p>
			<p><b>2. Далее нам понадобится универсальная утилита</b> <a href="https://maximalisimus.github.io/usb-loader/USB-Loader/BOOTICEx86_ru.7z">BOOTICE x86 ru</a>, русскоязычная версия.</p>
			<p>Она универсальная тем, что выступает не только как редактор разделов флешек, но и как единственный, качественный и понятный редактор <b>BCD (Boot Configuration Data)</b> файлов загрузчиков Windows.</p>
			<p><u>В Windows</u> в качестве альтернативы вполне можно воспользоваться и <u>встроенным редактором</u>, но с небольшой оговоркой - <u>он может не видеть всех разделов флешек</u>.</p>
			<p>В Linux же есть целых 2 варианта редакторов разделов - это &laquo;GParted&raquo; графический редактор разделов и консольный вариант &laquo;cfdisk&raquo;.</p>
			<p><b>3. Далее понадобится несколько архивов самих установочников загрузчиков.</b> Не волнуйсте, установка возможна не только одним единственным Bootice из Windows, но также и из Linux, и даже из MSDos, если вдруг однажды придётся.</p>
			<ul>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/grub4dos-0.4.6a-2024-02-26.7z">grub4dos-0.4.6a-2024-02-26.7z</a> или <a href="https://maximalisimus.github.io/usb-loader/USB-Loader/grubinst_1.0.1_bin_win.7z">grubinst_1.0.1_bin_win.7z</a>.</li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/syslinux-6.03.tar.gz">syslinux-6.03.tar.gz</a> или <a href="https://maximalisimus.github.io/usb-loader/USB-Loader/syslinux-5.10.tar.gz">syslinux-5.10.tar.gz</a>.</li>
			</ul>
			<p><b>4. Теперь сами загрузчики.</b></p>
			<ul>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/EFI-Grub4Dos-SysLinux-Full.7z">EFI-Grub4Dos-SysLinux-Full.7z</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/EFI-Grub4Dos-SysLinux-minimal.7z">EFI-Grub4Dos-SysLinux-minimal.7z</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/GFX-Editor1.0.exe.7z">GFX-Editor1.0.exe.7z</a></li>
			</ul>
			<p><b>5. Примеры конфигурационных файлов загрузчиков.</b></p>
			<p>Примеры всех конфигурационных файлов загрузчиков - и для GRUB4DOS, и для SysLinux, и для GRUB2 <a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/boot-info/">смотрите здесь</a>.</p>
			<p>Там вы найдете множество разных вариантов настроек для очень многих случаев любых настроек загрузки ОС - будь то хоть совместно Windows 7 + Alkid Live DVD, или Windows 10 + AlKid Live USB + Linux Mint, и многие многие другие.</p>
			<p><b>6. Остался только Qemu (<a href="https://maximalisimus.github.io/usb-loader/USB-Loader/QemuBootTester.zip">QemuBootTester.zip для Windows</a>, <a href="https://qemu.weilnetz.de/w32/">32 бит для Windows</a>, <a href="https://qemu.weilnetz.de/w64/">64 бит для Windows</a>) для тестирования загрузочных флешек.</b></p>
			<p>Для Linux установку смотрите <a href="https://www.qemu.org/download/#linux">здесь</a>.</p>
			<p>НО, в Linux еще надо установить некий GUI, иначе отображение результата не будет как такового. Например в Linux Mint - это &laquo;qemu-system-gui&raquo; кажись. Кажись, потому что в разных дистрибутивых Linux, у них даже названия разные. В Archlinux например вообще вот такой список пакетов потребуется установить: qemu-full qemu-img qemu-ui-gtk qemu-tools edk2-ovmf qemu-block-gluster qemu-block-iscsi.</p>
			<p>Понадобится еще один файлик - <a href="https://maximalisimus.github.io/usb-loader/USB-Loader/edk2-ovmf-202505-1-any.pkg.tar.gz">edk2-ovmf-202505-1-any.pkg.tar.gz</a> - имитация загрузки UEFI режима, если вы не скачивали QemuBootTester, в который она встроена, чтобы не перезагружать вашу ОС для проверки получившейся мультизагрузочной флешки.</p>
			<p><b>7. Установка самих загрузчиков.</b></p>
			<p>Инструкция установки MBR и PBR из утилиты Bootice. (Ниже список одной и той же инструкции в разных форматах для онлайн чтения)</p>
			<ul>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot_ReedMe.doc">Multiboot_ReedMe.doc</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot_ReedMe.docx">Multiboot_ReedMe.docx</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot_ReedMe.htm">Multiboot_ReedMe.htm</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot_ReedMe.pdf">Multiboot_ReedMe.pdf</a></li>
				<li><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot_ReedMe.rtf">Multiboot_ReedMe.rtf</a></li>
			</ul>
			<p><a href="https://maximalisimus.github.io/usb-loader/USB-Loader/MultiBootUSB/uefi-bios/Multiboot-Manual.txt">Инструкция установки MBR и PBR из CMD, Linux или даже MSDOs.</a></p>
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p><a name="part3"></a></p>
			<h2>3. Практика</h2>
			<p>Теперь подробно поговорим обо всех указанных в главе ПО архивах и как их использовать в любой ОС с конкретными примерами. Для этого создадим пару мултизагрузочных флешек для разных случаев.</p>
			<p>Например, пусть будут установчная флешка с Windows 10 и парой других ОС или дополнительных утилит. И флешка для простого восстановления доступа, настроек или просто ремонта.</p>
			<p>Все смежные и спользуемые внутри загрузчиков утилиты также обговорим - какая и зачем нужна.</p>
			<hr>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>
			<p></p>			
			<p><a href="#oglavlenie">Перейти к оглавлению</a>.</p>
		</div>
		<div class="content">
			<p>Ну а сегодня на этом всё. Всем Добра и Удачи!</p>
		</div>	
		<div class="about">
			<p>Copyright &copy; xx.xx.xxxx by <a href="mailto:maximalis171091@yandex.ru">Mikhail Artamonov</a></p>
		</div>
		</br>
	</div>
	<script type="text/javascript">$('.fz__minimized').litezoom({speed:400, viewTitle:true});</script>
</body>
</html>
